<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust RFC Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="0049-match-arm-attributes.html">0049-match-arm-attributes</a></li><li class="chapter-item expanded "><a href="0198-slice-notation.html">0198-slice-notation</a></li><li class="chapter-item expanded "><a href="2000-const-generics.html">2000-const-generics</a></li><li class="chapter-item expanded "><a href="2342-const-control-flow.html">2342-const-control-flow</a></li><li class="chapter-item expanded "><a href="2495-min-rust-version.html">2495-min-rust-version</a></li><li class="chapter-item expanded "><a href="2789-sparse-index.html">2789-sparse-index</a></li><li class="chapter-item expanded "><a href="3128-io-safety.html">3128-io-safety</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-rfcs---active-rfc-list"><a class="header" href="#rust-rfcs---active-rfc-list">Rust RFCs - <a href="https://rfcbot.rs/">Active RFC List</a></a></h1>
<p><strong>注意</strong>：這是官方 rust rfcs 的 fork。如果你有興趣協助翻譯的話，歡迎前往 <a href="CONTRIBUTING.html">CONTRIBUTING.md</a> 瞭解更多細節。</p>
<p><strong>Note</strong>: This is a fork of official rust rfcs. If you are interested in help translating, please have a look at <a href="CONTRIBUTING.html">CONTRIBUTING.md</a>.</p>
<p>Many changes, including bug fixes and documentation improvements can be
implemented and reviewed via the normal GitHub pull request workflow.</p>
<p>Some changes though are &quot;substantial&quot;, and we ask that these be put through a
bit of a design process and produce a consensus among the Rust community and
the <a href="http://www.rust-lang.org/team.html">sub-team</a>s.</p>
<p>The &quot;RFC&quot; (request for comments) process is intended to provide a consistent
and controlled path for new features to enter the language and standard
libraries, so that all stakeholders can be confident about the direction the
language is evolving in.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="introduction.html#rust-rfcs">Opening</a></li>
<li><a href="introduction.html#table-of-contents">Table of Contents</a></li>
<li><a href="introduction.html#when-you-need-to-follow-this-process">When you need to follow this process</a></li>
<li><a href="introduction.html#before-creating-an-rfc">Before creating an RFC</a></li>
<li><a href="introduction.html#what-the-process-is">What the process is</a></li>
<li><a href="introduction.html#the-rfc-life-cycle">The RFC life-cycle</a></li>
<li><a href="introduction.html#reviewing-rfcs">Reviewing RFCs</a></li>
<li><a href="introduction.html#implementing-an-rfc">Implementing an RFC</a></li>
<li><a href="introduction.html#rfc-postponement">RFC Postponement</a></li>
<li><a href="introduction.html#help-this-is-all-too-informal">Help this is all too informal!</a></li>
<li><a href="introduction.html#license">License</a></li>
</ul>
<h2 id="when-you-need-to-follow-this-process"><a class="header" href="#when-you-need-to-follow-this-process">When you need to follow this process</a></h2>
<p>You need to follow this process if you intend to make &quot;substantial&quot; changes to
Rust, Cargo, Crates.io, or the RFC process itself. What constitutes a
&quot;substantial&quot; change is evolving based on community norms and varies depending
on what part of the ecosystem you are proposing to change, but may include the
following.</p>
<ul>
<li>Any semantic or syntactic change to the language that is not a bugfix.</li>
<li>Removing language features, including those that are feature-gated.</li>
<li>Changes to the interface between the compiler and libraries, including lang
items and intrinsics.</li>
<li>Additions to <code>std</code>.</li>
</ul>
<p>Some changes do not require an RFC:</p>
<ul>
<li>Rephrasing, reorganizing, refactoring, or otherwise &quot;changing shape does
not change meaning&quot;.</li>
<li>Additions that strictly improve objective, numerical quality criteria
(warning removal, speedup, better platform coverage, more parallelism, trap
more errors, etc.)</li>
<li>Additions only likely to be <em>noticed by</em> other developers-of-rust,
invisible to users-of-rust.</li>
</ul>
<p>If you submit a pull request to implement a new feature without going through
the RFC process, it may be closed with a polite request to submit an RFC first.</p>
<h3 id="sub-team-specific-guidelines"><a class="header" href="#sub-team-specific-guidelines">Sub-team specific guidelines</a></h3>
<p>For more details on when an RFC is required for the following areas, please see
the Rust community's <a href="http://www.rust-lang.org/team.html">sub-team</a> specific guidelines for:</p>
<ul>
<li><a href="lang_changes.html">language changes</a>,</li>
<li><a href="libs_changes.html">library changes</a>,</li>
<li><a href="compiler_changes.html">compiler changes</a>.</li>
</ul>
<h2 id="before-creating-an-rfc"><a class="header" href="#before-creating-an-rfc">Before creating an RFC</a></h2>
<p>A hastily-proposed RFC can hurt its chances of acceptance. Low quality
proposals, proposals for previously-rejected features, or those that don't fit
into the near-term roadmap, may be quickly rejected, which can be demotivating
for the unprepared contributor. Laying some groundwork ahead of the RFC can
make the process smoother.</p>
<p>Although there is no single way to prepare for submitting an RFC, it is
generally a good idea to pursue feedback from other project developers
beforehand, to ascertain that the RFC may be desirable; having a consistent
impact on the project requires concerted effort toward consensus-building.</p>
<p>The most common preparations for writing and submitting an RFC include talking
the idea over on our <a href="https://discord.gg/rust-lang">official Discord server</a>, discussing the topic on our
<a href="http://internals.rust-lang.org/">developer discussion forum</a>, and occasionally posting &quot;pre-RFCs&quot; on the
developer forum. You may file issues on this repo for discussion, but these are
not actively looked at by the teams.</p>
<p>As a rule of thumb, receiving encouraging feedback from long-standing project
developers, and particularly members of the relevant <a href="http://www.rust-lang.org/team.html">sub-team</a> is a good
indication that the RFC is worth pursuing.</p>
<h2 id="what-the-process-is"><a class="header" href="#what-the-process-is">What the process is</a></h2>
<p>In short, to get a major feature added to Rust, one must first get the RFC
merged into the RFC repository as a markdown file. At that point the RFC is
&quot;active&quot; and may be implemented with the goal of eventual inclusion into Rust.</p>
<ul>
<li>Fork the RFC repo <a href="http://github.com/rust-lang/rfcs">RFC repository</a></li>
<li>Copy <code>0000-template.md</code> to <code>text/0000-my-feature.md</code> (where &quot;my-feature&quot; is
descriptive). Don't assign an RFC number yet; This is going to be the PR
number and we'll rename the file accordingly if the RFC is accepted.</li>
<li>Fill in the RFC. Put care into the details: RFCs that do not present
convincing motivation, demonstrate lack of understanding of the design's
impact, or are disingenuous about the drawbacks or alternatives tend to
be poorly-received.</li>
<li>Submit a pull request. As a pull request the RFC will receive design
feedback from the larger community, and the author should be prepared to
revise it in response.</li>
<li>Each pull request will be labeled with the most relevant <a href="http://www.rust-lang.org/team.html">sub-team</a>, which
will lead to its being triaged by that team in a future meeting and assigned
to a member of the subteam.</li>
<li>Build consensus and integrate feedback. RFCs that have broad support are
much more likely to make progress than those that don't receive any
comments. Feel free to reach out to the RFC assignee in particular to get
help identifying stakeholders and obstacles.</li>
<li>The sub-team will discuss the RFC pull request, as much as possible in the
comment thread of the pull request itself. Offline discussion will be
summarized on the pull request comment thread.</li>
<li>RFCs rarely go through this process unchanged, especially as alternatives
and drawbacks are shown. You can make edits, big and small, to the RFC to
clarify or change the design, but make changes as new commits to the pull
request, and leave a comment on the pull request explaining your changes.
Specifically, do not squash or rebase commits after they are visible on the
pull request.</li>
<li>At some point, a member of the subteam will propose a &quot;motion for final
comment period&quot; (FCP), along with a <em>disposition</em> for the RFC (merge, close,
or postpone).
<ul>
<li>This step is taken when enough of the tradeoffs have been discussed that
the subteam is in a position to make a decision. That does not require
consensus amongst all participants in the RFC thread (which is usually
impossible). However, the argument supporting the disposition on the RFC
needs to have already been clearly articulated, and there should not be a
strong consensus <em>against</em> that position outside of the subteam. Subteam
members use their best judgment in taking this step, and the FCP itself
ensures there is ample time and notification for stakeholders to push back
if it is made prematurely.</li>
<li>For RFCs with lengthy discussion, the motion to FCP is usually preceded by
a <em>summary comment</em> trying to lay out the current state of the discussion
and major tradeoffs/points of disagreement.</li>
<li>Before actually entering FCP, <em>all</em> members of the subteam must sign off;
this is often the point at which many subteam members first review the RFC
in full depth.</li>
</ul>
</li>
<li>The FCP lasts ten calendar days, so that it is open for at least 5 business
days. It is also advertised widely,
e.g. in <a href="https://this-week-in-rust.org/">This Week in Rust</a>. This way all
stakeholders have a chance to lodge any final objections before a decision
is reached.</li>
<li>In most cases, the FCP period is quiet, and the RFC is either merged or
closed. However, sometimes substantial new arguments or ideas are raised,
the FCP is canceled, and the RFC goes back into development mode.</li>
</ul>
<h2 id="the-rfc-life-cycle"><a class="header" href="#the-rfc-life-cycle">The RFC life-cycle</a></h2>
<p>Once an RFC becomes &quot;active&quot; then authors may implement it and submit the
feature as a pull request to the Rust repo. Being &quot;active&quot; is not a rubber
stamp, and in particular still does not mean the feature will ultimately be
merged; it does mean that in principle all the major stakeholders have agreed
to the feature and are amenable to merging it.</p>
<p>Furthermore, the fact that a given RFC has been accepted and is &quot;active&quot;
implies nothing about what priority is assigned to its implementation, nor does
it imply anything about whether a Rust developer has been assigned the task of
implementing the feature. While it is not <em>necessary</em> that the author of the
RFC also write the implementation, it is by far the most effective way to see
an RFC through to completion: authors should not expect that other project
developers will take on responsibility for implementing their accepted feature.</p>
<p>Modifications to &quot;active&quot; RFCs can be done in follow-up pull requests. We
strive to write each RFC in a manner that it will reflect the final design of
the feature; but the nature of the process means that we cannot expect every
merged RFC to actually reflect what the end result will be at the time of the
next major release.</p>
<p>In general, once accepted, RFCs should not be substantially changed. Only very
minor changes should be submitted as amendments. More substantial changes
should be new RFCs, with a note added to the original RFC. Exactly what counts
as a &quot;very minor change&quot; is up to the sub-team to decide; check
<a href="introduction.html#sub-team-specific-guidelines">Sub-team specific guidelines</a> for more details.</p>
<h2 id="reviewing-rfcs"><a class="header" href="#reviewing-rfcs">Reviewing RFCs</a></h2>
<p>While the RFC pull request is up, the sub-team may schedule meetings with the
author and/or relevant stakeholders to discuss the issues in greater detail,
and in some cases the topic may be discussed at a sub-team meeting. In either
case a summary from the meeting will be posted back to the RFC pull request.</p>
<p>A sub-team makes final decisions about RFCs after the benefits and drawbacks
are well understood. These decisions can be made at any time, but the sub-team
will regularly issue decisions. When a decision is made, the RFC pull request
will either be merged or closed. In either case, if the reasoning is not clear
from the discussion in thread, the sub-team will add a comment describing the
rationale for the decision.</p>
<h2 id="implementing-an-rfc"><a class="header" href="#implementing-an-rfc">Implementing an RFC</a></h2>
<p>Some accepted RFCs represent vital features that need to be implemented right
away. Other accepted RFCs can represent features that can wait until some
arbitrary developer feels like doing the work. Every accepted RFC has an
associated issue tracking its implementation in the Rust repository; thus that
associated issue can be assigned a priority via the triage process that the
team uses for all issues in the Rust repository.</p>
<p>The author of an RFC is not obligated to implement it. Of course, the RFC
author (like any other developer) is welcome to post an implementation for
review after the RFC has been accepted.</p>
<p>If you are interested in working on the implementation for an &quot;active&quot; RFC, but
cannot determine if someone else is already working on it, feel free to ask
(e.g. by leaving a comment on the associated issue).</p>
<h2 id="rfc-postponement"><a class="header" href="#rfc-postponement">RFC Postponement</a></h2>
<p>Some RFC pull requests are tagged with the &quot;postponed&quot; label when they are
closed (as part of the rejection process). An RFC closed with &quot;postponed&quot; is
marked as such because we want neither to think about evaluating the proposal
nor about implementing the described feature until some time in the future, and
we believe that we can afford to wait until then to do so. Historically,
&quot;postponed&quot; was used to postpone features until after 1.0. Postponed pull
requests may be re-opened when the time is right. We don't have any formal
process for that, you should ask members of the relevant sub-team.</p>
<p>Usually an RFC pull request marked as &quot;postponed&quot; has already passed an
informal first round of evaluation, namely the round of &quot;do we think we would
ever possibly consider making this change, as outlined in the RFC pull request,
or some semi-obvious variation of it.&quot; (When the answer to the latter question
is &quot;no&quot;, then the appropriate response is to close the RFC, not postpone it.)</p>
<h3 id="help-this-is-all-too-informal"><a class="header" href="#help-this-is-all-too-informal">Help this is all too informal!</a></h3>
<p>The process is intended to be as lightweight as reasonable for the present
circumstances. As usual, we are trying to let the process be driven by
consensus and community norms, not impose more structure than necessary.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>This repository is currently in the process of being licensed under either of:</p>
<ul>
<li>Apache License, Version 2.0, (<a href="LICENSE-APACHE">LICENSE-APACHE</a> or http://www.apache.org/licenses/LICENSE-2.0)</li>
<li>MIT license (<a href="LICENSE-MIT">LICENSE-MIT</a> or http://opensource.org/licenses/MIT)</li>
</ul>
<p>at your option. Some parts of the repository are already licensed according to those terms. For more see <a href="https://github.com/rust-lang/rfcs/pull/2044">RFC 2044</a> and its <a href="https://github.com/rust-lang/rust/issues/43461">tracking issue</a>.</p>
<h3 id="contributions"><a class="header" href="#contributions">Contributions</a></h3>
<p>Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2014-03-20</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/49">rust-lang/rfcs#49</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/12812">rust-lang/rust#12812</a></li>
<li>Translators: [<a href="https://github.com/FizzyElt">@FizzyElt</a>]</li>
<li>Commit: <a href="https://github.com/rust-lang/rfcs/blob/0e2baed56a1d31a65f58f4cb615eedfaad59c2e3/text/0049-match-arm-attributes.md">The commit link this page based on</a></li>
<li>Updated: 2022-05-17</li>
</ul>
<h1 id="概要"><a class="header" href="#概要">概要</a></h1>
<p>允許屬性在配對分支上</p>
<h1 id="動機"><a class="header" href="#動機">動機</a></h1>
<p>有時希望使用屬性來注釋配對語句的分支，例如條件編譯 <code>#[cfg]</code> 或是分支權重（後者為最重要的用途）。</p>
<p>對於條件編譯，暫時得解決辦法是使用 <code>#[cfg]</code> 來重複宣告相同函式來處理不同的案例。一個案例研究是 <a href="https://github.com/sfackler/rust-openssl">sfackler 的 bindings to OpenSSL</a>，在多數的發行版本中移除了 SSLv2 支持，因此 Rust bindings 部分需要被條件禁用。支援各種不同 SSL 版本最顯而易見的方法是使用枚舉。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum SslMethod {
    #[cfg(sslv2)]
    /// Only support the SSLv2 protocol
    Sslv2,
    /// Only support the SSLv3 protocol
    Sslv3,
    /// Only support the TLSv1 protocol
    Tlsv1,
    /// Support the SSLv2, SSLv3 and TLSv1 protocols
    Sslv23,
}
<span class="boring">}
</span></code></pre></pre>
<p>然而，所有的 <code>match</code> 只能在 <code>cfg</code> 啟用時使用 <code>Sslv2</code>，例如下面內容是無效的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn name(method: SslMethod) -&gt; &amp;'static str {
    match method {
        Sslv2 =&gt; &quot;SSLv2&quot;,
        Sslv3 =&gt; &quot;SSLv3&quot;,
        _ =&gt; &quot;...&quot;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>一個有效的方法則必須有兩個定義：<code>#[cfg(sslv2)] fn name(...)</code> 和 <code>#[cfg(not(sslv2)] fn name(...)</code>
。前者有 <code>Sslv2</code> 的分支，後者沒有。顯然，對於枚舉中每個額外的 <code>cfg</code> 變體，這都會以指數型的方式爆炸。</p>
<p>分支權重將允許仔細的微優化器（micro-optimiser）通知編譯器，例如，鮮少採取某個配對分支：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match foo {
    Common =&gt; {}
    #[cold]
    Rare =&gt; {}
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="詳細設計"><a class="header" href="#詳細設計">詳細設計</a></h1>
<p>一般的屬性語法，應用於整個配對分支。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match x {
    #[attr]
    Thing =&gt; {}

    #[attr]
    Foo | Bar =&gt; {}

    #[attr]
    _ =&gt; {}
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="替代方案"><a class="header" href="#替代方案">替代方案</a></h1>
<p>實際上沒有通用的替代方案; 人們也許可以用一些巨集（macro）和輔助函數來解決條件枚舉變體的配對問題; 但一般來說，這起不了任何作用。</p>
<h1 id="未解決的問題"><a class="header" href="#未解決的問題">未解決的問題</a></h1>
<p>無</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2014-09-11</li>
<li>RFC PR #: <a href="https://github.com/rust-lang/rfcs/pull/198">rust-lang/rfcs#198</a></li>
<li>Rust Issue #: <a href="https://github.com/rust-lang/rust/issues/17177">rust-lang/rust#17177</a></li>
<li>Translators: [<a href="https://github.com/FizzyElt">@FizzyElt</a>]</li>
<li>Commit: <a href="https://github.com/rust-lang/rfcs/blob/4009b546172c558a1cfa0f39dd81c896312f73d5/text/0198-slice-notation.md">The commit link this page based on</a></li>
<li>Updated: 2022-05-27</li>
</ul>
<h1 id="概要-1"><a class="header" href="#概要-1">概要</a></h1>
<p>此 RFC 增加了<em>多載切片符號</em>：</p>
<ul>
<li><code>foo[]</code> 對應 <code>foo.as_slice()</code></li>
<li><code>foo[n..m]</code> 對應 <code>foo.slice(n, m)</code></li>
<li><code>foo[n..]</code> 對應 <code>foo.slice_from(n)</code></li>
<li><code>foo[..m]</code> 對應 <code>foo.slice_to(m)</code></li>
<li>以上所有的 <code>mut</code> 變體</li>
</ul>
<p>透過<code>Slice</code> 跟 <code>SliceMut</code> 兩個新特徵（trait）。</p>
<p>它還將 範圍<code>配對</code>模式的符號改為 <code>...</code>，以表示它們是包含的，而 <code>..</code> 在切片中是不包含的。</p>
<h1 id="動機-1"><a class="header" href="#動機-1">動機</a></h1>
<p>引入此功能有兩個主要動機。</p>
<h3 id="人因工程"><a class="header" href="#人因工程">人因工程</a></h3>
<p>在處理 vector 或其他類型的容器時，切片操作（特別是 <code>as_slice</code>）是相當常見的基本操作。我們已經有了透過 <code>Index</code> 特徵進行索引的語法，此 RFC 本質上是這特徵的延續。</p>
<p><code>as_slice</code> 運算子尤其重要，自從我們已經擺脫以強迫的方式自動切片，明確地呼叫 <code>as_slice</code> 變得非常普遍，這也是語言中<a href="https://github.com/rust-lang/rust/issues/14983">人因工程優先/第一印象</a>的問題之一。還有一些其他方法可以解決這個特定問題，但這些替代方法具有下方討論的一些缺點（參閱「替代方案」）。</p>
<h3 id="錯誤處理協定"><a class="header" href="#錯誤處理協定">錯誤處理協定</a></h3>
<p>我們正在逐漸走向一個類似 Python 的世界，像是當 <code>n</code> 超出範圍時，<code>foo[n]</code> 會呼叫 <code>fail!</code>，而相應的方法像是 <code>get</code> 則返回 <code>Option</code> 而不是失敗。透過為切片提供類似的符號，我們打開了在整個 vector-like APIs 中遵循相同協定的大門。</p>
<h1 id="詳細設計-1"><a class="header" href="#詳細設計-1">詳細設計</a></h1>
<p>此設計是對 <code>Index</code> 特徵設計的直接延續。我們引入了兩個新特徵（trait），用於不可變與可變切片：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Slice&lt;Idx, S&gt; {
    fn as_slice&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a S;
    fn slice_from(&amp;'a self, from: Idx) -&gt; &amp;'a S;
    fn slice_to(&amp;'a self, to: Idx) -&gt; &amp;'a S;
    fn slice(&amp;'a self, from: Idx, to: Idx) -&gt; &amp;'a S;
}

trait SliceMut&lt;Idx, S&gt; {
    fn as_mut_slice&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut S;
    fn slice_from_mut(&amp;'a mut self, from: Idx) -&gt; &amp;'a mut S;
    fn slice_to_mut(&amp;'a mut self, to: Idx) -&gt; &amp;'a mut S;
    fn slice_mut(&amp;'a mut self, from: Idx, to: Idx) -&gt; &amp;'a mut S;
}
<span class="boring">}
</span></code></pre></pre>
<p>（請注意，此處的可變名稱是命名規則可能更改的一部分，將在單獨的 RFC 中描述）。</p>
<p>這些特徵將在解釋以下符號時使用：</p>
<p><em>不可變切片</em></p>
<ul>
<li><code>foo[]</code> 對應 <code>foo.as_slice()</code></li>
<li><code>foo[n..m]</code> 對應 <code>foo.slice(n, m)</code></li>
<li><code>foo[n..]</code> 對應 <code>foo.slice_from(n)</code></li>
<li><code>foo[..m]</code> 對應 <code>foo.slice_to(m)</code></li>
</ul>
<p><em>可變切片</em></p>
<ul>
<li><code>foo[mut]</code> 對應 <code>foo.as_mut_slice()</code></li>
<li><code>foo[mut n..m]</code> 對應 <code>foo.slice_mut(n, m)</code></li>
<li><code>foo[mut n..]</code> 對應 <code>foo.slice_from_mut(n)</code></li>
<li><code>foo[mut ..m]</code> 對應 <code>foo.slice_to_mut(m)</code></li>
</ul>
<p>像 <code>Index</code> 一樣，這種表示法的使用將自動取值，就如同對應的方法調用一樣。因此，如果 <code>T</code> 實現了 <code>Slice&lt;uint, [U]&gt;</code> 和 <code>s: Smaht&lt;T&gt;</code>，那麼 <code>s[]</code> 就可以編譯並具有 <code>&amp;[U]</code> 類型。</p>
<p>請注意，切片是「不包含」（因此 <code>[n..m]</code> 是等於 <code>n &lt;= x &lt; m</code>），而模式配對中的 <code>..</code> 是「包含」。為了避免混淆，我們建議將配對符號更改為 <code>...</code> 來做出區別。更改符號而不是解釋的原因是，「不包含」（分別「包含」）解釋是切片（相較於「配對」）的正確默認值。</p>
<h2 id="使用此語法的基本理由"><a class="header" href="#使用此語法的基本理由">使用此語法的基本理由</a></h2>
<p>用於切片的方括號的選擇很簡單：它與我們的索引表示法契合，並且切片和索引密切相關。</p>
<p>其他一些語言（如 Python 和 Go 和 Fortran）在切片表示法中使用 <code>:</code> 而不是 <code>..</code>。在 Rust 中，<code>..</code> 的選擇受到 Rust 本身其他地方的使用影響，例如固定長度陣列類型 <code>[T, ..n]</code>。用於切片的 <code>..</code> 在 Perl 和 D 中有先例。</p>
<p>有關程式語言中切片表示法歷史的更多資訊，請參閱 <a href="http://en.wikipedia.org/wiki/Array_slicing">維基百科</a>。</p>
<h3 id="mut-限定符"><a class="header" href="#mut-限定符"><code>mut</code> 限定符</a></h3>
<p>可能令人驚訝的是，<code>mut</code> 在建議的切片表示法中作為限定符，而不是用於索引表示法。原因是索引包含隱式取消引用。假如 <code>v: Vec&lt;Foo&gt;</code> 則 <code>v[n]</code> 的類型為 <code>Foo</code>，而不是 <code>&amp;Foo</code> 或 <code>&amp;mut Foo</code>。因此，如果你想透過索引取得可變引用，你可以寫成 <code>&amp;mut v[n]</code>。更廣泛地說，這允許我們在解決可變性之前進行解析/類型檢查。</p>
<p>這種對 <code>Index</code> 的處理符合 C 的傳統，並允許我們寫成 <code>v[0] = foo</code>，而不是 <code>*v[0] = foo</code>。</p>
<p>另一方面，這種方法對於切片是有問題的，因為一般來說，他會產生一個 unsized 類型（在 DST 中），當然，切片是為了給你一個指向切片大小的胖指標，我們不希望立即取消引用。但是，這樣的結果是，我們需要預先知道切片的可變性，因為它決定了表達式的類型。</p>
<h1 id="缺點"><a class="header" href="#缺點">缺點</a></h1>
<p>主要的缺點是增加了語言語法的複雜度。這看起來微不足道，尤其是因為這裡的符號本質上是 &quot;完成&quot; 以 <code>Index</code> 特徵開始的內容。</p>
<h2 id="設計上的限制"><a class="header" href="#設計上的限制">設計上的限制</a></h2>
<p>與 <code>Index</code> 特徵一樣，這迫使結果透過 <code>＆</code> 成為一個引用，這可能會排除切片的普遍化。</p>
<p>解決此問題的一個方法是切片方法使用 <code>self</code> （依值) 而不是 <code>&amp;self</code>，反過來在 <code>&amp;T</code> 而不是 <code>T</code> 上實現特徵。這個方法是否長期可行將取決於方法解析和自動引用的最終規則。</p>
<p>一般來說，當特徵可以應用於類型 <code>T</code> 而不是借用類型 <code>&amp;T</code> 時，特徵系統運作的最好。最終，如果 Rust 獲得了更高的類型（HKT），我們可以將特徵中的切片類型 <code>S</code> 更改為更高的類型，這樣他就是一個由生命週期索引的類型<em>家族</em>。然後，我們可以用 <code>S&lt;'a&gt;</code> 來代替返回值中的 <code>&amp;'a S</code>。在未來，我們應該可以從當前的 <code>Index</code> 和 <code>Slice</code> 特徵設計轉換到一個 HKT 版本，而不會破壞相後的兼容性，方法是對實現舊特徵的類型使用新特徵的全面實現（例如 <code>IndexHKT</code>）。</p>
<h1 id="替代方案-1"><a class="header" href="#替代方案-1">替代方案</a></h1>
<p>對於改善 <code>as_slice</code> 的易用性，有兩個主要替代方案。</p>
<h2 id="強制-自動切片"><a class="header" href="#強制-自動切片">強制: 自動切片</a></h2>
<p>一種可能性是重新引入某種自動切片的強制。我們曾經有一個從（用現今的話來說）<code>Vec&lt;T&gt;</code> 到 <code>&amp;[T]</code> 的強制轉換。由於我們不再強制擁有借來的值，我們現在可能想要一個強制 <code>&amp;Vec&lt;T&gt;</code> 到 <code>&amp;[T]</code> 的轉換：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn use_slice(t: &amp;[u8]) { ... }

let v = vec!(0u8, 1, 2);
use_slice(&amp;v)           // automatically coerce here
use_slice(v.as_slice()) // equivalent
<span class="boring">}
</span></code></pre></pre>
<p>不幸的是，添加這樣的強制需要在以下選項中進行選擇：</p>
<ul>
<li>
<p>將強制與 <code>Vec</code> 和 <code>String</code> 連繫起來，這將重新引入對這些原本純粹的函式庫類型的特殊處理，並且意味著其他支援切片的函數庫類型不會受益（違背了一些 DST 的目的）。</p>
</li>
<li>
<p>透過特徵使強制可擴展。然而這是在打開潘朵拉的盒子：這個機制很可能被用來在強制的過程中運行任意的程式碼，所以任何呼叫 <code>foo(a, b, c)</code> 都可能涉及運行程式碼來預處理每個參數。雖然我們最終可能想要這種使用者可擴展的強制機制，但在理解程式碼時，這是一個很<strong>大</strong>的步驟，有很多潛在的不利因素，所以我們應該先追求更保守的解決方案。</p>
</li>
</ul>
<h2 id="解引用"><a class="header" href="#解引用">解引用</a></h2>
<p>另一種可能是讓 <code>String</code> 實現 <code>Deref&lt;str&gt;</code> 和 <code>Vec&lt;T&gt;</code> 實現 <code>Deref&lt;[T]&gt;</code> 一旦 DST 登陸。這樣做將允許顯式的強制機制，例如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn use_slice(t: &amp;[u8]) { ... }

let v = vec!(0u8, 1, 2);
use_slice(&amp;*v)          // take advantage of deref
use_slice(v.as_slice()) // equivalent
<span class="boring">}
</span></code></pre></pre>
<p>但是，這樣做至少有兩個缺點：</p>
<ul>
<li>
<p>目前不清楚方法解析規則最終將如何與 <code>Deref</code> 互動。特別是，一個領先的提議是，對於一個智慧指標 <code>s: Smaht&lt;T&gt;</code> ，當你呼叫 <code>s.m(...)</code> 時，對於 <code>Smaht&lt;T&gt;</code> 只有 <em>內置</em> 方法 <code>m</code> 被考慮到；僅考慮最大引用值 <code>*s</code> 的特徵方法。</p>
<p>使用這樣的解析策略，為 <code>Vec</code> 實現 <code>Deref</code> 將使得我們無法在 <code>Vec</code> 類型上使用特徵方法 ，除非透過 UFCS，這嚴重限制了程式設計師為 <code>Vec</code> 有效地實現新特徵的能力。</p>
</li>
<li>
<p>將 <code>Vec</code> 作為一個圍繞切片的智慧指標的想法，以及如上所述的 <code>&amp;*v</code> 的使用，有點違反直覺，特別是對於這樣的基本類型。</p>
</li>
</ul>
<p>追根究底，無論如何，切片的符號本身似乎是可取的，如果它能消除對 <code>Vec</code> 和 <code>String</code> 實現 <code>Deref</code> 的需要，那就更好了。</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature Name: <code>const_generics</code></li>
<li>Start Date: 2017-05-01</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/2000">rust-lang/rfcs#2000</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/44580">rust-lang/rust#44580</a></li>
<li>Translators: [<a href="https://github.com/yanganto">@yanganto</a>]</li>
<li>Commit: <a href="https://github.com/rust-tw/rfcs-tw/blob/725bf172f383a21cf74189feb5073705778d2206/text/2000-const-generics.md">The commit link this page based on</a></li>
<li>Updated: 2021-03-26</li>
</ul>
<h1 id="總結"><a class="header" href="#總結">總結</a></h1>
<p>允許所有型別（type）以作為常數值（constant values）的形式成為泛型（generic），這能讓使用者用 <code>impl</code> 寫出所有陣列型別（array types）。</p>
<h1 id="動機-2"><a class="header" href="#動機-2">動機</a></h1>
<p>現在的 Rust 有一種將常數參數化（parametric）型別︰內建的陣列型別 <code>[T; LEN]</code>。然而，常數泛型（const generics）並非第一級別的功能，使用者無法自己定義將常數值作爲泛型的型別，且不能對所有的陣列實作特徵（traits）。</p>
<p>在此限制下，標準庫僅包含長度最多到 32 的陣列實作，而陣列也因此被視爲語言的第二級別的功能。即使在長度可靜態已知的情形下，也大多調配於堆（heap）上成為向量（vector）而非使用陣列型別，因而造成一定程度上的效能取捨。</p>
<p>常數參數也能讓使用者更自然地指定一個泛型變體（variant）, 且相比於型別更能確切地反應其值。舉例來說，基於某些因素有個型別用一個名稱來作為參數的話，使用 <code>&amp;'static str</code> 來提供其名稱會比（藉由相關的常數或是函式提供的）單元型別（unit type）的形式還來的合理，這能簡化 API。</p>
<p>總結來說，常數可作爲參數使用，讓編譯器在型別檢查時期能確定這些數值。藉由限制哪些數值是否有實作過特定的特徵，孤兒規則（orphan rules）可以確保一個 crate 僅使用部份安全的數值。（例如有關密碼學的相關函式庫）</p>
<h1 id="設計細節"><a class="header" href="#設計細節">設計細節</a></h1>
<p>現今 Rust 中的型別有兩種參數化的形式︰型別與生命周期。如同在編譯時能推導出這些數值，我們將額外的允許型別將數值參數化。一個常數參數必為單一、特定型別，且可以有效的替換為編譯時期計算出的任意值且該型別將符合本 RFC 以下列出的要求。</p>
<p>（為明確在此 RFC 闡明哪些表達式可在編譯時評估，在之後的範例中，我們假設整數及其基本算數操作可以在編譯時計算。）</p>
<h2 id="詞彙表"><a class="header" href="#詞彙表">詞彙表</a></h2>
<ul>
<li>
<p><b>常數（constant, const value）︰</b>一個在編譯時期可以保證完全評估的 Rust 數值。不同於靜態數值（static），常數將在其使用的位置 inline 而非存在於編譯好的二進制檔案的資料區段。</p>
</li>
<li>
<p><b>常數參數、泛型常數（const parameter, generic const）︰</b>一個由型別或函式抽象而得到的常數。此常數是具體型別的輸入值，例如一個靜態陣列的長度。</p>
</li>
<li>
<p><b>關聯常數（associated const）︰</b>一個由特徵關聯而得到的常數，其相似於關聯型別。不同於常數參數，關聯常數是由型別所決定的。</p>
</li>
<li>
<p><b>常數變數（const variable）︰</b>相比於具體常數，常數參數或關聯常數皆為常數變數。在單態化（monomorphization）之前，一個常數在上下文中是未確定的。</p>
</li>
<li>
<p><b>具體常數（concrete const）︰</b>相比於常數變數，一個在上下文中已知且單一值的常數。</p>
</li>
<li>
<p><b>常數表達式（const expression）︰</b>一個用於評估一個常數的表達式。此可為一個身份表達式或一個在 Rust 常數系統中可以評估出的更複雜的表達式。</p>
</li>
<li>
<p><b>抽象常數表達式（abstract const expression）︰</b>一個包含常數變數的表達式。（因此在單態化結束前其值是無法評估的）</p>
</li>
<li>
<p><b>常數投影（const projection）︰</b>抽象常數表達式的數值（其在泛型上下文中因缺乏所依賴的常數變數而無法被定義）</p>
</li>
<li>
<p><b>身份表達式（identity expression）︰</b>一個在不以其範圍內的名稱進行置換則無法評估的表達式。此包括了所有的文字及身份（ident），例如，<code>3</code>、<code>&quot;Hello, world&quot;</code>、<code>foo_bar</code>。</p>
</li>
</ul>
<h2 id="宣告常數參數"><a class="header" href="#宣告常數參數">宣告常數參數</a></h2>
<p>在型別參數宣告的任何序列中都可以宣告常數參數（例如在一個型別的定義中或是在 <code>impl</code> 的標頭或區塊（block）中）。常數參數的格式爲 <code>const $ident: $ty</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RectangularArray&lt;T, const WIDTH: usize, const HEIGHT: usize&gt; {
    array: [[T; WIDTH]; HEIGHT],
}
<span class="boring">}
</span></code></pre></pre>
<p>這些宣告的身份（ident）就是常數參數（在本 RFC 內文中可替稱作「常數變數」）的名稱，而且所有數值必定其推導的型別。本 RFC 後文將說明能被推導的型別有哪些限制。</p>
<p>宣告的常數變數範圍在該項目（type、impl、function、method、…等等）的整體範圍中。</p>
<h2 id="套用常數作為參數"><a class="header" href="#套用常數作為參數">套用常數作為參數</a></h2>
<p>任何可推導出該常數參數型別的常數表達式都可作爲參數。除了陣列外，當套用一個表達式作為常數參數且該表達式並非身份表達式時，該表達式必須包含在區塊內 。此語法上的限制是必要的，以避免在型別中解析表達式需要無限地向前展望（lookahead）。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const X: usize = 7;

let x: RectangularArray&lt;i32, 2, 4&gt;;
let y: RectangularArray&lt;i32, X, {2 * 2}&gt;;
<span class="boring">}
</span></code></pre></pre>
<h3 id="陣列"><a class="header" href="#陣列">陣列</a></h3>
<p>陣列語法中有一個特別的構造語法：<code>[T; CONST]</code>。在陣列中大括號不需要存在於任何的常數表達式中，<code>[i32; N * 2]</code> 是一個合理的型別。</p>
<h2 id="何時可使用常數變數"><a class="header" href="#何時可使用常數變數">何時可使用常數變數</a></h2>
<p>常數變數可使用於下列上下文之任一項中︰</p>
<ol>
<li>用於任一型別中的常數，該型別是待定項目之簽章（signature）的一部份：<code>fn foo&lt;const N: usize&gt;(arr: [i32; N])</code></li>
<li>用於定義相關常數的常數表達式或相關型別之參數的一部份</li>
<li>在項目中任何函式的內部之任何運行時表達式中的數值</li>
<li>在項目中任何函式內部用於任何型別的參數，例如在 <code>let x: [i32; N]</code> 或 <code>&lt;[i32; N] as Foo&gt;::bar()</code>。</li>
<li>在項目中任何欄位之型別的一部分（如 <code>struct Foo&lt;const N: usize&gt;([i32; N]);</code>）</li>
</ol>
<p>在一般情況下，常數變數可以用做常數。但有一個明顯的例外是，常數變數不可用於常數、靜態型別、函式、或函式內的型別的建構子，意即下面的例子是不合規的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;const X: usize&gt;() {
    const Y: usize = X * 2;
    static Z: (usize, usize)= (X, X);

    struct Foo([i32; X]);
}
<span class="boring">}
</span></code></pre></pre>
<p>這樣的限制就如同型別型別不能用在函式本體中建造的型別一樣。所有的宣告雖然專用於該項目，但也必需獨立於它，且不能有任何在其範圍內的參數。</p>
<h2 id="兩個常數的型別相等性之相等原則"><a class="header" href="#兩個常數的型別相等性之相等原則">兩個常數的型別相等性之相等原則</a></h2>
<p>在統一且重疊的檢查期間，何時兩個型別是否相等是關重要的。因為型別現在可依賴於常數了，所以我們必須定義我們如何比較兩個常數表達式的相等性。</p>
<p>在大多數情況下，兩個常數的相等性會如同你的預期，如果兩個常數彼此相等，則它們相等。但是仍會有一些特殊的狀況。</p>
<h3 id="結構相等性"><a class="header" href="#結構相等性">結構相等性</a></h3>
<p>常數相等性的定義是根據 <a href="https://github.com/rust-lang/rfcs/blob/master/text/1445-restrict-constants-in-patterns.md">RFC 1445</a> 解釋的結構相等性所定義。只有在型別有「結構相符」的特性下，該結構才可用做常數參數。舉例來說，浮點數就會被排除在外。</p>
<p>在最終解決方案出來前，結構相符這樣的性質應作為權宜之計。無論變數參數採用什麼解決方案，確保相等是具有反射性（reflexive）對於型別相等而言是重要的，這樣才能使得型別始終相同。（浮點數相等的標准定義是不具反射性）</p>
<p>這可能會與未來進行配對（match）的定義而有所不同，但是配對和常數參數不一定得使用相同的相等性定義，現今所使用的相等性定義已經足以滿足我們的目的。</p>
<p>因為常數必須具有結構相符的性質，並且此性質無法強制轉成一個型別變數，因此我們無法定義一個常數參數是從其他型別變數推導來的。（意即 <code>Foo &lt;T，const N：T&gt;</code>不是合規的）</p>
<h3 id="兩個抽像表達式的相等性"><a class="header" href="#兩個抽像表達式的相等性">兩個抽像表達式的相等性</a></h3>
<p>在比較兩個抽象常數表達式（即依賴於變數的表達式）的相等性時，我們無法比較其值的相等性，因其值是由常數變數所決定的，而在在單態化之前是未知的。</p>
<p>基於這個原因，我們至少會將常數表達式的返回值當作投影（projections）。雖然其值仍保持未知，我們仍藉由輸入值來決定其值，這是作法相同於現在我們處理關聯型別（associated types）的作法。此作法我們將稱為常數投影（const projection），對另一個同型別的常數而言，我們永遠無法確定其相等性。</p>
<p>每個常數表達式都會生成一個新的投影，該投影本質上是匿名的。不可能使兩個匿名投影一致（想像兩個關聯型別的泛型 <code>T :: Assoc</code> 和 <code>T :: Item</code>，你無法證明或否定它們是否為同一型別）。因此，除非它們從字面上使用完完全全相同的文字，否則常數表達式在 AST 節點中是彼此不一樣的。這意味著 <code>N + 1</code> 的一個實例不會與另一個 <code>N + 1</code> 的實例在型別相同。</p>
<p>更清楚來說，以下是無法通過型別檢查的，因為 <code>N + 1</code> 會是兩種不同的型別：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;const N: usize&gt;() -&gt; [i32; N + 1] {
    let x: [i32; N + 1] = [0; N + 1];
    x
}
<span class="boring">}
</span></code></pre></pre>
<p>但如果這樣寫的話，它將只有一個型別：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo&lt;const N: usize&gt; = [i32; N + 1];

fn foo&lt;const N: usize&gt;() -&gt; Foo&lt;N&gt; {
    let x: Foo&lt;N&gt; = Default::default();
    x
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="未來的擴展性"><a class="header" href="#未來的擴展性">未來的擴展性</a></h4>
<p>未來的某一天我們可以利用一些操作的基本性質（例如加法和乘法的可交換性），而對常數投影的相等性做出更聰明的判斷。但是，本 RFC 並不打算在此提案中建造這些可能性，而是打算留給未來的 RFC 決定。</p>
<h2 id="常數變數的特化specialization"><a class="header" href="#常數變數的特化specialization">常數變數的特化（Specialization）</a></h2>
<p>定義常數參數特化的順序也是很重要的。為此，將字面上的定義必需比其他表達式更具體，否則表達式定義的順序上也會產生不確定性。</p>
<p>正如我們有朝一日可以在常數投影上支援更進階的相等性一樣，我們可以支援更進階的特化定義。例如，給定型別為 <code>(i32, i32)</code>，我們可以確定 <code>(0, PARAM2)</code> 比 <code>(PARAM1, PARAM2)</code> 更為具體；<code>(i32, U)</code> 比 <code>(T, U)</code> 更為具體。在未來的某天我們將也有可能在常數特化上支援多元交互（intersectional）和其他更進階的定義。</p>
<h1 id="我們如何教導這個"><a class="header" href="#我們如何教導這個">我們如何教導這個</a></h1>
<p>常數泛型是一個很龐大的功能，將需要大量的教育資源，這將會需要寫在在書本跟參考文件中，且可能會在書中有獨立的章節。常數泛型的文件化過程本質上將會是一個大工程。</p>
<p>然而，常數泛型應該被視為進階功能，並且在使用 Rust 的初期，我們應該不會向新手介紹這些內容。</p>
<h1 id="缺點-1"><a class="header" href="#缺點-1">缺點</a></h1>
<p>此功能由於允許型別由常數決定，將為型別系統增加了大量的複雜性。它需要抽象變數相等性的確定規則，這出現了很多令人意外的的特殊情況。它增加了 Rust 的很多語法。如果我們不要採用此功能，Rust 肯定會更簡單。</p>
<p>然而，我們已經引入了一種由常數確定的型別（數組型別）。泛型化的功能似乎是必然的，甚至是不可避免的，鑑於此，我們應該盡早決定。</p>
<h1 id="替代方案-2"><a class="header" href="#替代方案-2">替代方案</a></h1>
<p>除了暫緩執行或不執行外，並沒有真的替代方案。</p>
<p>我們可以限制常數泛型為 <code>usize</code> 型別，但這不會讓實作更為簡單。</p>
<p>我們可以對常數相對性的複雜概念更積極地發展，但這會使實作比上述說明得更加複雜。</p>
<p>我們可以選擇稍微不同的語法，例如將在常數跟型別間加上分號。</p>
<h1 id="未解決問題"><a class="header" href="#未解決問題">未解決問題</a></h1>
<ul>
<li><b>一致的抽象常數表達式︰</b>本 RFC 盡可能最大限度地減少抽象常數表達式的統合性上的處理，從本質上來說，並沒有使其一致。這可能造成無法接受的使用者體驗的不穩定，而我們想要實作一些更進些的統合性之前穩定此功能。</li>
<li><b>常數表達式之正確格式︰</b>只有在單態化過程中，程式不會恐慌（panic）的情況下，此型別才能視爲正確格式。這對於溢出和超出範圍的陣列存取來說很棘手。然而，我們實際上只能確保在函式的簽章中表達式常數的格式進行正確性約束。目前尚不清楚有關在函式中抽象常數表達式之格式正確性的處理方式，也因此使實作推遲。</li>
<li><b>排序與預設參數︰</b>所有常數參數是否將排在最後，或者將它們與型別混合嗎？具有預設值的參數是否須在沒有預設值之後？這些決定推遲到實作語法的討論中。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature Name: <code>const-control-flow</code></li>
<li>Start Date: 2018-01-11</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/2342">rust-lang/rfcs#2342</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/49146">rust-lang/rust#49146</a></li>
<li>Translators: [<a href="https://github.com/CYBAI">@CYBAI</a>]</li>
<li>Commit: <a href="https://github.com/rust-lang/rfcs/blob/dfe697106478a52bddc000477e8cd0621bcc1a20/text/2342-const-control-flow.md">The commit link this page based on</a></li>
<li>Updated: 2020-09-05</li>
</ul>
<h1 id="總結-1"><a class="header" href="#總結-1">總結</a></h1>
<p>透過此功能，可以在常數求值（const evaluation）中使用 <code>if</code> 及 <code>match</code> 並使他們被延遲求值。簡單來說，這項功能允許我們寫 <code>if x &lt; y { y - x } else { x - y }</code>；即使當使用非負型別時在 <code>x &lt; y</code> 的 <code>else</code> 分支會報溢位錯誤 (overflow error)。</p>
<h1 id="動機-3"><a class="header" href="#動機-3">動機</a></h1>
<p>在常數宣告中使用條件式對於建立像是 <code>NonZero::new</code> 的 <code>const fn</code> 及 直譯判定（interpreting assertions）來說很重要。</p>
<h1 id="教學式解說"><a class="header" href="#教學式解說">教學式解說</a></h1>
<p>如果你寫</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32 = ...;
let y: u32 = ...;
let a = x - y;
let b = y - x;
if x &gt; y {
    // do something with a
} else {
    // do something with b
}
<span class="boring">}
</span></code></pre></pre>
<p>這支程式永遠都會 panic（除非 <code>x</code> 和 <code>y</code> 同時是 <code>0</code>）因為不管是 <code>x - y</code> 或是 <code>y - x</code> 都會造成溢位。為了解決此問題，我們必須把 <code>let a</code> 及 <code>let b</code> 個別搬進 <code>if</code> 及 <code>else</code> 中。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32 = ...;
let y: u32 = ...;
if x &gt; y {
    let a = x - y;
    // do something with a
} else {
    let b = y - x;
    // do something with b
}
<span class="boring">}
</span></code></pre></pre>
<p>當改用常數時，上面的寫法就會出現新問題：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const X: u32 = ...;
const Y: u32 = ...;
const FOO: SomeType = if X &gt; Y {
    const A: u32 = X - Y;
    ...
} else {
    const B: u32 = Y - X;
    ...
};
<span class="boring">}
</span></code></pre></pre>
<p><code>A</code> 和 <code>B</code> 會比 <code>FOO</code> 先被求值，因為常數在定義上就是「常數」，所以不應被求值順序影響。這項假設在有錯誤的情況下並不成立，因為錯誤屬於副作用（side effects），因此不純（pure）。</p>
<p>為了解決此問題，我們必須把中介常數消掉並改為直接對 <code>X - Y</code> 及 <code>Y - X</code> 求值。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const X: u32 = ...;
const Y: u32 = ...;
const FOO: SomeType = if X &gt; Y {
    let a = X - Y;
    ...
} else {
    let b = Y - X;
    ...
};
<span class="boring">}
</span></code></pre></pre>
<h1 id="技術文件式解說"><a class="header" href="#技術文件式解說">技術文件式解說</a></h1>
<p><code>if</code> 或是在 variant 沒有欄位的 enums 上做 <code>match</code> 會在 HIR -&gt; MIR 階段時，被轉譯成 <code>switchInt</code> 終止器（terminator）。Mir 直譯器現在將會針對那些終止器求值（之前就可以了）。</p>
<p>在 variant 沒有欄位的 enums 上做 <code>match</code> 會被轉譯成 <code>switch</code>，表示他會被檢查 discriminant 或是在 packed enums（例如 <code>Option&lt;&amp;T&gt;</code>）的情況會運算 discriminant（這個情況 discriminant 沒有特別的記憶體位址，但他會把所有的零視為 <code>None</code>，並把其他的值都當作 <code>Some</code>）。當進入 <code>match</code> 的分支時，匹配上的值基本上會被 transmute 成 enum 的 variant 型別，如此一來可以允許其他程式碼來存取該 enum 的欄位。</p>
<h1 id="缺點-2"><a class="header" href="#缺點-2">缺點</a></h1>
<p>這項功能容易造成任意「常數」值（如：<code>size_of::&lt;T&gt;()</code> 或是特定的平台常數）編譯失敗。</p>
<h1 id="原理及替代方案"><a class="header" href="#原理及替代方案">原理及替代方案</a></h1>
<h2 id="利用中介-const-fns-來破壞立即常數求值eager-const-evaluation"><a class="header" href="#利用中介-const-fns-來破壞立即常數求值eager-const-evaluation">利用中介 const fns 來破壞立即常數求值（eager const evaluation）</a></h2>
<p>如果寫成</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const X: u32 = ...;
const Y: u32 = ...;
const AB: u32 = if X &gt; Y {
    X - Y
} else {
    Y - X
};
<span class="boring">}
</span></code></pre></pre>
<p><code>X - Y</code> 或是 <code>Y - X</code> 其中一方有可能會報錯，這時必須加入中介 const fn</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const X: u32 = ...;
const Y: u32 = ...;
const fn foo(x: u32, y: u32) -&gt; u32 {
    if x &gt; y {
        x - y
    } else {
        y - x
    }
}
const AB: u32 = foo(X, Y);
<span class="boring">}
</span></code></pre></pre>
<p>const fn 的 <code>x</code> 和 <code>y</code> 參數未知，無法做常數求值（const evaluate）。當提供此 const fn 參數並求值時，只會對相應的分支求值。</p>
<h1 id="未解決問題-1"><a class="header" href="#未解決問題-1">未解決問題</a></h1>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature Name: <code>min_rust_version</code></li>
<li>Start Date: 2018-06-28</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/2495">rust-lang/rfcs#2495</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/65262">rust-lang/rust#65262</a></li>
<li>Translators: [<a href="https://github.com/weihanglo">@weihanglo</a>]</li>
<li>Commit: <a href="https://github.com/rust-lang/rfcs/blob/3071138d4ed510d6dfc1f8e1d7e9d4b099ea12e8/text/2495-min-rust-version.md">The commit link this page based on</a></li>
<li>Updated: 2020-09-07</li>
</ul>
<h1 id="總結-2"><a class="header" href="#總結-2">總結</a></h1>
<p>在 <code>Cargo.toml</code> 的 package 區塊加入 <code>rust</code> 欄位，用於指定 crate 的最低支援 Rust 版本（Minimum Supported Rust Version，MSRV）。</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
rust = &quot;1.30&quot;
</code></pre>
<h1 id="動機-4"><a class="header" href="#動機-4">動機</a></h1>
<p>當前 crate 無任何正式方法指定 MSRV，導致使用者無法在不建構該 crate 的情況下得知 crate 是否可透過他們的工具鏈（toolchain）建構。這也帶來有關如何在提升 MSRV 時管理 crate 版本的爭論，保守的作法是將之視為破壞性改動，這種作法會阻礙整個生態採納新功能，或使得版本號通膨式提升，進而讓下游的 crate 很難跟上。另一方面，若作法稍微寬鬆些，則導致採用較舊編譯器版本的使用者無法成功編譯它們的 crate。</p>
<h1 id="教學式解說-1"><a class="header" href="#教學式解說-1">教學式解說</a></h1>
<p>若你想指定一個特定 MSRV 版本，請在 <code>Cargo.toml</code> 的 <code>[package]</code> 區塊中的 <code>rust</code> 欄位設定指定的 Rust 版本。如果你建構一個 crate 時有任一依賴要求的 MSRV 比你當前工具鏈更高，會導致編譯錯誤，指明該依賴與它的 MSRV。這個行為可以透過 <code>--no-msrv-check</code> 選項來停用。</p>
<h1 id="技術文件式解說-1"><a class="header" href="#技術文件式解說-1">技術文件式解說</a></h1>
<p>在建構過程（包含 <code>run</code>、<code>test</code>、<code>benchmark</code>、<code>verify</code> 與 <code>publish</code> 子指令），<code>cargo</code> 會以依賴樹（dependency tree）的形式，檢查所有將要建構或檢查的所有 crate 之 MSRV 要求。在依賴樹內但不會被構建的 crate 不會執行此項檢查（例如特定目標平台或可選的 crate）。</p>
<p><code>rust</code> 欄位應至少遵循下列要求：</p>
<ul>
<li>其值需遵守語意化版號且不能有範圍運算子。注意，「1.50」是合法的值，代表「1.50.0」。</li>
<li>版本不能比當前 stable 工具鏈高（上傳 crate 時 crates.io 會檢查）。</li>
<li>版本不能低於 1.27（此版本將 <code>package.rust</code> 欄位從錯誤改為警告）。</li>
<li>版本不能比選用的 edition 釋出的版本低，舉例來說，同時出現 <code>rust = &quot;1.27&quot;</code> 與 <code>edition = 2018</code> 是非法的。</li>
</ul>
<h1 id="未來展望與延伸"><a class="header" href="#未來展望與延伸">未來展望與延伸</a></h1>
<h2 id="對版本解析之影響"><a class="header" href="#對版本解析之影響">對版本解析之影響</a></h2>
<p><code>rust</code> 欄位之值（手動設定或 <code>cargo</code> 自動選擇）會用於選擇合適的依賴版本。</p>
<p>舉例來說，想像你的 crate 相依 crate <code>foo</code>，一個發佈了從 <code>0.1.0</code> 到 <code>0.1.9</code> 十個版本的 crate，其中 <code>0.1.0</code> 到 <code>0.1.5</code> 版在 crates.io 上 <code>Cargo.toml</code> 的 <code>rust</code> 欄位為「1.30」，其他版本則為「1.40」。現在，你建構一個專案用了例如 Rust 1.33 版，<code>cargo</code> 會選用 <code>foo v0.1.5</code>。<code>foo v0.1.9</code> 只會在你用 Rust 1.40 或更高版本建構專案時選用。倘若你嘗試使用 Rust 1.29 建構專案，cargo 會回報錯誤。</p>
<p><code>rust</code> 欄位值也會被檢核。在 crate 建構過程，<code>cargo</code> 將檢查所有上游相依是否可以在指定 MSRV 下建構。（例如，檢查給定的 crate 與 Rust 版本限制條件下是否存在解）已除去（yank）的 crate 會略過這個檢查步驟。</p>
<p>期望實作這項功能得以替長久以來對 MSRV 提升是否為破壞性改動的爭論劃下休止符，並讓 crate 作者提升 crate 的 MSRV 不再如此綁手綁腳。（儘管對於已 1.0 的 crate 來說，透過提升修訂號（patch version）來提升 MSRV 次版號，以接納修復嚴重問題的 backport，可能是個有用的慣例）</p>
<p>注意，上述 MSRV 限制與依賴版本解析檢查，可以透過 <code>--no-msrv-check</code> 選項停用。</p>
<h2 id="發佈時檢查-msrv"><a class="header" href="#發佈時檢查-msrv">發佈時檢查 MSRV</a></h2>
<p><code>cargo publish</code> 將檢查上傳是以 <code>rust</code> 欄位指定的工具鏈版本完成，若工具鏈版本有異，<code>cargo</code> 會拒絕上傳該 crate。此確保機制避免因為未預期的 MSRV 提升導致錯誤的 <code>rust</code> 欄位值。這項檢查可透過既有的 <code>--no-verify</code> 選項停用。</p>
<h2 id="將-rust-欄位設為必填"><a class="header" href="#將-rust-欄位設為必填">將 <code>rust</code> 欄位設為必填</a></h2>
<p>未來（可能是下一個 edition），我們可以設定新上傳的 crate 的 <code>rust</code> 欄位為必填。既有 crate 的 MSRV 會透過 <code>edition</code> 決定。換句話說 <code>edition = 2018</code> 之 MSRV 必然是 <code>rust = &quot;1.31&quot;</code>，而 <code>edition = &quot;2015&quot;</code> 則是 <code>rust = &quot;1.0&quot;</code>。</p>
<p><code>cargo init</code> 將會使用當前工具鏈使用的版本。</p>
<h2 id="基於-cfg-的-msrv"><a class="header" href="#基於-cfg-的-msrv">基於 <code>cfg</code> 的 MSRV</a></h2>
<p>部分 crate 會根據不同目標架構平台或啟用的功能而有不同的 MSRV。可透過以下方式有效指定 MSRV 如何依賴這些配置：</p>
<pre><code class="language-toml">[package]
rust = &quot;1.30&quot;

[target.x86_64-pc-windows-gnu.package]
rust = &quot;1.35&quot;

[target.'cfg(feature = &quot;foo&quot;)'.package]
rust = &quot;1.33&quot;
</code></pre>
<p>在 <code>target</code> 區塊中所有 <code>rust</code> 值應等於或高於在 <code>package</code> 區塊的 <code>rust</code> 值。</p>
<p>若 <code>target</code> 的條件為真，<code>cargo</code> 會取用該區塊的 <code>rust</code> 值。若多個 target 區塊的條件為真，則取用最大值。</p>
<h2 id="nightly-與-stable-版本"><a class="header" href="#nightly-與-stable-版本">Nightly 與 stable 版本</a></h2>
<p>部分 crate 可能偏好在最新 stable 或 nighly 工具鏈，除了指定版本之外，我們可允許宣告 <code>stable</code> 或 <code>nightly</code> 值，讓維護者不需追蹤該 crate 的 MSRV 。</p>
<p>對於某些超前沿的 crate（例如： <code>rocket</code>）常常因為 Nightly 更新就壞，將可指定特定可成功建構的 Nightly 版本。透過下列語法來達成：</p>
<ul>
<li>自動選擇：<code>nightly</code> 此寫法與寫 <code>stable</code> 的行為一致，將使用等於當前或更高的 nightly 版本。</li>
<li>單一版本：<code>nightly: 2018-01-01</code> （主要寫法）</li>
<li>列舉：<code>nightly: 2018-01-01, 2018-01-15</code></li>
<li>類語意化版本條件：<code>nightly: &gt;=2018-01-01</code>、<code>nightly: &gt;=2018-01-01, &lt;=2018-01-15</code>、<code>nightly: &gt;=2018-01-01, &lt;=2018-01-15, 2018-01-20</code>。（後者會解讀為 「(version &gt;= 2018-01-01 &amp;&amp; version &lt;= 2018-01-20) || version == 2018-01-20」）</li>
</ul>
<p>這些條件或許很嚴苛，盼使用這功能的 crate 一隻手數得出來。</p>
<h1 id="缺點-3"><a class="header" href="#缺點-3">缺點</a></h1>
<ul>
<li>即使宣告了 MSRV 且檢查過，並無法保持 crate 能夠正確在指定 MSRV 下正確執行，只有合理配置的 CI 能做到此事。</li>
<li>更複雜的依賴版本解析演算法。</li>
<li>使用 <code>cargo publish</code> 配合 MSRV <code>rust = &quot;stable&quot;</code> 恐過於保守。</li>
</ul>
<h1 id="替代方案-3"><a class="header" href="#替代方案-3">替代方案</a></h1>
<ul>
<li>自動計算 MSRV。</li>
<li>不做任何事，依靠 <a href="https://github.com/rust-lang/rfcs/pull/2483">LTS 發行</a> 的 crate MSRV 提升。</li>
<li>允許在 <a href="https://github.com/rust-lang/rfcs/pull/2523">RFC 2523</a> 中提出基於版本與路徑的 <code>cfg</code> 屬性（attribute）</li>
</ul>
<h1 id="先驅技術"><a class="header" href="#先驅技術">先驅技術</a></h1>
<p>早先的提案：</p>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/pull/1707">RFC 1707</a></li>
<li><a href="https://github.com/rust-lang/rfcs/pull/1709">RFC 1709</a></li>
<li><a href="https://github.com/rust-lang/rfcs/pull/1953">RFC 1953</a></li>
<li><a href="https://github.com/rust-lang/rfcs/pull/2182">RFC 2182</a>（這個非常有爭議的離題了）</li>
</ul>
<h1 id="未解決問題-2"><a class="header" href="#未解決問題-2">未解決問題</a></h1>
<ul>
<li>瑣碎的命名問題：<code>rust</code> 或 <code>rustc</code> 還是 <code>min-rust-version</code></li>
<li>額外的檢查？</li>
<li>更優質地說明版本解析演算法</li>
<li>nightly 版本如何與「基於 cfg 的 MSRV」運作？</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature Name: sparse_index</li>
<li>Start Date: 2019-10-18</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/2789">rust-lang/rfcs#2789</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/9069">rust-lang/rust#9069</a></li>
<li>Translators: [<a href="https://github.com/weihanglo">@weihanglo</a>]</li>
<li>Commit: <a href="https://github.com/rust-lang/rfcs/blob/3fec7e2e44884cff1a8f6c4a278bd6896ce04227/text/2789-sparse-index.md">The commit link this page based on</a></li>
<li>Updated: 2022-04-02</li>
</ul>
<h1 id="總結-3"><a class="header" href="#總結-3">總結</a></h1>
<p>可透過 HTTP 選擇性下載 crates-io 索引，類於 Ruby 的 Bundler 的作法。傳輸方式從預先（ahead-of-time）Git clone 改變為 HTTP 按需下載。既有的索引結構和內容維持不變。重要的是，此提案可與靜態檔案協同運作，而不需客製化的伺服器端 API。</p>
<h1 id="動機-5"><a class="header" href="#動機-5">動機</a></h1>
<p>完整的 crate 索引相對龐大且下載慢。它還會隨著 crates.io 增長而增長，讓情況每況愈下。需要下載完整索引這件事拖累了首次使用 Cargo 的速度。尤其是在無狀態的 CI 環境下更是緩慢又浪費且只使用完整索引的非常小一部分，剩下全都給拋棄。快取索引在 CI 環境可謂困難重重（<code>.cargo</code> 目錄很巨）又經常低效（如：在 Travis Ci 上傳下載大型快取幾乎和下載新鮮索引一樣慢）。</p>
<p>目前索引的儲存資料格式和 git 協定搭配起來並不是很舒服。未壓縮的索引內容 tarball（截止 eb037b4863）佔 176MiB，<code>gzip -1</code> 需要 16MiB，而 <code>xz -6</code> 壓縮則要 10MiB。然 Git clone 卻回報下載了 215 MiB，比未壓縮的最新索引內容還大，且是壓縮後 tarball 的 <strong>二十倍之多</strong>。</p>
<p>將 git 歷史記錄 shallow clone 或 squash 只是暫時解。且不論事實上 <a href="http://blog.cocoapods.org/Master-Spec-Repo-Rate-Limiting-Post-Mortem/">GitHub 指出它們不想支援大型儲存庫的 shallow clone</a>，也不論 libgit2 尚未支援 shallow clone，實際上這作法仍未解決客戶端必須下載包含所有 crate 的整包索引。</p>
<h1 id="教學式解說-2"><a class="header" href="#教學式解說-2">教學式解說</a></h1>
<p>將索引作為純文字檔案，透過 HTTP 開放出來。開放既有的索引佈局排列也夠用（就像從 raw.githubusercontent.com 看到的長相），不過以 HTTP 來說 URL scheme 可能可以簡化。</p>
<p>欲了解 crate 資訊和解析依賴，Cargo（或其他客戶端）可對每個依賴建立請求，並送往已知的 URL 以取得需要的資訊，例如：<code>https://index.example.com/se/rd/serde</code>。對各個依賴來說，客戶端也會繼續請求其依賴資訊， 遞迴循環，直到取得所有依賴（並快取）到本機端。</p>
<p>請求依賴檔案是有辦法平行化運作的，所以依賴解析最差情況下的延遲會限制在依賴樹的最大深度。實務上最差情況非常少見，因為依賴通常會多次出現在樹中，因此可以提前發現並增加平行化機會。且，若已有 lock 檔案，所有列在其中的依賴也都可平行化核對處理，</p>
<h2 id="離線支援"><a class="header" href="#離線支援">離線支援</a></h2>
<p>此提議的解法完全保留了 Cargo 離線工作的功能。（連線的情況下）欲取得 crate 必然要下載足夠的索引來使用，之後所有資料會快取留作離線使用。</p>
<h2 id="減少頻寬使用"><a class="header" href="#減少頻寬使用">減少頻寬使用</a></h2>
<p>Cargo 支援 HTTP/2，可有效率地處理多個相似的請求。</p>
<p>所有已獲取的依賴檔案可被快取，並透過條件式 HTTP 請求（<code>Etag</code> 或 <code>If-Modified-Since</code> 標頭）來避免重複下載未改變的檔案。</p>
<p>依賴的檔案易於壓縮，目前 <code>rustc-ap-rustc_data_structures</code> 內最大的檔案可用 Brotli 從 1MiB 壓縮到 26KiB。許多伺服器支援透明地提供預壓縮檔案（例如：可從帶有適當內容編碼標頭的 <code>rustc-ap-rustc_data_structures.gz</code> 提供 <code>/rustc-ap-rustc_data_structures</code> 的請求處理），因此索引可以保有高壓縮率但不必花費過多 CPU 以提供這些檔案。</p>
<p>就算是最糟的完整索引一個檔案一個檔案的下載狀況，比起 git clone 仍然使用更少頻寬（所有檔案分別壓縮加起來大小 39MiB）。</p>
<p>提供「增量式變更記錄」檔（在「未來展望」詳述）可以避免過多的條件式請求。</p>
<h2 id="處理移除的-crate"><a class="header" href="#處理移除的-crate">處理移除的 crate</a></h2>
<p>有需要的話，本提議的解法可支援 crate 移除。當客戶端欲檢查一個已移除的 crate 的新鮮度，會向伺服器請求並獲得 404/410/451 HTTP 狀態。客戶端可以根據情況處理，並清理本機端的資料（甚至是 tarball 和原始碼已簽出的情況下）。 </p>
<p>若客戶端對該移除 crate 不感興趣，就不會檢查之，但極大機率從來不會這樣做，也不會下載它。若主動清除已移除的 crate 快取資訊非常重要，則可以延伸「增量式變更記錄」來通知該移除。</p>
<h1 id="缺點-4"><a class="header" href="#缺點-4">缺點</a></h1>
<ul>
<li>crates-io 計畫替索引加上加密簽章，作為 HTTP 上額外一層保護。對 git 索引來說加密驗證非常直觀，不過簽署鬆散的 HTTP 索引可能蠻有挑戰性的。</li>
<li>在還沒有增量式變更記錄前，一個基本的實作，需要許多請求來更新索引。和 git fetch 相比會有更高的延遲。然而，在一些早期的效能比較下，若 CDN 支援足夠（&gt;60）多的平行請求，會比 git fetch 更快。對 Github 上的索引來說，Cargo 有一個捷徑會檢查 master 分支是否改變。若有增量式變更記錄檔，同樣的捷徑可以透過條件式 HTTP 請求該變更記錄檔來達成（例如，檢查 <code>ETag</code> 或 <code>Last-Modified</code>）。</li>
<li>此解法高效與否仰賴於建立多個平行小請求。支援 HTTP/2 的伺服器上做檢查是 HTTP/1.1 的兩倍快，但其實速度超越 HTTP/1.1 很合理。</li>
<li>替代 registry 的功能目前已穩定，代表基於 git 索引協定也穩定且無法移除了。</li>
<li>發送模糊搜尋索引的工具（例如 <code>cargo add</code>）可能需要發送數個請求，或是改用其他方法。URL 已全數正規化到小寫，所以不分大小寫的不需要額外的請求。</li>
</ul>
<h1 id="原理及替代方案-1"><a class="header" href="#原理及替代方案-1">原理及替代方案</a></h1>
<h2 id="查詢-api"><a class="header" href="#查詢-api">查詢 API</a></h2>
<p>顯而易見的替代方案是建立可供查詢依賴解析的伺服器端 API（例如提供依賴清單就回傳一個 lockfile 或類似的東西）。然而，這會需要在伺服器端跑依賴解析。維護這種至關重要的動態 API 給幾乎所有 Rust 使用者每天使用，比其靜態檔案更難花費更高。</p>
<p>本提議之解法並不需要伺服器端任何邏輯。索引可以放在靜態檔案 CDN 上，且非常容易快取或鏡像。不需要修改索引如何取出。標準版本的索引可以繼續以 git 儲存庫形式維持完整的歷史記錄。這能保持與過往 Cargo 版本的相容性，並且第三方工具可以使用當前的索引格式。</p>
<h2 id="從-rustup-提供初始索引"><a class="header" href="#從-rustup-提供初始索引">從 rustup 提供初始索引</a></h2>
<p>Rust／Cargo 的安裝可以打包初始版本的索引，這樣當 Cargo 運作時，就不需要從 git 下載整份索引檔，只需要做與種子版本差異更新。這個索引需要 rustup 更聰明地分別處理，避免在安裝或更新不同版本的 Cargo 時，造成重複下載索引多次。這會讓索引的下載和壓縮更好，讓做法可使目前的實作撐更久，但仍沒辦法解決索引不斷增長的問題。</p>
<p>本提議之解法更是伸縮自如，因為 Cargo 只要下載和快取「需要用到」的索引，未使用／棄用／垃圾 crate 不會造成任何花費。</p>
<h2 id="rsync"><a class="header" href="#rsync">Rsync</a></h2>
<p>rsync 協定需要掃描並校驗原始碼與目標檔案的檢查碼異同，這需要許多不必要的 I/O，且需要 SSH 或在伺服器上運行的客製化系統服務（daemon），這限制了架設索引的選項。</p>
<h1 id="先驅技術-1"><a class="header" href="#先驅技術-1">先驅技術</a></h1>
<p>https://andre.arko.net/2014/03/28/the-new-rubygems-index-format/</p>
<p>Bundler 曾經是預先下載完整索引，和 Cargo 一樣，直到它變得太大太大。然後它改用中心化的查詢 API，直到問題多到難以支援。然後就切換到增量式下載偏平檔案索引格式，和本提議解法相似。</p>
<h1 id="未解決問題-3"><a class="header" href="#未解決問題-3">未解決問題</a></h1>
<ul>
<li>如何設定索引（包含替代 registry）該從 git 或新的 HTTP 下載？目前的語法使用 <code>https://</code> URL 當作 git-over-HTTP。</li>
<li>我們如何確保切換到 HTTP registry 不會導致 lock 檔案出現巨大差異？</li>
<li>如何改寫當前的解析器，開啟平行取得索引檔案的功能？目前所有索引需要同時都可用，這杜絕了平行化的可能性。</li>
</ul>
<h1 id="實作可行性"><a class="header" href="#實作可行性">實作可行性</a></h1>
<p>目前已有一個經過測試的實作，是以簡單「貪婪」演算法來取得索引檔案，在 https://github.com/rust-lang/cargo/pull/8890 ，並且證實了不錯的效能，尤其是全新的建構。該實驗性實作的 PR 建議一個修改解析器的做法，以移除不必要的貪婪取得階段。</p>
<h1 id="未來展望"><a class="header" href="#未來展望">未來展望</a></h1>
<h2 id="增量式的-crate-檔案"><a class="header" href="#增量式的-crate-檔案">增量式的 crate 檔案</a></h2>
<p>Bundler 替每個獨立的依賴檔案使用僅允許附加（append-only）格式，以盡可能只增量下載新版本資訊。Cargo 的格式幾乎就是 append-only（除了 yank），所以如果單一檔案成長到是個問題，應該要版本修復它。然而，當前最大的 crate <code>rustc-ap-rustc_data_structures</code> 天天發佈新版本，每個版本增加 44 位元組（壓縮後），所以就算十年後它也才 190KB（壓縮後），看起來並沒有駭人到需要解決。</p>
<h2 id="增量式變更記錄"><a class="header" href="#增量式變更記錄">增量式變更記錄</a></h2>
<p>截至目前，本方案在每次更新索引時，都必須重驗證每個索引檔案的新鮮度，即使許多檔案根本沒變。執行 <code>cargo update</code> 會導致索引更新，不過也有其他時機會導致更新，例如專案缺少 lockfile，或是添加了新的依賴。雖然 HTTP/2 pipeline 和條件式 GET 請求使得請求多個未改變檔案<a href="https://github.com/rust-lang/cargo/pull/8890#issuecomment-737472043">不錯有效率</a>，但如果我們能避免那些無謂的請求，只請求有更改的檔案會更好。</p>
<p>一個解決方案是提供一個索引的概覽，讓客戶端可以快速確認本機端的索引檔是否過期。為了避免客戶端無謂的請求完整引樹快照，索引可以維護一個僅允許附加（append-only）的變更記錄。當改變發生（crate 版本發佈或 yank），記錄檔會附加新的一條記錄：epoch number（下面解釋之）、最後修改時間戳記、變更的 crate 名稱，未來需要也可添加其他額外資訊。</p>
<p>因為這個記錄檔只允許附加，所以客戶端可以利用 <code>Range</code> HTTP 請求漸增地更新它。客戶端不必下載完整的記錄檔來用，下載從任意一點到檔案結束這段即可，這用 <code>Range</code> 請求來達成簡單易懂。當在記錄裡（從最末端開始）找到一個 crate，並且其更動時間和本機快取一致，如此客戶端就不需要額外對該檔案發送 HTTP 請求。
當記錄檔成長過大，epoch number 遞增，記錄檔就可以重設到空白。即使在客戶端對該新記錄檔的 <code>Range</code> 請求合法的狀況下，epoch number 仍可讓客戶端有辦法偵測記錄檔是否有重設。</p>
<p>最終，這個 RFC 並沒有建議此方案，因為記錄檔恐導致<a href="https://github.com/rust-lang/cargo/commit/bda120ad837e6e71edb334a44e64533119402dee">程式碼變得十分複雜</a>，且<a href="https://github.com/rust-lang/cargo/pull/8890#issuecomment-738316828">比起簡單的下載正面效益不大</a>。若索引快照跟著 registry signing 一起實作了，此 RFC 的實作就可利用該快照機制當作變更記錄。</p>
<h2 id="應付不一致的-http-快取"><a class="header" href="#應付不一致的-http-快取">應付不一致的 HTTP 快取</a></h2>
<p>索引並不需要將所有檔案合併產生一個快照。索引是一次更新一個檔案，並且只需保留部分更新排序。從 Cargo 的角度來看，各個依賴可允許獨立更新。</p>
<p>過期的快取僅在於新版本的 crate 使用了最新版本且剛發佈的依賴時，且該 crate 的快取失效得比其依賴早，才可能產生問題。Cargo 要求依賴需在可見的索引上有充分版本資訊，並且不會發佈任何「毀損」的 crate。</p>
<p>然而，CDN 快取總是有機會過期或失效的順序不一致。若 Cargo 偵測到索引的快取過期了（例如一個 crate 的依賴尚未出現在索引中），它可從該狀況復原，附加「快取破壞者」（如當前時間戳記）在 URL 上，以重新向索引請求檔案。就算 CDN 並不理會請求中的 <code>cache-control: no-cache</code>，這還是可靠能繞過過期快取的方法。</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature Name: <code>io_safety</code></li>
<li>Start Date: 2021-05-24</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/3128">rust-lang/rfcs#3128</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/87074">rust-lang/rust#87074</a></li>
<li>Translators: [<a href="https://github.com/weihanglo">@weihanglo</a>]</li>
<li>Commit: <a href="https://github.com/rust-lang/rfcs/blob/88b30e7a0b7ac5b0f52370a58b70c165a9a252af/text/3128-io-safety.md">The commit link this page based on</a></li>
<li>Updated: 2021-08-2o</li>
</ul>
<h1 id="總結-4"><a class="header" href="#總結-4">總結</a></h1>
<p>透過引進<strong>輸入輸出安全性</strong>（I/O safety）之概念與一系列新型別與特徵，保障 <code>AsRaw</code> 及相關特徵的使用者對原始資源 handle （raw resource handle）之使用，以彌補 Rust 封裝邊界的漏洞。</p>
<h1 id="動機-6"><a class="header" href="#動機-6">動機</a></h1>
<p>Rust 標準函式庫幾乎算是已經提供了<strong>輸入輸出安全性</strong>，保證程式的一部分若私自持有一個原始 handle （raw handle），其他部分就無法存取。例如 <a href="https://doc.rust-lang.org/stable/std/os/unix/io/trait.FromRawFd.html#tymethod.from_raw_fd"><code>FromRawFd::from_raw_fd</code></a> 標示為不安全，它不允許使用者在 safe Rust 之下執行如 <code>File::from_raw_fd(7)</code> 等操作，或是在程式各處私自持有檔案描述子（file descriptor）來執行輸入輸出。</p>
<p>不過仍有漏網之魚。許多函式庫的 API 透過接受 <a href="https://doc.rust-lang.org/stable/std/os/unix/io/trait.AsRawFd.html"><code>AsRawFd</code></a>/<a href="https://doc.rust-lang.org/stable/std/os/unix/io/trait.IntoRawFd.html"><code>IntoRawFd</code></a> 來執行輸入輸出操作：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn do_some_io&lt;FD: AsRawFd&gt;(input: &amp;FD) -&gt; io::Result&lt;()&gt; {
    some_syscall(input.as_raw_fd())
}
<span class="boring">}
</span></code></pre></pre>
<p><code>AsRawFd</code> 並無限制 <code>as_raw_fd</code> 的回傳值，所以 <code>do_some_io</code> 最終會對任意 <code>RawRd</code> 的值執行輸入輸出。由於 <a href="https://doc.rust-lang.org/stable/std/os/unix/io/type.RawFd.html"><code>RawFd</code></a> 本身實作了 <code>AsRawFd</code>，甚至可以寫出 <code>do_some_io(&amp;7)</code>。</p>
<p>這會使得程式<a href="https://cwe.mitre.org/data/definitions/910.html">存取錯誤的資源</a>，更甚者為其他地方私有的原始 handle 建立多個別名（alias），從而打破封裝的邊界，造成<a href="https://en.wikipedia.org/wiki/Action_at_a_distance_(computer_programming)">遠處來的詭異行為</a>。</p>
<p>而在特殊情況下，違反輸入輸出安全性恐導致違反記憶體安全性。舉例來說，理論上替透過 Linux <a href="https://man7.org/linux/man-pages/man2/memfd_create.2.html"><code>memfd_create</code></a> 系統呼叫建立出來的檔案描述子打造  <code>mmap</code> 的安全封裝，並將之傳給 safe Rust 是可行的，畢竟它就是匿名的被開啟的檔案（anonymous open file），表示其他行程（process）無法存取之。然而，在沒有輸入輸出安全性且沒有永久封閉該檔案的情況下，該程式中其他程式碼恐意外地對該檔案描述子呼叫 <code>write</code> 或 <code>ftruncate</code>，進而打破記憶體安全性 <code>&amp;[u8]</code> 不變的規則。</p>
<p>這個 RFC 透過以下幾點，開闢一條逐步關閉此漏洞的道路：</p>
<ul>
<li>一個新概念：輸入輸出安全性。其概念會撰寫在標準函式庫文件中。</li>
<li>一系列全新的型別與特徵。</li>
<li>替 <a href="https://doc.rust-lang.org/stable/std/os/unix/io/trait.FromRawFd.html#tymethod.from_raw_fd"><code>from_raw_fd</code></a>/<a href="https://doc.rust-lang.org/stable/std/os/windows/io/trait.FromRawHandle.html#tymethod.from_raw_handle"><code>from_raw_handle</code></a>/<a href="https://doc.rust-lang.org/stable/std/os/windows/io/trait.FromRawSocket.html#tymethod.from_raw_socket"><code>from_raw_socket</code></a> 撰寫新文件，解釋就輸入輸出安全性而言，它們為何不安全，順便解決出現好<a href="https://github.com/rust-lang/rust/issues/72175">幾</a><a href="https://users.rust-lang.org/t/why-is-fromrawfd-unsafe/39670">次</a>的相同問題。</li>
</ul>
<h1 id="教學式解說-3"><a class="header" href="#教學式解說-3">教學式解說</a></h1>
<h2 id="輸入輸出安全性概念"><a class="header" href="#輸入輸出安全性概念">輸入輸出安全性概念</a></h2>
<p>Rust 標準函式庫提供了低階型別，以表示原始的作業系統資源 handle：類 Unix 平台的 <a href="https://doc.rust-lang.org/stable/std/os/unix/io/type.RawFd.html"><code>RawFd</code></a> 和 Windows 上的 <a href="https://doc.rust-lang.org/stable/std/os/windows/io/type.RawHandle.html"><code>RawHandle</code></a> 與 <a href="https://doc.rust-lang.org/stable/std/os/windows/io/type.RawSocket.html"><code>RawSocket</code></a>。然而，它們並沒有提供任何自身的行為，而是僅作為一個標識符（identifier），並在低階的作業系統 API 間傳遞。</p>
<p>這些原始 handle 可以視為原始指標（raw pointer）且具有相同的危險性。雖然<strong>取得</strong>一個原始指標是安全的，但當該原始指標是非法指標，或是比其指向記憶體之處活得更久時，對原始指標<strong>取值</strong>（dereference）都可能引發未定義行為（undefined behavior）。無獨有偶，透過 <a href="https://doc.rust-lang.org/stable/std/os/unix/io/trait.AsRawFd.html#tymethod.as_raw_fd"><code>AsRawFd::as_raw_fd</code></a> 或類似方法<strong>取得</strong>一個原始 handle 是安全的，但當它並非合法 handle 或在關閉之後才拿來用時，用該 handle 來執行輸入輸出恐導致「損毀的輸出結果」、「遺失或洩漏輸入資料」或「違反封裝的邊界」。在這兩個案例中，影響不僅限於本地，也會影響程式的其他部分。保護原始指標免於危險稱作記憶體安全性，所以保護原始 handle 免於危險我們叫它<strong>輸入輸出安全性</strong>。</p>
<p>Rust 標準函式庫也有高階型別如 <a href="https://doc.rust-lang.org/stable/std/fs/struct.File.html"><code>File</code></a> 和 <a href="https://doc.rust-lang.org/stable/std/net/struct.TcpStream.html"><code>TcpStream</code></a> 來提供高階的作業系統 API 界面，這些型別包裝了原始 handle。</p>
<p>這些高階型別同時實作了在類 Unix 平台的 <a href="https://doc.rust-lang.org/stable/std/os/unix/io/trait.FromRawFd.html"><code>FromRawFd</code></a> 特徵，以及 Windows 上的 <a href="https://doc.rust-lang.org/stable/std/os/windows/io/trait.FromRawHandle.html"><code>FromRawHandle</code></a>/<a href="https://doc.rust-lang.org/stable/std/os/windows/io/trait.FromRawSocket.html"><code>FromRawSocket</code></a> 。這些特徵提供許多函式將底層的值封裝產生出高階的值。由於這些函式無法確保輸入輸出的安全性，因此標示為不安全。型別系統並不會限制這些型別傳入：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use std::fs::File;
    use std::os::unix::io::FromRawFd;

    // 建立一個檔案。
    let file = File::open(&quot;data.txt&quot;)?;

    // 從任意整數值構建一個 `File`，這個型別能通過檢查，但 7 可能在執行期間無法
    // 被識別為任何活生生的資源，或它可能不慎指向程式其他地方封裝好的原始 handle
    // 一個 `unsafe` 區塊告知呼叫者對此有責任，需使其免於這些風險。
    let forged = unsafe { File::from_raw_fd(7) };

    // 取得一個 `file` 內部的原始 handle 的副本。
    let raw_fd = file.as_raw_fd();

    // 關閉 `file`。
    drop(file);

    // 開啟一些無關的檔案。
    let another = File::open(&quot;another.txt&quot;)?;

    // 其他對 `raw_fd`（也就是 `file` 內部的原始 handle）的使用有可能使其生命週
    // 期長於與作業系統的關聯。這恐導致意外建立別名指向其他封裝起來的 `File`
    // 實例，例如 `another`。因此，一個 `unsafe` 區塊告知呼叫者對此有責任，需使
    // 其免於這些風險。
    let dangling = unsafe { File::from_raw_fd(raw_fd) };
<span class="boring">}
</span></code></pre></pre>
<p>呼叫端必須確保傳入 <code>from_raw_fd</code> 的值一定是從作業系統回傳所得，並且 <code>from_raw_fd</code> 的回傳值的生命週期不會長於和作業系統關聯的 handle。</p>
<p>雖然將輸入輸出安全性作為明確的概念是個新作法，但其實它也反映出許多常見的實踐。除了引入一些新型別與特徵及其實作外，Rust <code>std</code> 並不需改變已經穩定的界面。在推行之初，並不需讓整個 Rust 生態系馬上支援輸入輸出安全性，而是可以漸進式地採用之。</p>
<h2 id="ownedfd-與-borrowedfdfd"><a class="header" href="#ownedfd-與-borrowedfdfd"><code>OwnedFd</code> 與 <code>BorrowedFd&lt;'fd&gt;</code></a></h2>
<p>這兩個型別概念上將取代 <code>RawFd</code>，並分別表示擁有和借用的 handle 值。<code>OwnedFd</code> 擁有一個檔案描述子，當 <code>OwnedFd</code> 釋放時就會關閉其檔案描述子。<code>BorrowedFd</code> 的生命週期標示該檔案描述子被借用多久。這些型別皆會自動實施其輸入輸出安全性不變的規則。</p>
<p>至於在 Windows 上，會以 <code>Handle</code> 和 <code>Socket</code> 形式呈現相應的型別。</p>
<p>這些型別在輸入輸出扮演的角色可類比 Rust 既有的記憶體管理相關型別：</p>
<table><thead><tr><th>型別</th><th>類似於</th></tr></thead><tbody>
<tr><td><code>OwnedFd</code></td><td><code>Box&lt;_&gt;</code></td></tr>
<tr><td><code>BorrowedFd&lt;'a&gt;</code></td><td><code>&amp;'a _</code></td></tr>
<tr><td><code>RawFd</code></td><td><code>*const _</code></td></tr>
</tbody></table>
<p>不過兩者還是有差，輸入輸出安全性並不區分可不可變。在 Rust 的掌控之外，作業系統資源能以各種形式共享，所以輸入輸出可以視為使用了<a href="https://doc.rust-lang.org/reference/interior-mutability.html">內部可變性</a>。</p>
<h2 id="asfdintoownedfd-與-fromownedfd"><a class="header" href="#asfdintoownedfd-與-fromownedfd"><code>AsFd</code>、<code>Into&lt;OwnedFd&gt;</code> 與 <code>From&lt;OwnedFd&gt;</code></a></h2>
<p>這三個型別概念上，在大多數用例中分別取代 <code>AsRawFd::as_raw_fd</code>、<code>IntoRawFd::into_raw_fd</code>，以及 <code>FromRawFd::from_raw_fd</code>。它們依據 <code>OwnedFd</code> 及 <code>BorrowedFd</code> 來運作，所以也會自動實施其輸入輸出安全性不變的規則。</p>
<p>使用這些型別後，就能避免在<a href="3128-io-safety.html#%E5%8B%95%E6%A9%9F">動機</a>一節的 <code>do_some_io</code> 範例中提及的問題。由於只有合理擁有或借用檔案描述子的型別能實作 <code>AsFd</code>，所以這個版本的 <code>do_some_io</code> 不需要擔心偽造或迷途（dangling）的檔案描述子傳入。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn do_some_io&lt;FD: AsFd&gt;(input: &amp;FD) -&gt; io::Result&lt;()&gt; {
    some_syscall(input.as_fd())
}
<span class="boring">}
</span></code></pre></pre>
<p>至於在 Windows 上，會以 <code>Handle</code> 和 <code>Socket</code> 形式呈現相應的型別。</p>
<h2 id="漸進式採用"><a class="header" href="#漸進式採用">漸進式採用</a></h2>
<p>輸入輸出安全性及其新型別與新特徵並不需要一次性全面導入，而是能夠分階段漸進採用：</p>
<ul>
<li>首先，在 <code>std</code> 新增這些新型別與新特徵，並替相關的型別實作之。這是向下相容的改變。</li>
<li>在此之後，crate 可以開始用這些新型別，並替 crate 自己的型別實作這些新特徵。這些改變相對小，而且符合語意化版號相容性，不需其他特殊處理。</li>
<li>當標準函式庫和夠多的熱門 crate 實作這些新特徵後，其他 crate 可按照它們的開發步調，將這些新特徵作為泛型引數的限定條件（bound)。雖然這些改變不符合語意化版號的相容性，不過多數 API 使用者改用新特徵時並不需改變程式碼。</li>
</ul>
<h1 id="技術文件式解說-2"><a class="header" href="#技術文件式解說-2">技術文件式解說</a></h1>
<h2 id="輸入輸出安全性概念-1"><a class="header" href="#輸入輸出安全性概念-1">輸入輸出安全性概念</a></h2>
<p>Rust 語言除了有記憶體安全性之外，Rust 標準函式庫同時提供了對輸入輸出安全性的保證。一個合法的輸入輸出操作，其所操作的原始 handle（<a href="https://doc.rust-lang.org/stable/std/os/unix/io/type.RawFd.html"><code>RawFd</code></a>、 <a href="https://doc.rust-lang.org/stable/std/os/windows/io/type.RawHandle.html"><code>RawHandle</code></a>、<a href="https://doc.rust-lang.org/stable/std/os/windows/io/type.RawSocket.html"><code>RawSocket</code></a>）必為明確從作業系統回傳之值，且這些操作僅發生在與作業系統關聯之生命週期內。當一段 Rust 程式碼宣稱輸入輸出安全性，代表該程式碼不可能導致非法的輸入輸出操作。</p>
<p>雖然有些作業系統的文件中說明其檔案描述子的配置演算法，但從這些演算法旁敲側擊出來的 handle 值並不會視為「明確從作業系統回傳之值」。</p>
<p>對接受任意原始輸入輸出 handle 值（<a href="https://doc.rust-lang.org/stable/std/os/unix/io/type.RawFd.html"><code>RawFd</code></a>、<a href="https://doc.rust-lang.org/stable/std/os/windows/io/type.RawHandle.html"><code>RawHandle</code></a>、<a href="https://doc.rust-lang.org/stable/std/os/windows/io/type.RawSocket.html"><code>RawSocket</code></a>）的函式，若安全的 API 會藉由這些 handle 執行輸入輸出，應標示為 <code>unsafe</code>。</p>
<h2 id="ownedfd-與-borrowedfdfd-1"><a class="header" href="#ownedfd-與-borrowedfdfd-1"><code>OwnedFd</code> 與 <code>BorrowedFd&lt;'fd&gt;</code></a></h2>
<p><code>OwnedFd</code> 與 <code>BorrowedFd</code> 皆為 <code>repr(transparent)</code>，並帶有一個 <code>RawFd</code> 值，且兩者皆可應用區位最佳化（niche optimizations），所以和 <code>Option&lt;OwnedFd&gt;</code> 與 <code>Option&lt;BorrowedFd&lt;'_&gt;&gt;</code> 的大小相同，而且可在 FFI 宣告的函式中使用，例如 <code>open</code>, <code>read</code>, <code>write</code>, <code>close</code> 等。若以上述方法使用之，它們將確保 FFI 邊界的輸入輸出安全性。</p>
<p>這些型別同時會實作既有的 <code>AsRawFd</code>、<code>IntoRawFd</code>，以及 <code>FromRawFd</code> 特徵，所以它們可和既有程式碼的 <code>RawFd</code> 型別交互使用。</p>
<h2 id="asfdintoownedfd-與-fromownedfd-1"><a class="header" href="#asfdintoownedfd-與-fromownedfd-1"><code>AsFd</code>、<code>Into&lt;OwnedFd&gt;</code> 與 <code>From&lt;OwnedFd&gt;</code></a></h2>
<p>這些型別提供 <code>as_fd</code>、<code>into</code> 與 <code>from</code> 函式，類似於 <code>AsRawFd::as_raw_fd</code>、<code>IntoRawFd::into_raw_fd</code> 與 <code>FromRawFd::from_raw_fd</code>。</p>
<h2 id="原型實作"><a class="header" href="#原型實作">原型實作</a></h2>
<p>上述所有原型放在：</p>
<p><a href="https://github.com/sunfishcode/io-lifetimes">https://github.com/sunfishcode/io-lifetimes</a></p>
<p>README.md 有文件鏈結、範例、和當前提供類似功能的 crate 之調查研究。</p>
<h1 id="缺點-5"><a class="header" href="#缺點-5">缺點</a></h1>
<p>Crate 若用到檔案描述子，如 <a href="https://crates.io/crates/nix"><code>nix</code></a> 或 <a href="https://crates.io/crates/mio"><code>mio</code></a>，將需要遷移到有實作 <code>AsFd</code> 的型別，或將這類函式標示為不安全。</p>
<p>crates 若用 <code>AsRawFd</code> 或 <code>IntoRawFd</code> 來接收任何「類檔案」或「類 socket」型別，如 <a href="https://crates.io/crates/socket2"><code>socket2</code></a> 的 <a href="https://docs.rs/socket2/0.4.0/socket2/struct.SockRef.html#method.from"><code>SockRef::from</code></a>，將需換成 <code>AsFd</code> 或 <code>Into&lt;OwnedFd&gt;</code>，或將這類函式標示為不安全。</p>
<h1 id="原理及替代方案-2"><a class="header" href="#原理及替代方案-2">原理及替代方案</a></h1>
<h2 id="有關unsafe-僅為了記憶體安全性"><a class="header" href="#有關unsafe-僅為了記憶體安全性">有關「unsafe 僅為了記憶體安全性」</a></h2>
<p>Rust 有個慣例：<code>unsafe</code> 只適用於標示記憶體安全性。舉個有名的案例， <a href="https://doc.rust-lang.org/std/mem/fn.forget.html"><code>std::mem::forget</code></a> 曾標示為不安全，但後來<a href="https://rust-lang.github.io/rfcs/1066-safe-mem-forget.html">被改為安全</a>，且其結論指出 unsafe 僅該用作標示記憶體安全性，而不該用來標示可能作繭自縛的情況或恫嚇應避免使用的 API 上。</p>
<p>記憶體安全性造成的危害比其他程式設計面向更甚，它不僅要避免意外行為發生，且仍需避免無法限制一段程式碼能做什麼。</p>
<p>輸入輸出安全性也落在這個範疇，有兩個因素：</p>
<ul>
<li>（若作業系統存在 <code>mmap</code> 相關 API）在安全封裝的 <code>mmap</code> 中，輸入輸出安全性的錯誤仍會導致記憶體安全性的錯誤。</li>
<li>輸入輸出安全性之錯誤也意味著一段程式碼可以在沒有通知或被授予任何引用的情形下，讀寫或刪除程式其他部分正在使用的資料。這使得在無法通曉一個 crate 鏈結到的其他 crate 的所有實作細節下，非常難以限制這個 crate 可以做什麼。</li>
</ul>
<p>原始 handle 更像指向單獨的位址空間（address space）的原始指標，它們可能迷途（dangle）或造假。輸入輸出安全性近似於記憶體安全性，兩者皆竭力杜絕遠處來的詭異行為（spooky-action-at-a-distance），且對兩者來說，所有權都可作為建立穩健抽象化的主要根基，所以自然而然共用了相似的安全性概念。</p>
<h2 id="將輸入輸出-handle-當作純資料"><a class="header" href="#將輸入輸出-handle-當作純資料">將輸入輸出 Handle 當作純資料</a></h2>
<p>主要的替代方案的說法是原始 handle 為純資料（plain data），並沒有輸入輸出安全性，和作業系統資源的生命週期也無任何與生俱來的關係。至少在類 Unix 平台，這些永遠不會導致記憶體不安全或是未定義行為。</p>
<p>不過，大部分的 Rust 程式碼不直接與原始 handle 互動。撇開本 RFC 不談，不與原始 handle 互動是件好事。所謂資源，一定會有生命週期，若大部分的 Rust 程式碼能使用各方面都更易上手又能自動管理生命週期的更高階的型別，這樣鐵定更棒。不過，純資料的方案對於相對不常見的案例，最多只能讓原始 handle 的操作容易撰寫些。這可能只是蠅頭小利，甚至可能是個缺點，有可能最後變相鼓勵大家在不需要時去用了原始 handle 。</p>
<p>純資料的方案亦不需要變更任何 crate 的程式碼。而輸入輸出安全性的方案則需改動如 <a href="https://crates.io/crates/socket2"><code>socket2</code></a>、<a href="https://crates.io/crates/nix"><code>nix</code></a> 和 <a href="https://crates.io/crates/mio"><code>mio</code></a> 這些用到 <a href="https://doc.rust-lang.org/stable/std/os/unix/io/trait.AsRawFd.html"><code>AsRawFd</code></a> 和 <a href="https://doc.rust-lang.org/stable/std/os/unix/io/type.RawFd.html"><code>RawFd</code></a> 的 crate，不過這改動可以漸進推廣到整個生態系，而不必一次性完成。</p>
<h2 id="iosafe-特徵與它的前身-ownsraw"><a class="header" href="#iosafe-特徵與它的前身-ownsraw"><code>IoSafe</code> 特徵（與它的前身 <code>OwnsRaw</code>）</a></h2>
<p>這個 RFC 在早先幾個版本提議過一個 <code>IoSafe</code> 特徵，這個特徵會帶來小程度但具侵入性的修復。來自該 RFC 的回饋促使一系列新型別與特徵的開發。這個開發牽扯更廣的 API 範圍，也意味著需要更多設計和審核。並且隨著時間推移，整個 crate 生態系需要更大規模的改動。然而，早期跡象指出，本 RFC 引入的新型別與特徵更易理解，使用上更順手且安全，所以長期來說有更穩健的基礎。</p>
<p><code>IoSafe</code> 早期叫做 <code>OwnsRaw</code>。我們很難替這個特徵找到恰到好處的名字，這也許是個訊號，表示它並非良好設計的特徵。</p>
<h1 id="先驅技術-2"><a class="header" href="#先驅技術-2">先驅技術</a></h1>
<p>大部分記憶體安全的程式語言都對原始 handle 做了安全的抽象層。多數情況下，它們僅是簡單地避免暴露原始 handle，例如 <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.file?view=net-5.0">C#</a>、<a href="https://docs.oracle.com/javase/7/docs/api/java/io/File.html?is-external=true">Java</a> 等。若將透過原始 handle 執行輸入輸出標示為不安全，可讓 safe Rust 與這些程式語言達到相同程度的安全保證。</p>
<p>在 crates.io 上有好幾個 crate 封裝了擁有或借用的檔案描述子。<a href="https://github.com/sunfishcode/io-lifetimes#prior-art">io-lifetimes 的 README.md 中 Prior Art 一節</a>詳細描述了其與其他既有 crate 的同異。從高層次角度來看，既有的 crate 都與 io-lifetimes 共享相同的基本概念。這些 crate 都圍繞著 Rust 生命週期與所有權概念打造，而這恰恰說明這些概念非常適合這個問題。</p>
<p>Android 有特殊的 API 會偵測不恰當的 <code>close</code>，詳見 <a href="https://github.com/rust-lang/rust/pull/74680">rust-lang/rust#74860</a>。這些 API 的動機就是一種輸入輸出安全性的應用。Android 的特殊 API 用了動態檢查，讓它們可以在跨來源語言的邊界實施這些規則。本 RFC 提議的輸入輸出安全性的型別和特徵只專注在 Rust 程式碼本身實施這些規則，所以它們可在編譯期間利用 Rust 的型別系統實施這些規則，而非延遲到執行期間。</p>
<h1 id="未解決問題-4"><a class="header" href="#未解決問題-4">未解決問題</a></h1>
<h2 id="形式化所有權"><a class="header" href="#形式化所有權">形式化所有權</a></h2>
<p>此 RFC 並沒有為原始 handle 的所有權和生命週期定義一個形式化模型（formal model）。這 RFC 對原始 handle 規範之定位尚不明朗。當 handle 只是整數型別時，與其關聯資源之生命週期意義為何？所有具有相同值的整數型別會共享該關連嗎？</p>
<p>Rust <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">參考手冊</a>根據 <a href="http://llvm.org/docs/LangRef.html#pointer-aliasing-rules">LLVM 的指標別名規則</a>定義了記憶體的未定義行為；輸入輸出可能需要類似的 handle 別名規則。這對目前的實際需求而言似非必要，但未來可對此進行探索。</p>
<h1 id="未來展望-1"><a class="header" href="#未來展望-1">未來展望</a></h1>
<p>以下包含一些從此 RFC 延伸的可能想法：</p>
<ul>
<li>
<p>Clippy 警吿常見的輸入輸出不安全狀況。</p>
</li>
<li>
<p>一個原始 handle 所有權形式化模型。可想像為延伸 Miri 使其揪出「關閉後使用」和「使用偽造的 handle」這類錯誤。</p>
</li>
<li>
<p>一個屬於 Rust，細緻且基於能力的安全模型（capabability-based security model）。藉由此模型提供的保證，在 safe Rust 語境下就不可能偽造出假的原始 handle 高階封裝。</p>
</li>
<li>
<p>還可替有實作 <code>AsFd</code>、<code>Into&lt;OwnedFd&gt;</code> 或 <code>From&lt;OwnedFd&gt;</code> 的型別添加一些方便的功能：</p>
<ul>
<li><code>from_into_fd</code> 函式：取得 <code>Into&lt;OwnedFd&gt;</code> 並將之轉為 <code>From&lt;OwnedFd&gt;</code>，讓使用者一步執行這些常見的轉換步驟。</li>
<li><code>as_filelike_view::&lt;T&gt;()</code> 函式：回傳一個 <code>View</code>，其中包含內部檔案描述子構建出來的暫時實例 T，讓使用者能以 <code>File</code> 或 <code>TcpStream</code> 等方式查看原始的檔案描述子。</li>
</ul>
</li>
<li>
<p>簡單使用情景的可攜性。由於 Windows 有兩種不同的 handle 型別，但 Unix 只有一種，因此在這領域中達成可攜性並非易事。然而，在部分案例中，可將 <code>AsFd</code> 和 <code>AsHandle</code> 一視同仁，而另外一些情況則可以把 <code>AsFd</code> 和 <code>AsSocket</code> 當作相同的。在這兩類情形，普通的 <code>FileLike</code> 和 <code>SocketLike</code> 抽象化能讓程式碼泛用在 Unix 和 Windows 上。</p>
<p>類似的可攜性也能推廣到 <code>From&lt;OwnedFd&gt;</code> 及 <code>Into&lt;OwnedFd&gt;</code>。</p>
</li>
</ul>
<h1 id="致謝"><a class="header" href="#致謝">致謝</a></h1>
<p>感謝 Ralf Jung (<a href="https://github.com/RalfJung">@RalfJung</a>) 引導我理解這個主題至此，鼓勵我和審核這個 RFC 的草案，並耐心回答我諸多問題！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
