<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust RFC Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="0049-match-arm-attributes.html">0049-match-arm-attributes</a></li><li class="chapter-item expanded "><a href="0198-slice-notation.html">0198-slice-notation</a></li><li class="chapter-item expanded "><a href="1548-global-asm.html">1548-global-asm</a></li><li class="chapter-item expanded "><a href="1598-generic_associated_types.html">1598-generic_associated_types</a></li><li class="chapter-item expanded "><a href="2000-const-generics.html">2000-const-generics</a></li><li class="chapter-item expanded "><a href="2342-const-control-flow.html">2342-const-control-flow</a></li><li class="chapter-item expanded "><a href="2394-async_await.html">2394-async_await</a></li><li class="chapter-item expanded "><a href="2495-min-rust-version.html">2495-min-rust-version</a></li><li class="chapter-item expanded "><a href="2592-futures.html">2592-futures</a></li><li class="chapter-item expanded "><a href="2789-sparse-index.html">2789-sparse-index</a></li><li class="chapter-item expanded "><a href="2843-llvm-asm.html">2843-llvm-asm</a></li><li class="chapter-item expanded "><a href="3128-io-safety.html">3128-io-safety</a></li><li class="chapter-item expanded "><a href="3151-scoped-threads.html">3151-scoped-threads</a></li><li class="chapter-item expanded "><a href="3392-leadership-council.html">3392-leadership-council</a></li><li class="chapter-item expanded "><a href="alternatives.html">alternatives</a></li><li class="chapter-item expanded "><a href="initial-work-of-the-council.html">initial-work-of-the-council</a></li><li class="chapter-item expanded "><a href="motivation.html">motivation</a></li><li class="chapter-item expanded "><a href="non-goals.html">non-goals</a></li><li class="chapter-item expanded affix "><a href="CONTRIBUTING.html">Contributing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-rfcs---active-rfc-list"><a class="header" href="#rust-rfcs---active-rfc-list">Rust RFCs - <a href="https://rfcbot.rs/">Active RFC List</a></a></h1>
<p><strong>注意</strong>：這是官方 rust rfcs 的 fork。如果你有興趣協助翻譯的話，歡迎前往 <a href="CONTRIBUTING.html">CONTRIBUTING.md</a> 瞭解更多細節。</p>
<p><strong>Note</strong>: This is a fork of official rust rfcs. If you are interested in help translating, please have a look at <a href="CONTRIBUTING.html">CONTRIBUTING.md</a>.</p>
<p>Many changes, including bug fixes and documentation improvements can be
implemented and reviewed via the normal GitHub pull request workflow.</p>
<p>Some changes though are &quot;substantial&quot;, and we ask that these be put through a
bit of a design process and produce a consensus among the Rust community and
the <a href="http://www.rust-lang.org/team.html">sub-team</a>s.</p>
<p>The &quot;RFC&quot; (request for comments) process is intended to provide a consistent
and controlled path for new features to enter the language and standard
libraries, so that all stakeholders can be confident about the direction the
language is evolving in.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="introduction.html#rust-rfcs">Opening</a></li>
<li><a href="introduction.html#table-of-contents">Table of Contents</a></li>
<li><a href="introduction.html#when-you-need-to-follow-this-process">When you need to follow this process</a></li>
<li><a href="introduction.html#before-creating-an-rfc">Before creating an RFC</a></li>
<li><a href="introduction.html#what-the-process-is">What the process is</a></li>
<li><a href="introduction.html#the-rfc-life-cycle">The RFC life-cycle</a></li>
<li><a href="introduction.html#reviewing-rfcs">Reviewing RFCs</a></li>
<li><a href="introduction.html#implementing-an-rfc">Implementing an RFC</a></li>
<li><a href="introduction.html#rfc-postponement">RFC Postponement</a></li>
<li><a href="introduction.html#help-this-is-all-too-informal">Help this is all too informal!</a></li>
<li><a href="introduction.html#license">License</a></li>
</ul>
<h2 id="when-you-need-to-follow-this-process"><a class="header" href="#when-you-need-to-follow-this-process">When you need to follow this process</a></h2>
<p>You need to follow this process if you intend to make &quot;substantial&quot; changes to
Rust, Cargo, Crates.io, or the RFC process itself. What constitutes a
&quot;substantial&quot; change is evolving based on community norms and varies depending
on what part of the ecosystem you are proposing to change, but may include the
following.</p>
<ul>
<li>Any semantic or syntactic change to the language that is not a bugfix.</li>
<li>Removing language features, including those that are feature-gated.</li>
<li>Changes to the interface between the compiler and libraries, including lang
items and intrinsics.</li>
<li>Additions to <code>std</code>.</li>
</ul>
<p>Some changes do not require an RFC:</p>
<ul>
<li>Rephrasing, reorganizing, refactoring, or otherwise &quot;changing shape does
not change meaning&quot;.</li>
<li>Additions that strictly improve objective, numerical quality criteria
(warning removal, speedup, better platform coverage, more parallelism, trap
more errors, etc.)</li>
<li>Additions only likely to be <em>noticed by</em> other developers-of-rust,
invisible to users-of-rust.</li>
</ul>
<p>If you submit a pull request to implement a new feature without going through
the RFC process, it may be closed with a polite request to submit an RFC first.</p>
<h3 id="sub-team-specific-guidelines"><a class="header" href="#sub-team-specific-guidelines">Sub-team specific guidelines</a></h3>
<p>For more details on when an RFC is required for the following areas, please see
the Rust community's <a href="http://www.rust-lang.org/team.html">sub-team</a> specific guidelines for:</p>
<ul>
<li><a href="lang_changes.html">language changes</a>,</li>
<li><a href="libs_changes.html">library changes</a>,</li>
<li><a href="compiler_changes.html">compiler changes</a>.</li>
</ul>
<h2 id="before-creating-an-rfc"><a class="header" href="#before-creating-an-rfc">Before creating an RFC</a></h2>
<p>A hastily-proposed RFC can hurt its chances of acceptance. Low quality
proposals, proposals for previously-rejected features, or those that don't fit
into the near-term roadmap, may be quickly rejected, which can be demotivating
for the unprepared contributor. Laying some groundwork ahead of the RFC can
make the process smoother.</p>
<p>Although there is no single way to prepare for submitting an RFC, it is
generally a good idea to pursue feedback from other project developers
beforehand, to ascertain that the RFC may be desirable; having a consistent
impact on the project requires concerted effort toward consensus-building.</p>
<p>The most common preparations for writing and submitting an RFC include talking
the idea over on our <a href="https://discord.gg/rust-lang">official Discord server</a>, discussing the topic on our
<a href="http://internals.rust-lang.org/">developer discussion forum</a>, and occasionally posting &quot;pre-RFCs&quot; on the
developer forum. You may file issues on this repo for discussion, but these are
not actively looked at by the teams.</p>
<p>As a rule of thumb, receiving encouraging feedback from long-standing project
developers, and particularly members of the relevant <a href="http://www.rust-lang.org/team.html">sub-team</a> is a good
indication that the RFC is worth pursuing.</p>
<h2 id="what-the-process-is"><a class="header" href="#what-the-process-is">What the process is</a></h2>
<p>In short, to get a major feature added to Rust, one must first get the RFC
merged into the RFC repository as a markdown file. At that point the RFC is
&quot;active&quot; and may be implemented with the goal of eventual inclusion into Rust.</p>
<ul>
<li>Fork the RFC repo <a href="http://github.com/rust-lang/rfcs">RFC repository</a></li>
<li>Copy <code>0000-template.md</code> to <code>text/0000-my-feature.md</code> (where &quot;my-feature&quot; is
descriptive). Don't assign an RFC number yet; This is going to be the PR
number and we'll rename the file accordingly if the RFC is accepted.</li>
<li>Fill in the RFC. Put care into the details: RFCs that do not present
convincing motivation, demonstrate lack of understanding of the design's
impact, or are disingenuous about the drawbacks or alternatives tend to
be poorly-received.</li>
<li>Submit a pull request. As a pull request the RFC will receive design
feedback from the larger community, and the author should be prepared to
revise it in response.</li>
<li>Each pull request will be labeled with the most relevant <a href="http://www.rust-lang.org/team.html">sub-team</a>, which
will lead to its being triaged by that team in a future meeting and assigned
to a member of the subteam.</li>
<li>Build consensus and integrate feedback. RFCs that have broad support are
much more likely to make progress than those that don't receive any
comments. Feel free to reach out to the RFC assignee in particular to get
help identifying stakeholders and obstacles.</li>
<li>The sub-team will discuss the RFC pull request, as much as possible in the
comment thread of the pull request itself. Offline discussion will be
summarized on the pull request comment thread.</li>
<li>RFCs rarely go through this process unchanged, especially as alternatives
and drawbacks are shown. You can make edits, big and small, to the RFC to
clarify or change the design, but make changes as new commits to the pull
request, and leave a comment on the pull request explaining your changes.
Specifically, do not squash or rebase commits after they are visible on the
pull request.</li>
<li>At some point, a member of the subteam will propose a &quot;motion for final
comment period&quot; (FCP), along with a <em>disposition</em> for the RFC (merge, close,
or postpone).
<ul>
<li>This step is taken when enough of the tradeoffs have been discussed that
the subteam is in a position to make a decision. That does not require
consensus amongst all participants in the RFC thread (which is usually
impossible). However, the argument supporting the disposition on the RFC
needs to have already been clearly articulated, and there should not be a
strong consensus <em>against</em> that position outside of the subteam. Subteam
members use their best judgment in taking this step, and the FCP itself
ensures there is ample time and notification for stakeholders to push back
if it is made prematurely.</li>
<li>For RFCs with lengthy discussion, the motion to FCP is usually preceded by
a <em>summary comment</em> trying to lay out the current state of the discussion
and major tradeoffs/points of disagreement.</li>
<li>Before actually entering FCP, <em>all</em> members of the subteam must sign off;
this is often the point at which many subteam members first review the RFC
in full depth.</li>
</ul>
</li>
<li>The FCP lasts ten calendar days, so that it is open for at least 5 business
days. It is also advertised widely,
e.g. in <a href="https://this-week-in-rust.org/">This Week in Rust</a>. This way all
stakeholders have a chance to lodge any final objections before a decision
is reached.</li>
<li>In most cases, the FCP period is quiet, and the RFC is either merged or
closed. However, sometimes substantial new arguments or ideas are raised,
the FCP is canceled, and the RFC goes back into development mode.</li>
</ul>
<h2 id="the-rfc-life-cycle"><a class="header" href="#the-rfc-life-cycle">The RFC life-cycle</a></h2>
<p>Once an RFC becomes &quot;active&quot; then authors may implement it and submit the
feature as a pull request to the Rust repo. Being &quot;active&quot; is not a rubber
stamp, and in particular still does not mean the feature will ultimately be
merged; it does mean that in principle all the major stakeholders have agreed
to the feature and are amenable to merging it.</p>
<p>Furthermore, the fact that a given RFC has been accepted and is &quot;active&quot;
implies nothing about what priority is assigned to its implementation, nor does
it imply anything about whether a Rust developer has been assigned the task of
implementing the feature. While it is not <em>necessary</em> that the author of the
RFC also write the implementation, it is by far the most effective way to see
an RFC through to completion: authors should not expect that other project
developers will take on responsibility for implementing their accepted feature.</p>
<p>Modifications to &quot;active&quot; RFCs can be done in follow-up pull requests. We
strive to write each RFC in a manner that it will reflect the final design of
the feature; but the nature of the process means that we cannot expect every
merged RFC to actually reflect what the end result will be at the time of the
next major release.</p>
<p>In general, once accepted, RFCs should not be substantially changed. Only very
minor changes should be submitted as amendments. More substantial changes
should be new RFCs, with a note added to the original RFC. Exactly what counts
as a &quot;very minor change&quot; is up to the sub-team to decide; check
<a href="introduction.html#sub-team-specific-guidelines">Sub-team specific guidelines</a> for more details.</p>
<h2 id="reviewing-rfcs"><a class="header" href="#reviewing-rfcs">Reviewing RFCs</a></h2>
<p>While the RFC pull request is up, the sub-team may schedule meetings with the
author and/or relevant stakeholders to discuss the issues in greater detail,
and in some cases the topic may be discussed at a sub-team meeting. In either
case a summary from the meeting will be posted back to the RFC pull request.</p>
<p>A sub-team makes final decisions about RFCs after the benefits and drawbacks
are well understood. These decisions can be made at any time, but the sub-team
will regularly issue decisions. When a decision is made, the RFC pull request
will either be merged or closed. In either case, if the reasoning is not clear
from the discussion in thread, the sub-team will add a comment describing the
rationale for the decision.</p>
<h2 id="implementing-an-rfc"><a class="header" href="#implementing-an-rfc">Implementing an RFC</a></h2>
<p>Some accepted RFCs represent vital features that need to be implemented right
away. Other accepted RFCs can represent features that can wait until some
arbitrary developer feels like doing the work. Every accepted RFC has an
associated issue tracking its implementation in the Rust repository; thus that
associated issue can be assigned a priority via the triage process that the
team uses for all issues in the Rust repository.</p>
<p>The author of an RFC is not obligated to implement it. Of course, the RFC
author (like any other developer) is welcome to post an implementation for
review after the RFC has been accepted.</p>
<p>If you are interested in working on the implementation for an &quot;active&quot; RFC, but
cannot determine if someone else is already working on it, feel free to ask
(e.g. by leaving a comment on the associated issue).</p>
<h2 id="rfc-postponement"><a class="header" href="#rfc-postponement">RFC Postponement</a></h2>
<p>Some RFC pull requests are tagged with the &quot;postponed&quot; label when they are
closed (as part of the rejection process). An RFC closed with &quot;postponed&quot; is
marked as such because we want neither to think about evaluating the proposal
nor about implementing the described feature until some time in the future, and
we believe that we can afford to wait until then to do so. Historically,
&quot;postponed&quot; was used to postpone features until after 1.0. Postponed pull
requests may be re-opened when the time is right. We don't have any formal
process for that, you should ask members of the relevant sub-team.</p>
<p>Usually an RFC pull request marked as &quot;postponed&quot; has already passed an
informal first round of evaluation, namely the round of &quot;do we think we would
ever possibly consider making this change, as outlined in the RFC pull request,
or some semi-obvious variation of it.&quot; (When the answer to the latter question
is &quot;no&quot;, then the appropriate response is to close the RFC, not postpone it.)</p>
<h3 id="help-this-is-all-too-informal"><a class="header" href="#help-this-is-all-too-informal">Help this is all too informal!</a></h3>
<p>The process is intended to be as lightweight as reasonable for the present
circumstances. As usual, we are trying to let the process be driven by
consensus and community norms, not impose more structure than necessary.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>This repository is currently in the process of being licensed under either of:</p>
<ul>
<li>Apache License, Version 2.0, (<a href="LICENSE-APACHE">LICENSE-APACHE</a> or http://www.apache.org/licenses/LICENSE-2.0)</li>
<li>MIT license (<a href="LICENSE-MIT">LICENSE-MIT</a> or http://opensource.org/licenses/MIT)</li>
</ul>
<p>at your option. Some parts of the repository are already licensed according to those terms. For more see <a href="https://github.com/rust-lang/rfcs/pull/2044">RFC 2044</a> and its <a href="https://github.com/rust-lang/rust/issues/43461">tracking issue</a>.</p>
<h3 id="contributions"><a class="header" href="#contributions">Contributions</a></h3>
<p>Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2014-03-20</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/49">rust-lang/rfcs#49</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/12812">rust-lang/rust#12812</a></li>
<li>Translators: [<a href="https://github.com/FizzyElt">@FizzyElt</a>]</li>
<li>Commit: <a href="https://github.com/rust-lang/rfcs/blob/0e2baed56a1d31a65f58f4cb615eedfaad59c2e3/text/0049-match-arm-attributes.md">The commit link this page based on</a></li>
<li>Updated: 2022-05-17</li>
</ul>
<h1 id="概要"><a class="header" href="#概要">概要</a></h1>
<p>允許屬性在配對分支上</p>
<h1 id="動機"><a class="header" href="#動機">動機</a></h1>
<p>有時希望使用屬性來注釋配對語句的分支，例如條件編譯 <code>#[cfg]</code> 或是分支權重（後者為最重要的用途）。</p>
<p>對於條件編譯，暫時得解決辦法是使用 <code>#[cfg]</code> 來重複宣告相同函式來處理不同的案例。一個案例研究是 <a href="https://github.com/sfackler/rust-openssl">sfackler 的 bindings to OpenSSL</a>，在多數的發行版本中移除了 SSLv2 支持，因此 Rust bindings 部分需要被條件禁用。支援各種不同 SSL 版本最顯而易見的方法是使用枚舉。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum SslMethod {
    #[cfg(sslv2)]
    /// Only support the SSLv2 protocol
    Sslv2,
    /// Only support the SSLv3 protocol
    Sslv3,
    /// Only support the TLSv1 protocol
    Tlsv1,
    /// Support the SSLv2, SSLv3 and TLSv1 protocols
    Sslv23,
}
<span class="boring">}</span></code></pre></pre>
<p>然而，所有的 <code>match</code> 只能在 <code>cfg</code> 啟用時使用 <code>Sslv2</code>，例如下面內容是無效的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn name(method: SslMethod) -&gt; &amp;'static str {
    match method {
        Sslv2 =&gt; &quot;SSLv2&quot;,
        Sslv3 =&gt; &quot;SSLv3&quot;,
        _ =&gt; &quot;...&quot;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>一個有效的方法則必須有兩個定義：<code>#[cfg(sslv2)] fn name(...)</code> 和 <code>#[cfg(not(sslv2)] fn name(...)</code>
。前者有 <code>Sslv2</code> 的分支，後者沒有。顯然，對於枚舉中每個額外的 <code>cfg</code> 變體，這都會以指數型的方式爆炸。</p>
<p>分支權重將允許仔細的微優化器（micro-optimiser）通知編譯器，例如，鮮少採取某個配對分支：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match foo {
    Common =&gt; {}
    #[cold]
    Rare =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<h1 id="詳細設計"><a class="header" href="#詳細設計">詳細設計</a></h1>
<p>一般的屬性語法，應用於整個配對分支。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match x {
    #[attr]
    Thing =&gt; {}

    #[attr]
    Foo | Bar =&gt; {}

    #[attr]
    _ =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<h1 id="替代方案"><a class="header" href="#替代方案">替代方案</a></h1>
<p>實際上沒有通用的替代方案; 人們也許可以用一些巨集（macro）和輔助函數來解決條件枚舉變體的配對問題; 但一般來說，這起不了任何作用。</p>
<h1 id="未解決的問題"><a class="header" href="#未解決的問題">未解決的問題</a></h1>
<p>無</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2014-09-11</li>
<li>RFC PR #: <a href="https://github.com/rust-lang/rfcs/pull/198">rust-lang/rfcs#198</a></li>
<li>Rust Issue #: <a href="https://github.com/rust-lang/rust/issues/17177">rust-lang/rust#17177</a></li>
<li>Translators: [<a href="https://github.com/FizzyElt">@FizzyElt</a>]</li>
<li>Commit: <a href="https://github.com/rust-lang/rfcs/blob/4009b546172c558a1cfa0f39dd81c896312f73d5/text/0198-slice-notation.md">The commit link this page based on</a></li>
<li>Updated: 2022-05-27</li>
</ul>
<h1 id="概要-1"><a class="header" href="#概要-1">概要</a></h1>
<p>此 RFC 增加了<em>多載切片符號</em>：</p>
<ul>
<li><code>foo[]</code> 對應 <code>foo.as_slice()</code></li>
<li><code>foo[n..m]</code> 對應 <code>foo.slice(n, m)</code></li>
<li><code>foo[n..]</code> 對應 <code>foo.slice_from(n)</code></li>
<li><code>foo[..m]</code> 對應 <code>foo.slice_to(m)</code></li>
<li>以上所有的 <code>mut</code> 變體</li>
</ul>
<p>透過<code>Slice</code> 跟 <code>SliceMut</code> 兩個新特徵（trait）。</p>
<p>它還將 範圍<code>配對</code>模式的符號改為 <code>...</code>，以表示它們是包含的，而 <code>..</code> 在切片中是不包含的。</p>
<h1 id="動機-1"><a class="header" href="#動機-1">動機</a></h1>
<p>引入此功能有兩個主要動機。</p>
<h3 id="人因工程"><a class="header" href="#人因工程">人因工程</a></h3>
<p>在處理 vector 或其他類型的容器時，切片操作（特別是 <code>as_slice</code>）是相當常見的基本操作。我們已經有了透過 <code>Index</code> 特徵進行索引的語法，此 RFC 本質上是這特徵的延續。</p>
<p><code>as_slice</code> 運算子尤其重要，自從我們已經擺脫以強迫的方式自動切片，明確地呼叫 <code>as_slice</code> 變得非常普遍，這也是語言中<a href="https://github.com/rust-lang/rust/issues/14983">人因工程優先/第一印象</a>的問題之一。還有一些其他方法可以解決這個特定問題，但這些替代方法具有下方討論的一些缺點（參閱「替代方案」）。</p>
<h3 id="錯誤處理協定"><a class="header" href="#錯誤處理協定">錯誤處理協定</a></h3>
<p>我們正在逐漸走向一個類似 Python 的世界，像是當 <code>n</code> 超出範圍時，<code>foo[n]</code> 會呼叫 <code>fail!</code>，而相應的方法像是 <code>get</code> 則返回 <code>Option</code> 而不是失敗。透過為切片提供類似的符號，我們打開了在整個 vector-like APIs 中遵循相同協定的大門。</p>
<h1 id="詳細設計-1"><a class="header" href="#詳細設計-1">詳細設計</a></h1>
<p>此設計是對 <code>Index</code> 特徵設計的直接延續。我們引入了兩個新特徵（trait），用於不可變與可變切片：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Slice&lt;Idx, S&gt; {
    fn as_slice&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a S;
    fn slice_from(&amp;'a self, from: Idx) -&gt; &amp;'a S;
    fn slice_to(&amp;'a self, to: Idx) -&gt; &amp;'a S;
    fn slice(&amp;'a self, from: Idx, to: Idx) -&gt; &amp;'a S;
}

trait SliceMut&lt;Idx, S&gt; {
    fn as_mut_slice&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut S;
    fn slice_from_mut(&amp;'a mut self, from: Idx) -&gt; &amp;'a mut S;
    fn slice_to_mut(&amp;'a mut self, to: Idx) -&gt; &amp;'a mut S;
    fn slice_mut(&amp;'a mut self, from: Idx, to: Idx) -&gt; &amp;'a mut S;
}
<span class="boring">}</span></code></pre></pre>
<p>（請注意，此處的可變名稱是命名規則可能更改的一部分，將在單獨的 RFC 中描述）。</p>
<p>這些特徵將在解釋以下符號時使用：</p>
<p><em>不可變切片</em></p>
<ul>
<li><code>foo[]</code> 對應 <code>foo.as_slice()</code></li>
<li><code>foo[n..m]</code> 對應 <code>foo.slice(n, m)</code></li>
<li><code>foo[n..]</code> 對應 <code>foo.slice_from(n)</code></li>
<li><code>foo[..m]</code> 對應 <code>foo.slice_to(m)</code></li>
</ul>
<p><em>可變切片</em></p>
<ul>
<li><code>foo[mut]</code> 對應 <code>foo.as_mut_slice()</code></li>
<li><code>foo[mut n..m]</code> 對應 <code>foo.slice_mut(n, m)</code></li>
<li><code>foo[mut n..]</code> 對應 <code>foo.slice_from_mut(n)</code></li>
<li><code>foo[mut ..m]</code> 對應 <code>foo.slice_to_mut(m)</code></li>
</ul>
<p>像 <code>Index</code> 一樣，這種表示法的使用將自動取值，就如同對應的方法調用一樣。因此，如果 <code>T</code> 實現了 <code>Slice&lt;uint, [U]&gt;</code> 和 <code>s: Smaht&lt;T&gt;</code>，那麼 <code>s[]</code> 就可以編譯並具有 <code>&amp;[U]</code> 類型。</p>
<p>請注意，切片是「不包含」（因此 <code>[n..m]</code> 是等於 <code>n &lt;= x &lt; m</code>），而模式配對中的 <code>..</code> 是「包含」。為了避免混淆，我們建議將配對符號更改為 <code>...</code> 來做出區別。更改符號而不是解釋的原因是，「不包含」（分別「包含」）解釋是切片（相較於「配對」）的正確默認值。</p>
<h2 id="使用此語法的基本理由"><a class="header" href="#使用此語法的基本理由">使用此語法的基本理由</a></h2>
<p>用於切片的方括號的選擇很簡單：它與我們的索引表示法契合，並且切片和索引密切相關。</p>
<p>其他一些語言（如 Python 和 Go 和 Fortran）在切片表示法中使用 <code>:</code> 而不是 <code>..</code>。在 Rust 中，<code>..</code> 的選擇受到 Rust 本身其他地方的使用影響，例如固定長度陣列類型 <code>[T, ..n]</code>。用於切片的 <code>..</code> 在 Perl 和 D 中有先例。</p>
<p>有關程式語言中切片表示法歷史的更多資訊，請參閱 <a href="http://en.wikipedia.org/wiki/Array_slicing">維基百科</a>。</p>
<h3 id="mut-限定符"><a class="header" href="#mut-限定符"><code>mut</code> 限定符</a></h3>
<p>可能令人驚訝的是，<code>mut</code> 在建議的切片表示法中作為限定符，而不是用於索引表示法。原因是索引包含隱式取消引用。假如 <code>v: Vec&lt;Foo&gt;</code> 則 <code>v[n]</code> 的類型為 <code>Foo</code>，而不是 <code>&amp;Foo</code> 或 <code>&amp;mut Foo</code>。因此，如果你想透過索引取得可變引用，你可以寫成 <code>&amp;mut v[n]</code>。更廣泛地說，這允許我們在解決可變性之前進行解析/類型檢查。</p>
<p>這種對 <code>Index</code> 的處理符合 C 的傳統，並允許我們寫成 <code>v[0] = foo</code>，而不是 <code>*v[0] = foo</code>。</p>
<p>另一方面，這種方法對於切片是有問題的，因為一般來說，他會產生一個 unsized 類型（在 DST 中），當然，切片是為了給你一個指向切片大小的胖指標，我們不希望立即取消引用。但是，這樣的結果是，我們需要預先知道切片的可變性，因為它決定了表達式的類型。</p>
<h1 id="缺點"><a class="header" href="#缺點">缺點</a></h1>
<p>主要的缺點是增加了語言語法的複雜度。這看起來微不足道，尤其是因為這裡的符號本質上是 &quot;完成&quot; 以 <code>Index</code> 特徵開始的內容。</p>
<h2 id="設計上的限制"><a class="header" href="#設計上的限制">設計上的限制</a></h2>
<p>與 <code>Index</code> 特徵一樣，這迫使結果透過 <code>＆</code> 成為一個引用，這可能會排除切片的普遍化。</p>
<p>解決此問題的一個方法是切片方法使用 <code>self</code> （依值) 而不是 <code>&amp;self</code>，反過來在 <code>&amp;T</code> 而不是 <code>T</code> 上實現特徵。這個方法是否長期可行將取決於方法解析和自動引用的最終規則。</p>
<p>一般來說，當特徵可以應用於類型 <code>T</code> 而不是借用類型 <code>&amp;T</code> 時，特徵系統運作的最好。最終，如果 Rust 獲得了更高的類型（HKT），我們可以將特徵中的切片類型 <code>S</code> 更改為更高的類型，這樣他就是一個由生命週期索引的類型<em>家族</em>。然後，我們可以用 <code>S&lt;'a&gt;</code> 來代替返回值中的 <code>&amp;'a S</code>。在未來，我們應該可以從當前的 <code>Index</code> 和 <code>Slice</code> 特徵設計轉換到一個 HKT 版本，而不會破壞相後的兼容性，方法是對實現舊特徵的類型使用新特徵的全面實現（例如 <code>IndexHKT</code>）。</p>
<h1 id="替代方案-1"><a class="header" href="#替代方案-1">替代方案</a></h1>
<p>對於改善 <code>as_slice</code> 的易用性，有兩個主要替代方案。</p>
<h2 id="強制-自動切片"><a class="header" href="#強制-自動切片">強制: 自動切片</a></h2>
<p>一種可能性是重新引入某種自動切片的強制。我們曾經有一個從（用現今的話來說）<code>Vec&lt;T&gt;</code> 到 <code>&amp;[T]</code> 的強制轉換。由於我們不再強制擁有借來的值，我們現在可能想要一個強制 <code>&amp;Vec&lt;T&gt;</code> 到 <code>&amp;[T]</code> 的轉換：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn use_slice(t: &amp;[u8]) { ... }

let v = vec!(0u8, 1, 2);
use_slice(&amp;v)           // automatically coerce here
use_slice(v.as_slice()) // equivalent
<span class="boring">}</span></code></pre></pre>
<p>不幸的是，添加這樣的強制需要在以下選項中進行選擇：</p>
<ul>
<li>
<p>將強制與 <code>Vec</code> 和 <code>String</code> 連繫起來，這將重新引入對這些原本純粹的函式庫類型的特殊處理，並且意味著其他支援切片的函數庫類型不會受益（違背了一些 DST 的目的）。</p>
</li>
<li>
<p>透過特徵使強制可擴展。然而這是在打開潘朵拉的盒子：這個機制很可能被用來在強制的過程中運行任意的程式碼，所以任何呼叫 <code>foo(a, b, c)</code> 都可能涉及運行程式碼來預處理每個參數。雖然我們最終可能想要這種使用者可擴展的強制機制，但在理解程式碼時，這是一個很<strong>大</strong>的步驟，有很多潛在的不利因素，所以我們應該先追求更保守的解決方案。</p>
</li>
</ul>
<h2 id="解引用"><a class="header" href="#解引用">解引用</a></h2>
<p>另一種可能是讓 <code>String</code> 實現 <code>Deref&lt;str&gt;</code> 和 <code>Vec&lt;T&gt;</code> 實現 <code>Deref&lt;[T]&gt;</code> 一旦 DST 登陸。這樣做將允許顯式的強制機制，例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn use_slice(t: &amp;[u8]) { ... }

let v = vec!(0u8, 1, 2);
use_slice(&amp;*v)          // take advantage of deref
use_slice(v.as_slice()) // equivalent
<span class="boring">}</span></code></pre></pre>
<p>但是，這樣做至少有兩個缺點：</p>
<ul>
<li>
<p>目前不清楚方法解析規則最終將如何與 <code>Deref</code> 互動。特別是，一個領先的提議是，對於一個智慧指標 <code>s: Smaht&lt;T&gt;</code> ，當你呼叫 <code>s.m(...)</code> 時，對於 <code>Smaht&lt;T&gt;</code> 只有 <em>內置</em> 方法 <code>m</code> 被考慮到；僅考慮最大引用值 <code>*s</code> 的特徵方法。</p>
<p>使用這樣的解析策略，為 <code>Vec</code> 實現 <code>Deref</code> 將使得我們無法在 <code>Vec</code> 類型上使用特徵方法 ，除非透過 UFCS，這嚴重限制了程式設計師為 <code>Vec</code> 有效地實現新特徵的能力。</p>
</li>
<li>
<p>將 <code>Vec</code> 作為一個圍繞切片的智慧指標的想法，以及如上所述的 <code>&amp;*v</code> 的使用，有點違反直覺，特別是對於這樣的基本類型。</p>
</li>
</ul>
<p>追根究底，無論如何，切片的符號本身似乎是可取的，如果它能消除對 <code>Vec</code> 和 <code>String</code> 實現 <code>Deref</code> 的需要，那就更好了。</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature Name: global_asm</li>
<li>Start Date: 2016-03-18</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/1548">rust-lang/rfcs#1548</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/35119">rust-lang/rust#35119</a></li>
<li>Translators: [<a href="https://github.com/TSOTSI1">@TSOTSI1</a>]</li>
<li>Commit: <a href="https://github.com/rust-lang/rfcs/blob/f4b8b61a414298ba0f76d9b786d58ccdc34a44bb/text/1548-global-asm.md">The commit link this page based on</a></li>
<li>Updated: 2022-06-29</li>
</ul>
<h1 id="總結"><a class="header" href="#總結">總結</a></h1>
<p>此 RFC 透過添加 <code>global_asm!</code> 巨集（macro）公開了 LLVM 對 <a href="http://llvm.org/docs/LangRef.html#module-level-inline-assembly">module-level inline assembly</a> 的支援。語法非常簡單：它只需要一個包含組合語言代碼的字串字面值。</p>
<p>範例:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>global_asm!(r#&quot;
.globl my_asm_func
my_asm_func:
    ret
&quot;#);

extern {
    fn my_asm_func();
}
<span class="boring">}</span></code></pre></pre>
<h1 id="動機-2"><a class="header" href="#動機-2">動機</a></h1>
<p>此功能有兩個主要使用案例。首先，它允許完全在組合語言中寫入函式，這大大消除了對 <code>naked</code> 屬性的需要。這主要適用於使用自訂呼叫規則（如中斷處置器）的函式。</p>
<p>另一個重要的使用案例是，它允許外部組合語言檔案在 Rust 模組中使用，而無需駭入編譯系統。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>global_asm!(include_str!(&quot;my_asm_file.s&quot;));
<span class="boring">}</span></code></pre></pre>
<p>組合語言檔案也可以由 <code>build.rs</code> 預處理或產生（例如使用 C 預處理器），這將在 Cargo 輸出目錄中產生輸出檔案：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>global_asm!(include_str!(concat!(env!(&quot;OUT_DIR&quot;), &quot;/preprocessed_asm.s&quot;)));
<span class="boring">}</span></code></pre></pre>
<h1 id="詳細設計-2"><a class="header" href="#詳細設計-2">詳細設計</a></h1>
<p>見上文所述，沒有要多補充的。巨集（macro）會直接映射到 LLVM 的 <code>module asm</code>。</p>
<h1 id="缺點-1"><a class="header" href="#缺點-1">缺點</a></h1>
<p>像<code>asm!</code>一樣，這個功能取決於 LLVM 的集成組合語言</p>
<h1 id="替代方案-2"><a class="header" href="#替代方案-2">替代方案</a></h1>
<p>包含外部組合語言的現有方式是使用 <code>build.rs</code> 中的 gcc 編譯組合語言檔案，並將其連結到 Rust 程式中作為靜態庫。</p>
<p>對於完全以組合語言寫入的函式的替代方案是添加一個 <a href="https://github.com/rust-lang/rfcs/pull/1201"><code>#[naked]</code> function attribute</a>.</p>
<h1 id="未解決問題"><a class="header" href="#未解決問題">未解決問題</a></h1>
<p>無</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature Name: generic_associated_types</li>
<li>Start Date: 2016-04-29</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/1598">rust-lang/rfcs#1598</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/44265">rust-lang/rust#44265</a></li>
<li>Translators: <a href="https://github.com/wusyong">@wusyong</a></li>
<li>Commit: <a href="https://github.com/rust-lang/rfcs/commit/a7cd91048eea3d7ae83bec20446e62bad0c45381">a7cd910</a></li>
<li>Updated: 2022-11-02</li>
</ul>
<h1 id="總結-1"><a class="header" href="#總結-1">總結</a></h1>
<p>讓型別建構子（type constructor）能與特徵（trait）相互關聯。在 Rust 使用者最想要的功能中，有個通常稱為「高階種類型別（higher-kinded types）」的功能，而這是達成這項目標的其中一步。關聯型別建構子（associated type constructors）這項特定的功能可以解決高階種類其中一項最普遍的使用情境，比起其他形式的高階種類多型（polymorphism）更容易擴充至原有的型別系統，而且能兼容未來可能所導入的更複雜形式的高階種類多型。</p>
<h1 id="動機-3"><a class="header" href="#動機-3">動機</a></h1>
<p>讓我們先考慮以下的特徵範例來展示可能的動機：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait StreamingIterator {
    type Item&lt;'a&gt;;
    fn next&lt;'a&gt;(&amp;'a mut self) -&gt; Option&lt;Self::Item&lt;'a&gt;&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>這樣的特徵是很實用的，它能提供一種疊代器（Iterator）所回傳的數值能附有一個生命週期，且能與傳至 <code>next</code> 的引用所擁有的生命週期綁定。此特徵最明顯的使用情境就是對一個向量（vector）所產生的疊代器，在每次疊代時都能產生重疊（overlapping）且可變（mutable）的子切片（subslice）。使用標準的 <code>Iterator</code> 介面的話，這樣的實作是無效的，因為每個切片必須活得與整個疊代器一樣長，而非只是透過 <code>next</code> 借用的時間而已。</p>
<p>這樣的特徵無法用現在的 Rust 表現出來，因為它需要依賴某種形式的高階種類多型。本 RFC 將擴充 Rust 來確保此特定形式的高階種類多型，也就是我們在此所稱作的關聯型別建構子。此功能有各種應用場景，但最主要的應用都還是與 <code>StreamingIterator</code> 類似：定義的特徵所持有的型別能附有一個生命週期，並與接收型別所借用的生命週期相互關聯。</p>
<h1 id="設計細節"><a class="header" href="#設計細節">設計細節</a></h1>
<h2 id="背景什麼是種類kind"><a class="header" href="#背景什麼是種類kind">背景：什麼是種類（Kind）？</a></h2>
<p>「高階種類型別」算是比較籠統的詞彙，容易與其他語言功能混淆，而造成我們想表達的概念不精確。所以本 RFC 將簡單介紹種類的概念。種類通常被稱為「型別的型別」，但這樣的解釋對於想理解的人幫助並不大，反而對已經了解這些概念的人才說得通。所以讓我們嘗試用型別比喻來了解種類。</p>
<p>在型別完善的語言中，每個表達式（expression）都有個型別。許多表達式都有所謂的「基本型別」，也就是語言中的原生型別而且無法用其他型別表達。在 Rust 中，<code>bool</code>、<code>i64</code>、<code>usize</code> 與 <code>char</code> 都是基本型別的明顯例子。另一方面，也就會有型別會是由其他型別組成，函式就是屬於這樣的例子。讓我們看看下面這個簡單的函式：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn not(x: bool) -&gt; bool {
   !x
}
<span class="boring">}</span></code></pre></pre>
<p><code>not</code> 的型別為 <code>bool -&gt; bool</code>（抱歉這邊開始會使用些與 Rust 不大一樣的語法），而  <code>not(true)</code> 的型別則是 <code>bool</code>。注意這樣的不同點正是了解高階種類的關鍵。</p>
<p>在種類的分析中，<code>bool</code>、<code>char</code>、<code>bool -&gt; bool</code> 等等型別都有 <code>type</code> 這種種類。每個型別都有  <code>type</code> 種類。然而 <code>type</code> 只是基本種類，就像 <code>bool</code> 只是個基本型別，我們能寫出更複雜的種類像是 <code>type -&gt; type</code>，這樣的種類其中一個範例就是 <code>Vec</code> 能接受一個型別然後產生出一個型別。而 <code>Vec</code> 的種類與 <code>Vec&lt;i32&gt;</code> 的種類（也就是 <code>type</code>）之間的差異，就相對應於 <code>not</code> 與 <code>not(true)</code> 之間的差異。另外注意 <code>Vec&lt;T&gt;</code> 的種類和 <code>Vec&lt;i32&gt;</code> 一樣仍然是 <code>type</code>。盡管 <code>T</code> 是個型別參數，<code>Vec&lt;T&gt;</code> 還是接收了一個型別，就像 <code>not(x)</code> 的型別仍然是 <code>bool</code>，盡管 <code>x</code> 是個變數一樣。</p>
<p>Rust 相對不尋常的特色是它有<strong>兩種</strong>基本種類，相較於許多語言處理高階種類時只會有一種種類 <code>type</code>。Rust 的另一個基本種類就是生命週期參數。如果你有個型別像是 <code>Foo&lt;'a&gt;</code>，<code>Foo</code> 的種類就是 <code>lifetime -&gt; type</code>。</p>
<p>而高階種類當然也可以接受多重引數，<code>Result</code> 的種類就是 <code>type, type -&gt; type</code>，而  <code>vec::Iter&lt;'a, T&gt;</code> 中的 <code>vec::Iter</code> 則會有 <code>lifetime, type -&gt; type</code> 這樣的種類。</p>
<p>高階種類的表達通常就稱為「型別運算子（type operators）」，運算出一個型別的型別運算子就稱作「型別建構子（type constructors）」。也有其他型別運算子能運算出其他型別運算子，而且還有更高階的型別運算子能接收型別運算子作為引數，讓它們的種類變成像是 <code>(type -&gt; type) -&gt; type</code>。本 RFC 將不會討論這些更進階的範疇。</p>
<p>本 RFC 更明確的目標就是要讓型別建構子可以與特徵相互關聯，就像你現在的特徵能與函式、型別與 consts 相互關聯一樣。型別建構子還有包含其他形式的多型，像是對型別建構子實作特徵，而非只是型別而已。但這些都不包含在本 RFC 內。</p>
<h2 id="關聯型別建構子的功能"><a class="header" href="#關聯型別建構子的功能">關聯型別建構子的功能</a></h2>
<h3 id="宣告與賦值給關聯型別建構子"><a class="header" href="#宣告與賦值給關聯型別建構子">宣告與賦值給關聯型別建構子</a></h3>
<p>本 RFC 將提供個非常簡單的語法來定義關聯型別建構子，它會與建立型別建構子的別名用的語法非常相似。使用此語法的目的就是為了避免讓尚未能理解高階種類的使用者使用困難。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait StreamingIterator {
   type Item&lt;'a&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>這樣能清楚表達關聯項目 <code>Item</code> 是一個型別建構子，而非只是個型別，因為它有個型別參數附加在旁。</p>
<p>與關聯型別一樣，關聯型別建構子可以用在界限內：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterable {
    type Item&lt;'a&gt;;
    type Iter&lt;'a&gt;: Iterator&lt;Item = Self::Item&lt;'a&gt;&gt;;
    
    fn iter&lt;'a&gt;(&amp;'a self) -&gt; Self::Iter&lt;'a&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>此界限套用到型別建構子的「輸出」，然後參數會被視為高階參數。也就是說上述的界限幾乎等於對特徵加上這樣的界限：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for&lt;'a&gt; Self::Iter&lt;'a&gt;: Iterator&lt;Item = Self::Item&lt;'a&gt;&gt;
<span class="boring">}</span></code></pre></pre>
<p>在 <code>impl</code> 中賦值給關聯型別建構子的語法與賦值給關聯型別的非常接近：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; StreamingIterator for StreamIterMut&lt;T&gt; {
    type Item&lt;'a&gt; = &amp;'a mut [T];
    ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="使用關聯型別建構子建立型別"><a class="header" href="#使用關聯型別建構子建立型別">使用關聯型別建構子建立型別</a></h3>
<p>一旦特徵擁有關聯型別建構子時，它就能套用在作用域中的任何參數或具體項。這能同時用在特徵的本體內與本體外，使用的語法就與使用關聯型別類似。以下是一些範例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait StreamingIterator {
    type Item&lt;'a&gt;;
    // 在特徵內將生命週期 `'a` 套用至 `Self::Item`。
    fn next&lt;'a&gt;(&amp;'a self) -&gt; Option&lt;Self::Item&lt;'a&gt;&gt;;
}

struct Foo&lt;T: StreamingIterator&gt; {
    // 在特徵外將實際生命週期套用至建構子。
    bar: &lt;T as StreamingIterator&gt;::Item&lt;'static&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>關聯型別建構子也能用來產生其他型別建構子：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    type Bar&lt;'a, 'b&gt;;
}

trait Baz {
    type Quux&lt;'a&gt;;
}

impl&lt;T&gt; Baz for T where T: Foo {
    type Quux&lt;'a&gt; = &lt;T as Foo&gt;::Bar&lt;'a, 'static&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>最後，關聯型別建構子的生命週期和其他型別建構子的一樣能被省略。加上生命週期省略的話，<code>StreamingIterator</code> 的完整定義就可以是：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait StreamingIterator {
    type Item&lt;'a&gt;;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="在界限中使用關聯型別建構子"><a class="header" href="#在界限中使用關聯型別建構子">在界限中使用關聯型別建構子</a></h3>
<p>對於參數的型別是由特徵的關聯型別建構子產生的話，使用者可以用高階特徵界限（Higher-Rank Trait Bounds）來綁定。無論是對型別相等的界限或是對此種類的特徵界限都是有效的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T: for&lt;'a&gt; StreamingIterator&lt;Item&lt;'a&gt;=&amp;'a [i32]&gt;&gt;(iter: T) { ... }

fn foo&lt;T&gt;(iter: T) where T: StreamingIterator, for&lt;'a&gt; T::Item&lt;'a&gt;: Display { ... }
<span class="boring">}</span></code></pre></pre>
<p>本 RFC 並沒有提出任何允許型別建構子自己綁定的形式，無論是相等界限或特徵界限（當然特徵界限是不可能的）。</p>
<h2 id="型別引數的關聯型別建構子"><a class="header" href="#型別引數的關聯型別建構子">型別引數的關聯型別建構子</a></h2>
<p>本 RFC 目前所有的範例都專注在生命週期引數的關聯型別建構子。但是本 RFC 一樣有提出導入型別的關聯型別建構子：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    type Bar&lt;T&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>本 RFC <strong>並沒有</strong>打算讓高階特徵界限能進一步接收型別引數，因為這會讓它們更難清楚地表達語義。我們的確有這樣的擴充需求，但這超出本 RFC 的範疇。</p>
<p>型別引數可以透過「Family」模式來達成其他形式的高階種類多型。舉例來說，使用 <code>PointerFamily</code> 特徵可以將 Arc 與 Rc 抽象出來：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait PointerFamily {
    type Pointer&lt;T&gt;: Deref&lt;Target = T&gt;;
    fn new&lt;T&gt;(value: T) -&gt; Self::Pointer&lt;T&gt;;
}

struct ArcFamily;

impl PointerFamily for ArcFamily {
    type Pointer&lt;T&gt; = Arc&lt;T&gt;;
    fn new&lt;T&gt;(value: T) -&gt; Self::Pointer&lt;T&gt; {
        Arc::new(value)
    }
}

struct RcFamily;

impl PointerFamily for RcFamily {
    type Pointer&lt;T&gt; = Rc&lt;T&gt;;
    fn new&lt;T&gt;(value: T) -&gt; Self::Pointer&lt;T&gt; {
        Rc::new(value)
    }
}

struct Foo&lt;P: PointerFamily&gt; {
    bar: P::Pointer&lt;String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="特徵界限與-where"><a class="header" href="#特徵界限與-where">特徵界限與 where</a></h2>
<h3 id="關聯型別建構子的界限"><a class="header" href="#關聯型別建構子的界限">關聯型別建構子的界限</a></h3>
<p>關聯型別建構子的界限會被視為特徵自己的高階界限。這讓它們的行為能與一般關聯型別的界限一致。舉例來說：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    type Assoc&lt;'a&gt;: Trait&lt;'a&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>就等同於：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo where for&lt;'a&gt; Self::Assoc&lt;'a&gt;: Trait&lt;'a&gt; {
    type Assoc&lt;'a&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="關聯型別上的-where"><a class="header" href="#關聯型別上的-where">關聯型別上的 <code>where</code></a></h3>
<p>另一方面，在關聯型別上使用 where 則會要求每次使用關聯型別時都得滿足其限制。舉例來說：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    type Assoc where Self: Sized;
}
<span class="boring">}</span></code></pre></pre>
<p>每次呼叫 <code>&lt;T as Foo&gt;::Assoc</code> 時都需要證明 <code>T: Sized</code>，就像其他場合需要證明有符合 impl 的界限一樣。</p>
<p>(@nikomatsakis 相信在某些場合的 where 會需要關聯型別建構子指明處理生命週期。實際細節將不會包含在本 RFC，因為這在實際實作時才會更清楚。)</p>
<h2 id="在其他高階種類多型之前只實作此功能的優點"><a class="header" href="#在其他高階種類多型之前只實作此功能的優點">在其他高階種類多型之前只實作此功能的優點</a></h2>
<p>此功能並非完整的高階種類多型，也無法允許那些在 Haskell 中熱門的抽象形式，但它能提供 Rust 獨一無二的高階種類多型使用情境。像是 <code>StreamingIterator</code> 與各式集合的特徵。這很可能也會是許多使用者最需要用到的功能，讓還不知道高階種類的人也能輕易直觀地使用。</p>
<p>此功能會有些麻煩的實作挑戰，但也避免了其他所有高階種類多型所需的功能像是：</p>
<ul>
<li>定義高階種類特徵</li>
<li>對型別運算子實作高階種類</li>
<li>高階型別運算子</li>
<li>高階種類特徵綁定的型別運算子參數</li>
<li>型別運算子參數套用至一個給予的型別或型別參數</li>
</ul>
<h2 id="建議語法的優點"><a class="header" href="#建議語法的優點">建議語法的優點</a></h2>
<p>建議語法的優點在於它建立在已經存在的語法上，型別建構子已經能在 Rust 中使用相同的語法建立別名。雖然型別別名在型別解析上沒有多型的意義，對於使用者來說他們非常類似於關聯型別。此語法的目標就是要讓許多使用者能夠輕易使用具有關聯型別建構子的型別，就算他們沒有察覺到這和高階種類有關。</p>
<h1 id="我們如何教導這個"><a class="header" href="#我們如何教導這個">我們如何教導這個</a></h1>
<p>在本 RFC 我們使用「關聯型別建構子」，這是因為這在 Rust 社群中已經很常拿來使用作為此功能的討論了。但這並沒有很輕易地表達此概念，尤其光是型別理論中的「型別建構子」就已經足以讓人望之卻步了，多數使用者可能並不熟悉這樣的詞彙。</p>
<p>在接受本 RFC 後，我們應該開始稱呼此概念為「泛型關聯型別（generic associated types）」就好，現在的關聯型別還無法使用泛型。在此 RFC 後，這就化為可能了。與其教導這是一個不同的功能，不如介紹說這會是關聯型別的進階使用情境。</p>
<p>像是「Family」特徵的模式也需要同時教導，我們可能會寫進書裡或是某種形式的文件就好，像是網誌文章等。</p>
<p>這也可能會增加使用者使用高階特徵界限的頻率，我們可能會需要挹注更多資源在高階特徵界限上。</p>
<h1 id="缺點-2"><a class="header" href="#缺點-2">缺點</a></h1>
<h2 id="增加語言複雜度"><a class="header" href="#增加語言複雜度">增加語言複雜度</a></h2>
<p>這會對語言增加一定的複雜度，型別建構子將能夠多型產生，而且型別系統也需要幾個擴充，這都讓實作更加複雜。</p>
<p>除此之外，雖然語法設計旨在易於學習此功能，但它更有可能產生模糊空間讓使用者意外使用到，而不是他們原本想寫的，這就像 <code>impl .. for Trait</code> 和 <code>impl&lt;T&gt; .. for T where T: Trait</code> 之間產生的混淆。舉例來說：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 使用者其實想寫這樣
trait Foo&lt;'a&gt; {
    type Bar: 'a;
}

// 但他們寫成這樣
trait Foo&lt;'a&gt; {
    type Bar&lt;'a&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="並非完整的高階種類型別"><a class="header" href="#並非完整的高階種類型別">並非完整的「高階種類型別」</a></h2>
<p>本 RFC 並沒有加入當大家講到高階種類型別時的所有功能。舉例來說，它並沒有辦法提供特徵像是 <code>Monad</code>。有些人傾向於一次實作完所有這些功能。然而，此功能是能夠兼容於其他形式的高階種類多型的，且並沒有將他們的可能性排除掉。事實上，它還解決了一些會影響其他高階種類形式的實作細節，為它們開拓了可能的路徑，像是 Partial Application。</p>
<h2 id="語法與其他形式的高階種類多型都不一樣"><a class="header" href="#語法與其他形式的高階種類多型都不一樣">語法與其他形式的高階種類多型都不一樣</a></h2>
<p>雖然建議的語法非常近似於關聯型別與型別別名的語法，其他形式的高階種類多型可能無法使用相同的語法來表達。基於此原因，定義關聯型別建構子的語法可能會與，舉例來說，對特徵實作型別建構子的語法不同。</p>
<p>不過這些其他形式的高階種類多型也將會依到它們實際的功能來決定語法。要設計一個未知功能的語法是非常困難的。</p>
<h1 id="替代方案-3"><a class="header" href="#替代方案-3">替代方案</a></h1>
<h2 id="進一步強化高階特徵界限而不是關聯型別建構子"><a class="header" href="#進一步強化高階特徵界限而不是關聯型別建構子">進一步強化高階特徵界限而不是關聯型別建構子</a></h2>
<p>其中一種替代方案是強化高階特徵界限，有可能是加入一些省略規則，讓它們更容易使用。</p>
<p>目前可能的 <code>StreamingIterator</code> 也許能被定義成這樣：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait StreamingIterator&lt;'a&gt; {
   type Item: 'a;
   fn next(&amp;'a self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>這樣你就可以綁定型別成 <code>T: for&lt;'a&gt; StreamingIterator&lt;'a&gt;</code> 來避免每次出現 <code>StreamingIterator</code> 時都會被生命週期感染。</p>
<p>然而這樣僅避免了 <code>StreamingIterator</code> 的傳染性，只能用在一些關聯型別建構子能夠表達的型別，而且這更像是針對限制下的權變措施，而非等價的替代方案。</p>
<h2 id="對關聯型別建構子施加限制"><a class="header" href="#對關聯型別建構子施加限制">對關聯型別建構子施加限制</a></h2>
<p>我們常稱呼的「完整高階種類多型」能允許使用型別建構子作為其他型別建構子的輸入參數，換句話說就是高階型別建構子。在沒有任何限制的情況下，多重參數的高階型別建構子會對型別介面帶來嚴重的問題。</p>
<p>舉例來說，當你嘗試推導型別時，而且你知道你有個建構子的形式為 <code>type, type -&gt; Result&lt;(), io::Error&gt;</code>，如果沒有任何限制的話，我們很難判斷此建構子到底是 <code>(), io::Error -&gt; Result&lt;(), io::Error&gt;</code> 還是 <code>io::Error, () -&gt; Result&lt;(), io::Error&gt;</code>。</p>
<p>有鑑於此，將高階種類多型視為第一公民的語言通常都會對這些高階種類施加限制，像是 Haskell 的柯里（currying）規則。</p>
<p>如果 Rust 也要採納高階型別建構子的話，我們需要對型別建構子可以接收的種類施加類似的限制。但關聯型別建構子已經是一種別名，其自然就囊括了實際型別建構子的結構。換句話說，如果我們想要使用關聯型別建構子作為高階型別建構子的引數，我們需要將那些限制施加於<strong>所有</strong>的關聯結構建構子。</p>
<p>我們已經有一份我們認為必要且足夠的限制清單，更多細節可以在 nmatsakis 的<a href="http://smallcultfollowing.com/babysteps/blog/2016/11/09/associated-type-constructors-part-4-unifying-atc-and-hkt/">網誌文章</a>找到：</p>
<ul>
<li>關聯型別建構子的每個引數都必須被套用到</li>
<li>它們必須以它們在關聯型別建構子出現的相同順序來套用</li>
<li>它們必須套用恰好一次而已</li>
<li>它們必須是建構子的最左引數</li>
</ul>
<p>這些限制已經非常有建設性了，我們已經知道有一些關聯型別建構子的應用會被受限於此，像是 <code>Iterable</code> 給 <code>HashMap</code> 的定義（項目 <code>(&amp;'a K, &amp;'a V)</code> 要套用兩次生命週期）。</p>
<p>有鑑於此，我們決定<strong>不要</strong>對所有關聯型別建構子施加這些限制。這代表如果到時候有高階型別建構子加入語言中的話，它們將無法將關聯型別建構子作為引數。然而，這其實能透過新型別（newtypes）來滿足限制，舉例來說：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct IterItem&lt;'a, I: Iterable&gt;(I::Item&lt;'a&gt;);
<span class="boring">}</span></code></pre></pre>
<h1 id="未解決問題-1"><a class="header" href="#未解決問題-1">未解決問題</a></h1>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature Name: <code>const_generics</code></li>
<li>Start Date: 2017-05-01</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/2000">rust-lang/rfcs#2000</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/44580">rust-lang/rust#44580</a></li>
<li>Translators: [<a href="https://github.com/yanganto">@yanganto</a>]</li>
<li>Commit: <a href="https://github.com/rust-tw/rfcs-tw/blob/725bf172f383a21cf74189feb5073705778d2206/text/2000-const-generics.md">The commit link this page based on</a></li>
<li>Updated: 2021-03-26</li>
</ul>
<h1 id="總結-2"><a class="header" href="#總結-2">總結</a></h1>
<p>允許所有型別（type）以作為常數值（constant values）的形式成為泛型（generic），這能讓使用者用 <code>impl</code> 寫出所有陣列型別（array types）。</p>
<h1 id="動機-4"><a class="header" href="#動機-4">動機</a></h1>
<p>現在的 Rust 有一種將常數參數化（parametric）型別︰內建的陣列型別 <code>[T; LEN]</code>。然而，常數泛型（const generics）並非第一級別的功能，使用者無法自己定義將常數值作爲泛型的型別，且不能對所有的陣列實作特徵（traits）。</p>
<p>在此限制下，標準庫僅包含長度最多到 32 的陣列實作，而陣列也因此被視爲語言的第二級別的功能。即使在長度可靜態已知的情形下，也大多調配於堆（heap）上成為向量（vector）而非使用陣列型別，因而造成一定程度上的效能取捨。</p>
<p>常數參數也能讓使用者更自然地指定一個泛型變體（variant）, 且相比於型別更能確切地反應其值。舉例來說，基於某些因素有個型別用一個名稱來作為參數的話，使用 <code>&amp;'static str</code> 來提供其名稱會比（藉由相關的常數或是函式提供的）單元型別（unit type）的形式還來的合理，這能簡化 API。</p>
<p>總結來說，常數可作爲參數使用，讓編譯器在型別檢查時期能確定這些數值。藉由限制哪些數值是否有實作過特定的特徵，孤兒規則（orphan rules）可以確保一個 crate 僅使用部份安全的數值。（例如有關密碼學的相關函式庫）</p>
<h1 id="設計細節-1"><a class="header" href="#設計細節-1">設計細節</a></h1>
<p>現今 Rust 中的型別有兩種參數化的形式︰型別與生命周期。如同在編譯時能推導出這些數值，我們將額外的允許型別將數值參數化。一個常數參數必為單一、特定型別，且可以有效的替換為編譯時期計算出的任意值且該型別將符合本 RFC 以下列出的要求。</p>
<p>（為明確在此 RFC 闡明哪些表達式可在編譯時評估，在之後的範例中，我們假設整數及其基本算數操作可以在編譯時計算。）</p>
<h2 id="詞彙表"><a class="header" href="#詞彙表">詞彙表</a></h2>
<ul>
<li>
<p><b>常數（constant, const value）︰</b>一個在編譯時期可以保證完全評估的 Rust 數值。不同於靜態數值（static），常數將在其使用的位置 inline 而非存在於編譯好的二進制檔案的資料區段。</p>
</li>
<li>
<p><b>常數參數、泛型常數（const parameter, generic const）︰</b>一個由型別或函式抽象而得到的常數。此常數是具體型別的輸入值，例如一個靜態陣列的長度。</p>
</li>
<li>
<p><b>關聯常數（associated const）︰</b>一個由特徵關聯而得到的常數，其相似於關聯型別。不同於常數參數，關聯常數是由型別所決定的。</p>
</li>
<li>
<p><b>常數變數（const variable）︰</b>相比於具體常數，常數參數或關聯常數皆為常數變數。在單態化（monomorphization）之前，一個常數在上下文中是未確定的。</p>
</li>
<li>
<p><b>具體常數（concrete const）︰</b>相比於常數變數，一個在上下文中已知且單一值的常數。</p>
</li>
<li>
<p><b>常數表達式（const expression）︰</b>一個用於評估一個常數的表達式。此可為一個身份表達式或一個在 Rust 常數系統中可以評估出的更複雜的表達式。</p>
</li>
<li>
<p><b>抽象常數表達式（abstract const expression）︰</b>一個包含常數變數的表達式。（因此在單態化結束前其值是無法評估的）</p>
</li>
<li>
<p><b>常數投影（const projection）︰</b>抽象常數表達式的數值（其在泛型上下文中因缺乏所依賴的常數變數而無法被定義）</p>
</li>
<li>
<p><b>身份表達式（identity expression）︰</b>一個在不以其範圍內的名稱進行置換則無法評估的表達式。此包括了所有的文字及身份（ident），例如，<code>3</code>、<code>&quot;Hello, world&quot;</code>、<code>foo_bar</code>。</p>
</li>
</ul>
<h2 id="宣告常數參數"><a class="header" href="#宣告常數參數">宣告常數參數</a></h2>
<p>在型別參數宣告的任何序列中都可以宣告常數參數（例如在一個型別的定義中或是在 <code>impl</code> 的標頭或區塊（block）中）。常數參數的格式爲 <code>const $ident: $ty</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RectangularArray&lt;T, const WIDTH: usize, const HEIGHT: usize&gt; {
    array: [[T; WIDTH]; HEIGHT],
}
<span class="boring">}</span></code></pre></pre>
<p>這些宣告的身份（ident）就是常數參數（在本 RFC 內文中可替稱作「常數變數」）的名稱，而且所有數值必定其推導的型別。本 RFC 後文將說明能被推導的型別有哪些限制。</p>
<p>宣告的常數變數範圍在該項目（type、impl、function、method、…等等）的整體範圍中。</p>
<h2 id="套用常數作為參數"><a class="header" href="#套用常數作為參數">套用常數作為參數</a></h2>
<p>任何可推導出該常數參數型別的常數表達式都可作爲參數。除了陣列外，當套用一個表達式作為常數參數且該表達式並非身份表達式時，該表達式必須包含在區塊內 。此語法上的限制是必要的，以避免在型別中解析表達式需要無限地向前展望（lookahead）。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const X: usize = 7;

let x: RectangularArray&lt;i32, 2, 4&gt;;
let y: RectangularArray&lt;i32, X, {2 * 2}&gt;;
<span class="boring">}</span></code></pre></pre>
<h3 id="陣列"><a class="header" href="#陣列">陣列</a></h3>
<p>陣列語法中有一個特別的構造語法：<code>[T; CONST]</code>。在陣列中大括號不需要存在於任何的常數表達式中，<code>[i32; N * 2]</code> 是一個合理的型別。</p>
<h2 id="何時可使用常數變數"><a class="header" href="#何時可使用常數變數">何時可使用常數變數</a></h2>
<p>常數變數可使用於下列上下文之任一項中︰</p>
<ol>
<li>用於任一型別中的常數，該型別是待定項目之簽章（signature）的一部份：<code>fn foo&lt;const N: usize&gt;(arr: [i32; N])</code></li>
<li>用於定義相關常數的常數表達式或相關型別之參數的一部份</li>
<li>在項目中任何函式的內部之任何運行時表達式中的數值</li>
<li>在項目中任何函式內部用於任何型別的參數，例如在 <code>let x: [i32; N]</code> 或 <code>&lt;[i32; N] as Foo&gt;::bar()</code>。</li>
<li>在項目中任何欄位之型別的一部分（如 <code>struct Foo&lt;const N: usize&gt;([i32; N]);</code>）</li>
</ol>
<p>在一般情況下，常數變數可以用做常數。但有一個明顯的例外是，常數變數不可用於常數、靜態型別、函式、或函式內的型別的建構子，意即下面的例子是不合規的。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;const X: usize&gt;() {
    const Y: usize = X * 2;
    static Z: (usize, usize)= (X, X);

    struct Foo([i32; X]);
}
<span class="boring">}</span></code></pre></pre>
<p>這樣的限制就如同型別型別不能用在函式本體中建造的型別一樣。所有的宣告雖然專用於該項目，但也必需獨立於它，且不能有任何在其範圍內的參數。</p>
<h2 id="兩個常數的型別相等性之相等原則"><a class="header" href="#兩個常數的型別相等性之相等原則">兩個常數的型別相等性之相等原則</a></h2>
<p>在統一且重疊的檢查期間，何時兩個型別是否相等是關重要的。因為型別現在可依賴於常數了，所以我們必須定義我們如何比較兩個常數表達式的相等性。</p>
<p>在大多數情況下，兩個常數的相等性會如同你的預期，如果兩個常數彼此相等，則它們相等。但是仍會有一些特殊的狀況。</p>
<h3 id="結構相等性"><a class="header" href="#結構相等性">結構相等性</a></h3>
<p>常數相等性的定義是根據 <a href="https://github.com/rust-lang/rfcs/blob/master/text/1445-restrict-constants-in-patterns.md">RFC 1445</a> 解釋的結構相等性所定義。只有在型別有「結構相符」的特性下，該結構才可用做常數參數。舉例來說，浮點數就會被排除在外。</p>
<p>在最終解決方案出來前，結構相符這樣的性質應作為權宜之計。無論變數參數採用什麼解決方案，確保相等是具有反射性（reflexive）對於型別相等而言是重要的，這樣才能使得型別始終相同。（浮點數相等的標准定義是不具反射性）</p>
<p>這可能會與未來進行配對（match）的定義而有所不同，但是配對和常數參數不一定得使用相同的相等性定義，現今所使用的相等性定義已經足以滿足我們的目的。</p>
<p>因為常數必須具有結構相符的性質，並且此性質無法強制轉成一個型別變數，因此我們無法定義一個常數參數是從其他型別變數推導來的。（意即 <code>Foo &lt;T，const N：T&gt;</code>不是合規的）</p>
<h3 id="兩個抽像表達式的相等性"><a class="header" href="#兩個抽像表達式的相等性">兩個抽像表達式的相等性</a></h3>
<p>在比較兩個抽象常數表達式（即依賴於變數的表達式）的相等性時，我們無法比較其值的相等性，因其值是由常數變數所決定的，而在在單態化之前是未知的。</p>
<p>基於這個原因，我們至少會將常數表達式的返回值當作投影（projections）。雖然其值仍保持未知，我們仍藉由輸入值來決定其值，這是作法相同於現在我們處理關聯型別（associated types）的作法。此作法我們將稱為常數投影（const projection），對另一個同型別的常數而言，我們永遠無法確定其相等性。</p>
<p>每個常數表達式都會生成一個新的投影，該投影本質上是匿名的。不可能使兩個匿名投影一致（想像兩個關聯型別的泛型 <code>T :: Assoc</code> 和 <code>T :: Item</code>，你無法證明或否定它們是否為同一型別）。因此，除非它們從字面上使用完完全全相同的文字，否則常數表達式在 AST 節點中是彼此不一樣的。這意味著 <code>N + 1</code> 的一個實例不會與另一個 <code>N + 1</code> 的實例在型別相同。</p>
<p>更清楚來說，以下是無法通過型別檢查的，因為 <code>N + 1</code> 會是兩種不同的型別：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;const N: usize&gt;() -&gt; [i32; N + 1] {
    let x: [i32; N + 1] = [0; N + 1];
    x
}
<span class="boring">}</span></code></pre></pre>
<p>但如果這樣寫的話，它將只有一個型別：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo&lt;const N: usize&gt; = [i32; N + 1];

fn foo&lt;const N: usize&gt;() -&gt; Foo&lt;N&gt; {
    let x: Foo&lt;N&gt; = Default::default();
    x
}
<span class="boring">}</span></code></pre></pre>
<h4 id="未來的擴展性"><a class="header" href="#未來的擴展性">未來的擴展性</a></h4>
<p>未來的某一天我們可以利用一些操作的基本性質（例如加法和乘法的可交換性），而對常數投影的相等性做出更聰明的判斷。但是，本 RFC 並不打算在此提案中建造這些可能性，而是打算留給未來的 RFC 決定。</p>
<h2 id="常數變數的特化specialization"><a class="header" href="#常數變數的特化specialization">常數變數的特化（Specialization）</a></h2>
<p>定義常數參數特化的順序也是很重要的。為此，將字面上的定義必需比其他表達式更具體，否則表達式定義的順序上也會產生不確定性。</p>
<p>正如我們有朝一日可以在常數投影上支援更進階的相等性一樣，我們可以支援更進階的特化定義。例如，給定型別為 <code>(i32, i32)</code>，我們可以確定 <code>(0, PARAM2)</code> 比 <code>(PARAM1, PARAM2)</code> 更為具體；<code>(i32, U)</code> 比 <code>(T, U)</code> 更為具體。在未來的某天我們將也有可能在常數特化上支援多元交互（intersectional）和其他更進階的定義。</p>
<h1 id="我們如何教導這個-1"><a class="header" href="#我們如何教導這個-1">我們如何教導這個</a></h1>
<p>常數泛型是一個很龐大的功能，將需要大量的教育資源，這將會需要寫在在書本跟參考文件中，且可能會在書中有獨立的章節。常數泛型的文件化過程本質上將會是一個大工程。</p>
<p>然而，常數泛型應該被視為進階功能，並且在使用 Rust 的初期，我們應該不會向新手介紹這些內容。</p>
<h1 id="缺點-3"><a class="header" href="#缺點-3">缺點</a></h1>
<p>此功能由於允許型別由常數決定，將為型別系統增加了大量的複雜性。它需要抽象變數相等性的確定規則，這出現了很多令人意外的的特殊情況。它增加了 Rust 的很多語法。如果我們不要採用此功能，Rust 肯定會更簡單。</p>
<p>然而，我們已經引入了一種由常數確定的型別（數組型別）。泛型化的功能似乎是必然的，甚至是不可避免的，鑑於此，我們應該盡早決定。</p>
<h1 id="替代方案-4"><a class="header" href="#替代方案-4">替代方案</a></h1>
<p>除了暫緩執行或不執行外，並沒有真的替代方案。</p>
<p>我們可以限制常數泛型為 <code>usize</code> 型別，但這不會讓實作更為簡單。</p>
<p>我們可以對常數相對性的複雜概念更積極地發展，但這會使實作比上述說明得更加複雜。</p>
<p>我們可以選擇稍微不同的語法，例如將在常數跟型別間加上分號。</p>
<h1 id="未解決問題-2"><a class="header" href="#未解決問題-2">未解決問題</a></h1>
<ul>
<li><b>一致的抽象常數表達式︰</b>本 RFC 盡可能最大限度地減少抽象常數表達式的統合性上的處理，從本質上來說，並沒有使其一致。這可能造成無法接受的使用者體驗的不穩定，而我們想要實作一些更進些的統合性之前穩定此功能。</li>
<li><b>常數表達式之正確格式︰</b>只有在單態化過程中，程式不會恐慌（panic）的情況下，此型別才能視爲正確格式。這對於溢出和超出範圍的陣列存取來說很棘手。然而，我們實際上只能確保在函式的簽章中表達式常數的格式進行正確性約束。目前尚不清楚有關在函式中抽象常數表達式之格式正確性的處理方式，也因此使實作推遲。</li>
<li><b>排序與預設參數︰</b>所有常數參數是否將排在最後，或者將它們與型別混合嗎？具有預設值的參數是否須在沒有預設值之後？這些決定推遲到實作語法的討論中。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature Name: <code>const-control-flow</code></li>
<li>Start Date: 2018-01-11</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/2342">rust-lang/rfcs#2342</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/49146">rust-lang/rust#49146</a></li>
<li>Translators: [<a href="https://github.com/CYBAI">@CYBAI</a>]</li>
<li>Commit: <a href="https://github.com/rust-lang/rfcs/blob/dfe697106478a52bddc000477e8cd0621bcc1a20/text/2342-const-control-flow.md">The commit link this page based on</a></li>
<li>Updated: 2020-09-05</li>
</ul>
<h1 id="總結-3"><a class="header" href="#總結-3">總結</a></h1>
<p>透過此功能，可以在常數求值（const evaluation）中使用 <code>if</code> 及 <code>match</code> 並使他們被延遲求值。簡單來說，這項功能允許我們寫 <code>if x &lt; y { y - x } else { x - y }</code>；即使當使用非負型別時在 <code>x &lt; y</code> 的 <code>else</code> 分支會報溢位錯誤 (overflow error)。</p>
<h1 id="動機-5"><a class="header" href="#動機-5">動機</a></h1>
<p>在常數宣告中使用條件式對於建立像是 <code>NonZero::new</code> 的 <code>const fn</code> 及 直譯判定（interpreting assertions）來說很重要。</p>
<h1 id="教學式解說"><a class="header" href="#教學式解說">教學式解說</a></h1>
<p>如果你寫</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32 = ...;
let y: u32 = ...;
let a = x - y;
let b = y - x;
if x &gt; y {
    // do something with a
} else {
    // do something with b
}
<span class="boring">}</span></code></pre></pre>
<p>這支程式永遠都會 panic（除非 <code>x</code> 和 <code>y</code> 同時是 <code>0</code>）因為不管是 <code>x - y</code> 或是 <code>y - x</code> 都會造成溢位。為了解決此問題，我們必須把 <code>let a</code> 及 <code>let b</code> 個別搬進 <code>if</code> 及 <code>else</code> 中。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32 = ...;
let y: u32 = ...;
if x &gt; y {
    let a = x - y;
    // do something with a
} else {
    let b = y - x;
    // do something with b
}
<span class="boring">}</span></code></pre></pre>
<p>當改用常數時，上面的寫法就會出現新問題：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const X: u32 = ...;
const Y: u32 = ...;
const FOO: SomeType = if X &gt; Y {
    const A: u32 = X - Y;
    ...
} else {
    const B: u32 = Y - X;
    ...
};
<span class="boring">}</span></code></pre></pre>
<p><code>A</code> 和 <code>B</code> 會比 <code>FOO</code> 先被求值，因為常數在定義上就是「常數」，所以不應被求值順序影響。這項假設在有錯誤的情況下並不成立，因為錯誤屬於副作用（side effects），因此不純（pure）。</p>
<p>為了解決此問題，我們必須把中介常數消掉並改為直接對 <code>X - Y</code> 及 <code>Y - X</code> 求值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const X: u32 = ...;
const Y: u32 = ...;
const FOO: SomeType = if X &gt; Y {
    let a = X - Y;
    ...
} else {
    let b = Y - X;
    ...
};
<span class="boring">}</span></code></pre></pre>
<h1 id="技術文件式解說"><a class="header" href="#技術文件式解說">技術文件式解說</a></h1>
<p><code>if</code> 或是在 variant 沒有欄位的 enums 上做 <code>match</code> 會在 HIR -&gt; MIR 階段時，被轉譯成 <code>switchInt</code> 終止器（terminator）。Mir 直譯器現在將會針對那些終止器求值（之前就可以了）。</p>
<p>在 variant 沒有欄位的 enums 上做 <code>match</code> 會被轉譯成 <code>switch</code>，表示他會被檢查 discriminant 或是在 packed enums（例如 <code>Option&lt;&amp;T&gt;</code>）的情況會運算 discriminant（這個情況 discriminant 沒有特別的記憶體位址，但他會把所有的零視為 <code>None</code>，並把其他的值都當作 <code>Some</code>）。當進入 <code>match</code> 的分支時，匹配上的值基本上會被 transmute 成 enum 的 variant 型別，如此一來可以允許其他程式碼來存取該 enum 的欄位。</p>
<h1 id="缺點-4"><a class="header" href="#缺點-4">缺點</a></h1>
<p>這項功能容易造成任意「常數」值（如：<code>size_of::&lt;T&gt;()</code> 或是特定的平台常數）編譯失敗。</p>
<h1 id="原理及替代方案"><a class="header" href="#原理及替代方案">原理及替代方案</a></h1>
<h2 id="利用中介-const-fns-來破壞立即常數求值eager-const-evaluation"><a class="header" href="#利用中介-const-fns-來破壞立即常數求值eager-const-evaluation">利用中介 const fns 來破壞立即常數求值（eager const evaluation）</a></h2>
<p>如果寫成</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const X: u32 = ...;
const Y: u32 = ...;
const AB: u32 = if X &gt; Y {
    X - Y
} else {
    Y - X
};
<span class="boring">}</span></code></pre></pre>
<p><code>X - Y</code> 或是 <code>Y - X</code> 其中一方有可能會報錯，這時必須加入中介 const fn</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const X: u32 = ...;
const Y: u32 = ...;
const fn foo(x: u32, y: u32) -&gt; u32 {
    if x &gt; y {
        x - y
    } else {
        y - x
    }
}
const AB: u32 = foo(X, Y);
<span class="boring">}</span></code></pre></pre>
<p>const fn 的 <code>x</code> 和 <code>y</code> 參數未知，無法做常數求值（const evaluate）。當提供此 const fn 參數並求值時，只會對相應的分支求值。</p>
<h1 id="未解決問題-3"><a class="header" href="#未解決問題-3">未解決問題</a></h1>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature Name: async_await</li>
<li>Start Date: 2018-03-30</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/2394">rust-lang/rfcs#2394</a></li>
<li>Rust Issues: 
<ul>
<li><a href="https://github.com/rust-lang/rust/issues/50547">rust-lang/rust#50547</a></li>
<li><a href="https://github.com/rust-lang/rust/issues/62290">rust-lang/rust#62290</a> - #!feature(async_closure)</li>
</ul>
</li>
<li>Translators:[<a href="https://github.com/FizzyElt">@FizzyElt</a>]</li>
<li>Commit: <a href="https://github.com/rust-lang/rfcs/blob/6041dd9ff2ed97eff4e054117cc1581b8c45d8c1/text/2394-async_await.md">The commit link this page based on</a></li>
<li>Updated 2022-09-21</li>
</ul>
<h1 id="概要-2"><a class="header" href="#概要-2">概要</a></h1>
<p>新增 async 和 await 語法，使撰寫程式碼操作 futures 更符合人因工程學。</p>
<p>另有一個<a href="2592-futures.html">配套 RFC</a>，用於向 libstd 和 libcore 新增一個小型 futures API。</p>
<h1 id="動機-6"><a class="header" href="#動機-6">動機</a></h1>
<p>高效能網路服務經常使用非同步 IO，而不是阻塞式 IO，這樣在處理許多並行連線時更容易獲得更好的效能表現。 Rust 已經在網路服務領域得到了一些採用，我們希望透過使 Rust 中撰寫非同步網路服務更符合人因工程學，繼續支援這些使用者 - 並支援其他使用者採用。</p>
<p>Rust 中非同步 IO 的發展經歷了多個階段。在 1.0 之前，我們嘗試在語言中內嵌綠色執行緒（green-threading） runtime。然而，事實證明這太過武斷了——因為它影響了每個用 Rust 撰寫的程式——並且在 1.0 之前不久就被刪除了。在 1.0 之後，非同步 IO 最初的重點是 mio 函式庫，它為 Linux、Mac OS 和 Windows 的非同步 IO 基元（primitive）提供了一個跨平台抽象。 2016 年年中，future crate 的引入產生了重大影響，它為非同步操作提供了一個方便且可共享的抽象。 tokio 函式庫提供了一個基於 mio 的事件循環，可以執行使用 future 介面實作的程式碼。</p>
<p>在獲得基於 future 的生態系統的經驗和使用者的回饋後，我們發現了某些人因工程學挑戰。使用需要在等待點（await point）之間共享的狀態，是非常不符合人因工程學的（需要 Arc 或 join chaining）雖然組合器通常比手動撰寫 future 更符合人因工程學，但它們仍然經常導致混亂的嵌套和 chained callbacks。</p>
<p>幸運的是，Future 抽象非常適合與一種語法糖一起使用——這個語法糖在許多具有非同步 IO 的語言中愈來愈常見：async 和 await 關鍵字。簡而言之，非同步函式回傳一個 future，而不是在呼叫時立即執行。在函式內部，可以使用 await 表達式等待其他 future，這使它們在輪詢 future 時讓出控制權。從使用者的角度來看，他們可以像在使用同步程式碼一樣使用 async/await，並且只需要標注其函式和調用。</p>
<p>Async/await 和 futures 通常是非同步和並行的強大抽象，並且可能可以應用在非同步 I/O 空間以外的地方。我們今天遇到的案例通常與非同步 IO 相關，但透過引入一等公民語法和 libstd 的支援，我們相信更多不直接與非同步 IO 相關的 async 和 await 案例也會蓬勃發展。</p>
<h1 id="教學式解說-1"><a class="header" href="#教學式解說-1">教學式解說</a></h1>
<h2 id="非同步函式"><a class="header" href="#非同步函式">非同步函式</a></h2>
<p>對函式加上 <code>async</code> 關鍵字，使它們成為「非同步函式」：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn function(argument: &amp;str) -&gt; usize {
     // ...
}
<span class="boring">}</span></code></pre></pre>
<p>非同步函式的工作方式與普通函式不同。呼叫非同步函式時，它不會立即進入主體。相反，它執行實作 <code>Future</code> 特徵的匿名型別。當輪詢該 future 時，該函式被執行到它內部的下一個 <code>await</code> 或回傳點（請參閱接下來 await 語法部分）。</p>
<p>非同步函式是延遲計算的一種 - 在您開始輪詢函式回傳的 future 之前，函式本體中沒有任何內容被實際執行。例如：</p>
<pre><pre class="playground"><code class="language-rust">async fn print_async() {
     println!(&quot;Hello from print_async&quot;)
}

fn main() {
     let future = print_async();
     println!(&quot;Hello from main&quot;);
     futures::executor::block_on(future);
}</code></pre></pre>
<p>這將在印出 <code>&quot;Hello from main&quot;</code> 之前印出 <code>&quot;Hello from print_async&quot;</code>。</p>
<p><code>async fn foo(args..) -&gt; T</code> 是 <code>fn(args..) -&gt; impl Future&lt;Output = T&gt;</code> 型別的函式。回傳型別是編譯器產生的匿名型別。</p>
<h3 id="async--closures"><a class="header" href="#async--closures"><code>async ||</code> closures</a></h3>
<p>除了函式，非同步也可以應用在 closure 上面。與非同步函式一樣，非同步 closure 的回傳型別為 <code>impl Future&lt;Output = T&gt;</code>，而不是 <code>T</code>。當您呼叫該 closure 時，它會立即回傳一個 future，且不會執行任何程式碼（就像非同步函式一樣）。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let closure = async || {
         println!(&quot;Hello from async closure.&quot;);
    };
    println!(&quot;Hello from main&quot;);
    let future = closure();
    println!(&quot;Hello from main again&quot;);
    futures::block_on(future);
}</code></pre></pre>
<p>這將在印出 <code>&quot;Hello from async closure.&quot;</code> 之前印出兩個 <code>&quot;Hello from main&quot;</code>。</p>
<p><code>async</code> closure 可以用 <code>move</code> 來捕捉它們包覆在 closure 內的變數的所有權。</p>
<h2 id="async-區塊"><a class="header" href="#async-區塊"><code>async</code> 區塊</a></h2>
<p>您可以使用 <code>async</code> 區塊直接將 future 建立為表達式：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_future = async {
    println!(&quot;Hello from an async block&quot;);
};
<span class="boring">}</span></code></pre></pre>
<p>這種形式幾乎等同於立即呼叫的 <code>async</code> closure。即是：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async { /* body */ }

// is equivalent to

(async || { /* body */ })()
<span class="boring">}</span></code></pre></pre>
<p>除了像 <code>return</code>、<code>break</code> 和 <code>continue</code> 這樣的控制流程結構不允許在 <code>body</code> 中使用（除非它們出現在一個新的控制流上下文中，比如 closure 或 loop）。 尚未確定 <code>?</code> 運算子和提早回傳（early return）在非同步區塊運作的方式（請參閱未解決的問題）。</p>
<p>與 <code>async</code> closure 一樣，<code>async</code> 區塊可以加入 <code>move</code>，以捕捉區塊內所包覆的變數的所有權。</p>
<h2 id="編譯器內嵌的-await"><a class="header" href="#編譯器內嵌的-await">編譯器內嵌的 <code>await!</code></a></h2>
<p>編譯器加入了一個名為 <code>await!</code> 的內建函式。<code>await!</code> 可用於「暫停」future 的計算，將控制權交還給呼叫者。<code>await!</code> 接受任何實作 <code>IntoFuture</code> 的表達式，並計算為此 future 所傳入的泛型型別（如下面範例的 <code>Output</code>）之值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// future: impl Future&lt;Output = usize&gt;
let n = await!(future);
<span class="boring">}</span></code></pre></pre>
<p>await 展開的程式碼，會重複在接收到的 future 上呼叫 <code>poll</code>：<code>poll</code> 回傳 <code>Poll::Pending</code> 時讓出 (yield) 函式的控制權，並在最終回傳 <code>Poll::Ready</code> 時取得項目的值。</p>
<p><code>await!</code> 只能在非同步函式、closure 或區塊內使用，除此之外使用它都是錯誤的。</p>
<p>（<code>await!</code> 是編譯器的內建函式，為以後確定其確切語法保留彈性空間。詳細資訊請參閱〈未解決的問題〉部分。）</p>
<h1 id="技術文件式解說-1"><a class="header" href="#技術文件式解說-1">技術文件式解說</a></h1>
<h2 id="關鍵字"><a class="header" href="#關鍵字">關鍵字</a></h2>
<p><code>async</code> 和 <code>await</code> 在 2018 版本中都成為關鍵字。</p>
<h2 id="async-函式closure區塊的回傳型別"><a class="header" href="#async-函式closure區塊的回傳型別"><code>async</code> 函式、closure、區塊的回傳型別</a></h2>
<p>非同步函式的回傳型別是編譯器生成的唯一匿名型別，和 closure 的型別類似。你可以把這種型別想像成一個枚舉，函式的每個「yield point」都是一個變體——開頭、await 表達式和每一次的回傳。每個變體都會儲存需要保存的狀態，以便從該 yield point 恢復控制。</p>
<p>呼叫函式時，此匿名型別以其初始狀態回傳，其中包含此函式的所有引數。</p>
<h3 id="特徵綁定"><a class="header" href="#特徵綁定">特徵綁定</a></h3>
<p>匿名回傳型別實作 <code>Future</code>，<code>Item</code> 為它的回傳型別。輪詢它會推進函數的狀態，當它在 <code>await</code> 狀態時會返回 <code>Pending</code>；當它在 <code>return</code> 狀態時則返回 <code>Ready</code>。任何在它已經回傳 <code>Ready</code> 一次後對其嘗試進行輪詢都將造成恐慌。</p>
<p>匿名回傳型別對 <code>Unpin</code> 特徵有一個相反的實作，即 <code>impl !Unpin</code>。這是因為 future 可能有內部引用，這意味著它永遠不需要被移動。</p>
<h2 id="匿名-future-的生命週期捕捉"><a class="header" href="#匿名-future-的生命週期捕捉">匿名 future 的生命週期捕捉</a></h2>
<p>該函式的所有輸入生命週期都在非同步函式回傳的 future 捕捉，因為它將函式的所有引數儲存在其初始狀態（可能還有以後的狀態）。也就是說，給定這樣的函數：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn foo(arg: &amp;str) -&gt; usize { ... }
<span class="boring">}</span></code></pre></pre>
<p>它具有與此等效的類型簽名：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'a&gt;(arg: &amp;'a str) -&gt; impl Future&lt;Output = usize&gt; + 'a { ... }
<span class="boring">}</span></code></pre></pre>
<p>這與 <code>impl Trait</code> 的預設值不同，它不捕捉生命週期。這就是為什麼回傳類型是 <code>T</code> 而不是 <code>impl Future&lt;Output = T&gt;</code> 的一個重要部分。</p>
<h3 id="初始化模式"><a class="header" href="#初始化模式">「初始化」模式</a></h3>
<p>有時會出現的一種模式是 future 有一個「初始化」步驟，應該在其建立期間被執行。這在處理資料轉換和臨時借用時很有用。因為 async 函式在您輪詢它之前不會開始計算，並且它會捕捉其引數的生命週期，因此這種模式不能直接用 <code>async fn</code> 表示。</p>
<p>其中一個解決辦法，是撰寫一個回傳 <code>impl Future</code> 的函式，而回傳值是會立即計算 (evaluate) 的 closure：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// only arg1's lifetime is captured in the returned future
fn foo&lt;'a&gt;(arg1: &amp;'a str, arg2: &amp;str) -&gt; impl Future&lt;Output = usize&gt; + 'a {
    // do some initialization using arg2

    // closure which is evaluated immediately
    async move {
         // asynchronous portion of the function
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="await-展開後的程式碼"><a class="header" href="#await-展開後的程式碼">await 展開後的程式碼</a></h2>
<p>內嵌的  <code>await!</code> 展開結果大致如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut future = IntoFuture::into_future($expression);
let mut pin = unsafe { Pin::new_unchecked(&amp;mut future) };
loop {
    match Future::poll(Pin::borrow(&amp;mut pin), &amp;mut ctx) {
          Poll::Ready(item) =&gt; break item,
          Poll::Pending     =&gt; yield,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>這不是真正意義上的『展開』，因為 <code>yield</code> 概念不能用 <code>async</code> 函式中的表層語法來表達。這就是為什麼 <code>await!</code> 是一個內建編譯器函式，而不是實際的巨集。</p>
<h2 id="async-和-move-的順序"><a class="header" href="#async-和-move-的順序"><code>async</code> 和 <code>move</code> 的順序</a></h2>
<p>非同步 closure 和區塊可以用 <code>move</code> 註釋來捕捉它們包覆的變數的所有權。關鍵字的順序固定為 <code>async move</code>。只允許一種順序，可以避免語義上「是否有重要意義」的混淆。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async move {
    // body
}
<span class="boring">}</span></code></pre></pre>
<h1 id="缺點-5"><a class="header" href="#缺點-5">缺點</a></h1>
<p>在 Rust 中新增 async 和 await 語法是對語言的重大更改 - 這是自 1.0 以來最重要的新增功能之一。雖然我們從最小的功能開始，但從長遠來看，它所隱含的功能集也會增長（請參閱未解決的問題部分）。對於這樣一個重要的新增功能，我們絕不能掉以輕心，只有在強烈的動機下才能進行。</p>
<p>我們相信，一個符合人因工程學的非同步 IO 解決方案對於 Rust 作為撰寫高效能網路服務的語言的成功至關重要，這是我們 2018 年的目標之一。基於 Future trait 的 async &amp; await 語法是在不久的將來實現這一目標最便捷和低風險的途徑。</p>
<p>這個 RFC，連同其配套的 lib RFC，對 future 和 async/await 做出比我們過往的專案更堅定的承諾。如果我們在穩定這些特性之後決定反其道而行，那將付出相當大的代價。因為這個 RFC 的存在，增加非同步程式的替代機制的成本會更高。然而，有鑑於我們在 future 方面的經驗，我們相信這是正確的發展方向。</p>
<p>我們所做的幾個小決定也有缺點。例如，在使用「内部」回傳型別和「外部」回傳型別之間有一個權衡。我們可以為非同步函式建立一個不同的求值模型，即在第一個等待（await point）點之前立即對其進行求值。我們在這些問題上做出的决定在 RFC 的相應部分都有說明。</p>
<h1 id="原理和替代方案"><a class="header" href="#原理和替代方案">原理和替代方案</a></h1>
<p>本節包含了本 RFC 拒絕的替代性設計決定（相對於那些只是推遲的設計）。</p>
<h2 id="回傳型別使用-t-而不是-impl-futureoutput--t"><a class="header" href="#回傳型別使用-t-而不是-impl-futureoutput--t">回傳型別（使用 <code>T</code> 而不是 <code>impl Future&lt;Output = T&gt;</code>）</a></h2>
<p>非同步函式的回傳型別是一個有點複雜的問題。對於非同步函式的回傳型別，有兩個不同的觀點：「内部」回傳型別 - 你用 <code>return</code> 關鍵字回傳的型別，以及「外部」回傳型別 - 當你呼叫函式時回傳的型別。</p>
<p>大多數帶有非同步函式的靜態型別語言在函式簽名中顯示「外部」回傳型別。本 RFC 建議在函式簽名中顯示「内部」回傳型別。這既有優點也有缺點。</p>
<h3 id="生命週期消除問題"><a class="header" href="#生命週期消除問題">生命週期消除問題</a></h3>
<p>正如前面所提到的，回傳的 future 捕捉了所有傳入的生命週期。預設情況下，<code>impl Trait</code> 不捕捉任何生命週期。為了準確反應外部回傳型別，有必要消除生命週期的省略：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn foo&lt;'ret, 'a: 'ret, 'b: 'ret&gt;(x: &amp;'a i32, y: &amp;'b i32) -&gt; impl Future&lt;Output = i32&gt; + 'ret {
     *x + *y
}
<span class="boring">}</span></code></pre></pre>
<p>這將是非常不符合人因工程學的，並且使非同步的使用變得更不愉快，更不易於學習。這個問題在決定回傳內部型別時佔很大比重。</p>
<p>我們可以讓它回傳 <code>impl Future</code>，但對於 <code>async fn</code> 的回傳型別，生命週期捕捉的運作方式與其他函式不同，這似乎比顯示內部型別更糟糕。</p>
<h3 id="多型的回傳對我們來說並非是一個因素"><a class="header" href="#多型的回傳對我們來說並非是一個因素">多型的回傳（對我們來說並非是一個因素）</a></h3>
<p>根據 C# 開發者的說法，回傳 <code>Task&lt;T&gt;</code>（他們的「外部型別」）的主要因素之一是，他們希望有可以回傳 <code>Task</code> 以外型別的非同步函式。我們對此沒有一個可以令人信服的實例。</p>
<ol>
<li>在 future 的 0.2 分支中，<code>Future</code> 和 <code>StableFuture</code> 之間是有區別的。然而，這種區分是人為的，單純是因為物件安全（object-safe）的自定義自型別（self-types）在穩定版本上還不能使用。</li>
<li>目前的 <code>#[async]</code> 巨集有一個 <code>(boxed)</code> 變體。我們更傾向於讓非同步函式盡可能的不包裝，只在呼叫處明確包裝。屬性變體的動機是為了支援物件安全特徵中的非同步方法。這是在物件安全特徵中支援 <code>impl Trait</code> 的一個特例（可能是透過在物件情况下對回傳型別進行包裝），我們希望這個特性與非同步函式分開。</li>
<li>有人建議我們支援回傳串流（stream）的 <code>async fn</code>。然而，這意味著内部函式的語意在回傳 future 和串流的函式之間會有顯著的不同。正如在未解决的問題部分所討論的，基於生成器和非同步生成器的解決方案似乎更有機會。</li>
</ol>
<p>基於這些原因，我們認為從多型的角度來看，回傳外部型別的論點並不強烈。</p>
<h3 id="可學習性文件的權衡"><a class="header" href="#可學習性文件的權衡">可學習性/文件的權衡</a></h3>
<p>從可學習性的角度來看，支援外部和内部回傳型別的論點都有。支援外部回傳型別最有說服力的論據之一是文件：當你閱讀自動產生的 API 文件時，你肯定會看到你作為呼叫者得到的東西。相較之下，由於回傳型別和你 <code>return</code> 的表達式的型別之間的對應關係，可以更容易理解如何使用内部回傳型別撰寫非同步函式。</p>
<p>Rustdoc 可以透過幾種方式處理使用内部回傳型別的非同步函式，使其更容易理解。我們至少應該確保在文件中包含 <code>async</code> 註解，這樣了解 async 符號的使用者就知道此函式將回傳一個 future。我們還可以進行其他轉換，可能是可選的，以顯示函式的外部簽名。如何確切處理非同步函式的 API 文件是一個尚未解决的問題。</p>
<h2 id="內嵌語法而不是在生成器中使用巨集"><a class="header" href="#內嵌語法而不是在生成器中使用巨集">內嵌語法，而不是在生成器中使用巨集</a></h2>
<p>另一個選擇是專注於穩定程序性巨集（procedural macro）和生成器，而不是為非同步函式引入內嵌語法。一個非同步函式可以被建模為一個生成器，它將產生 <code>()</code>。</p>
<p>從長遠來看，我們相信我們會希望有專門的語法來處理非同步函式，因為它更符合人因工程學原理，而且使用情境也足夠令人信服和重要，可以證明這一點（類似於 - 例如 - 有内嵌的 for 迴圈和 if 判斷式，而不是有編譯成迴圈和配對判斷式的巨集）。鑑於此，唯一的問題是，我們是否可以透過暫時使用生成器來獲得比現在引入非同步函式更好的穩定性。</p>
<p>使用展開到生成器的巨集似乎不太可能使其更快的穩定。生成器可以表現更多的可能性，並且有更多的開放性問題 - 包括語法和語意。這甚至沒有解決穩定更多程序性巨集的開放問題。出於這個原因，我們認為穩定最小的内嵌 async/await 功能比試圖穩定生成器和 proc 巨集更有效益。</p>
<h2 id="單純基於生成器的-async"><a class="header" href="#單純基於生成器的-async">單純基於生成器的 <code>async</code></a></h2>
<p>另一種設計是將非同步函式作為建立生成器的語法。在這種設計中，我們可以寫一個這樣的生成器：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn foo(arg: Arg) -&gt; Return yield Yield
<span class="boring">}</span></code></pre></pre>
<p>return 和 yield 都是可選的，預設為 <code>()</code>。一個產生 <code>()</code> 的非同步函式將使用全面實作（blanket impl）來實作 <code>Future</code>。一個回傳 <code>()</code> 的非同步函式將實作 <code>Iterator</code>。</p>
<p>此方法的問題是，它不能從人因工程學的角度處理 <code>Stream</code>，Stream 需要產生 <code>Poll&lt;Option&lt;T&gt;&gt;</code>。目前還不清楚在一個產生 <code>()</code> 以外的東西（包括 Stream）的非同步函式裡的 <code>await</code> 如何運作。由於這個原因，「矩陣」方法，即我們對生成器函式、非同步函式和非同步生成器函式有獨立的語法，似乎是一個更可行的方法。</p>
<h2 id="hot-async-functions"><a class="header" href="#hot-async-functions">&quot;Hot async functions&quot;</a></h2>
<p>正如本 RFC 所建議的，所有的非同步函式都會立即回傳，根本不需要執行其主體。如上所述，這對於需要立即進行「初始化」步驟的情境來說並不方便 - 例如，這些情境需要使用一個終端非同步區塊。</p>
<p>另一種方法是讓非同步函式立即求值，直到它們的第一個 <code>await</code>，在那之前保留它們的狀態。這將是一個相當複雜的實現 - 它們需要在 <code>await</code> 中擁有一个額外的 yield point，在輪詢被 await 的 future 之前，條件是 await 是否是 future 主體中的第一個 await。</p>
<p>Rust 的 future 與其它語言的 future 的一個根本區別是，Rust 的 future 除非被輪詢，否則不會做任何事情。整個系统都是圍繞這一點建立的：例如，取消正是因為這個原因而捨棄了 future。相反，在其它語言中，呼叫一個非同步函式會產生一個立即開始執行的 future。這種差異也延續到了 <code>async fn</code> 和 <code>async</code> 區塊中，其中至關重要的是，產生的 future 要<strong>主動輪詢</strong>以取得進展。允許部分、急迫的執行很可能會引發嚴重的混亂和錯誤。</p>
<p>從使用者的角度來看，這也很複雜 - 主體的一部分何時被執行取決於它是否出現在所有 <code>await</code> 語句（可能是巨集生成的）之前。使用终端 async 區塊提供了一個更清晰的機制來區分帶有初始化步驟的 future 中立即執行部分和非同步執行部分。</p>
<h2 id="使用-asyncawait-而不是其他的非同步性系統"><a class="header" href="#使用-asyncawait-而不是其他的非同步性系統">使用 async/await 而不是其他的非同步性系統</a></h2>
<p>最後，一個極端的選擇是放棄 future 和 async/await 作為 Rust 中 async/await 的機制，而採用不同的典範。在這些建議中，有一個常見的效果系统，monad 和 do 語法（do notation）、綠色執行緒和滿堆疊（stack-full）的協程。</p>
<p>假設性上來說，Rust 可以透過 async/await 語法來達成一些泛化（generalization），但在這個領域的研究還不足以在短期内支援它。考慮到我們 2018 年的目標 - 強調 - async/await 語法（一個在許多語言中廣泛存在的概念，與我們現有的 async IO 函式庫運作良好）是在 Rust 發展的這個階段最合理的實作。</p>
<h2 id="非同步區塊與非同步-closure"><a class="header" href="#非同步區塊與非同步-closure">非同步區塊與非同步 closure</a></h2>
<p>正如文中所指出的，非同步區塊和非同步 closure 是密切相關的，而且大致上是可以相互表達的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// almost equivalent
async { ... }
(async || { ... })()

// almost equivalent
async |..| { ... }
|..| async { ... }
<span class="boring">}</span></code></pre></pre>
<p>我們可以考慮只採用兩個結構中的其中一個。然而：</p>
<ul>
<li>
<p>為了與 <code>async fn</code> 保持一致，我們有充分的理由使用 <code>async ||</code>；這樣的 closure 通常對建構一個服務這樣的高階構造很有用。</p>
</li>
<li>
<p>有一個強而有力的理由讓我們採用非同步區塊。RFC 文件中提到的初始化模式，以及事實上它提供了一種更直接、更原始的方式建立 future。</p>
</li>
</ul>
<p>RFC 提議在前面就包含這兩個構造，因為我們似乎不可避免地需要這兩者，但我們總是可以在穩定之前重新思考這個問題。</p>
<h1 id="現有技術"><a class="header" href="#現有技術">現有技術</a></h1>
<p>在其他語言中，包含 C#、JavaScript 和 Python，有很多關於使用 async/await 語法作為處理非同步操作的一種方式的先例。</p>
<p>目前主流的非同步程式設計有以下三種範式：</p>
<ul>
<li>async 和 await 符號。</li>
<li>隱式並行的執行階段程式庫（implicit concurrent runtime），通常稱為「綠色執行緒」，例如通信順序行程（例如 Go）或參與者模型（例如 Erlang）。</li>
<li>延遲執行程式中的 Monadic 轉換，例如：Haskell 的 do 語法（do notation）。</li>
</ul>
<p>async/await 是 Rust 最引人注目的模型，因為它與所有權和借用互動良好（不像基於 Monadic 的系统），而且它使我們能夠擁有一個完全基於函式庫的非同步模型（不像綠色執行緒）。</p>
<p>我們對 async/await 的處理不同於大多數其他靜態型別語言（例如 C#），我們選擇顯示「內部」回傳型別，而不是外部回傳型別。正如在替代方案部分中討論的那樣，在 Rust 定義的特定脈絡下（生命週期省略，不需要回傳型別多型），這種偏差的動機充分。</p>
<h1 id="未解決的問題-1"><a class="header" href="#未解決的問題-1">未解決的問題</a></h1>
<p>本節包含已推延且未包含在此初始 RFC 中設計的延伸。</p>
<h2 id="await-表達式的最終語法"><a class="header" href="#await-表達式的最終語法"><code>await</code> 表達式的最終語法</a></h2>
<p>儘管此 RFC 建議 <code>await</code> 是一個內建的巨集，但我們希望有一天它成為一個正常的控制流結構。如何處理它的運算子優先順序，以及是否需要某種分隔符號則尚待解決。</p>
<p>特別是， <code>await</code> 與 <code>?</code> 有一個有趣的互動。很常見的情況是有一個 future，它將被執行為一個 <code>Result</code>，然後使用者會想把這個结果應用到 <code>?</code> 這意味著 await 應該比 <code>?</code> 有更高的優先順序，這樣該模式就能按照使用者的意願運作。然而，由於它引入了一個空格，看起來這並不是你要得到的優先順序：</p>
<pre><code>await future?
</code></pre>
<p>以下有幾種可能的解決方案：</p>
<ol>
<li>需要某種的分隔符號，可能是大括號或括號或兩者之一，讓它看起來更符合期望的那樣 - await {future}？ - 這很煩躁。</li>
<li>將優先順序定義為，如果優先順序不符使用者本意，需要使用者明確指出 <code>(await future)?</code> - 對使用者來說非常令人驚訝。</li>
<li>將其定義為不方便的優先順序 —— 這似乎與其他優先順序一樣令人驚訝。</li>
<li>引入一種特殊的語法來處理多個應用程式，例如 <code>await? future</code> - 這似乎是很不尋常的方式。</li>
</ol>
<p>這個問題留給未來找尋另一種解決方案，或是從上述方案中選擇最不糟糕的一個。</p>
<h2 id="for-await-和處理串流"><a class="header" href="#for-await-和處理串流"><code>for await</code> 和處理串流</a></h2>
<p>RFC 目前遺漏的另一個延伸是使用 for 迴圈處理串流的能力。可以想像 <code>for await</code> 這樣的結構，它採用 <code>IntoStream</code> 而不是 <code>IntoIterator</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for await value in stream {
    println!(&quot;{}&quot;, value);
}
<span class="boring">}</span></code></pre></pre>
<p>這被排除在最初的 RFC 之外，以避免必須在標準庫中穩定 <code>Stream</code> 的定義（以使與此相關的 RFC 盡可能小）。</p>
<h2 id="生成器和串流"><a class="header" href="#生成器和串流">生成器和串流</a></h2>
<p>將來，我們可能還希望能夠定義對串流求值非同步函式，而不是對 future 求值。我們建議透過生成器來處理這個案例。生成器可以轉換為一種迭代器，而非同步生成器可以轉換為一種串流。</p>
<p>例如（使用的語法可能會改變）；</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Returns an iterator of i32
fn foo(mut x: i32) yield i32 {
     while x &gt; 0 {
          yield x;
          x -= 2;
     }
}

// Returns a stream of i32
async fn foo(io: &amp;AsyncRead) yield i32 {
    async for line in io.lines() {
        yield line.unwrap().parse().unwrap();
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="實現-unpin-的非同步函式"><a class="header" href="#實現-unpin-的非同步函式">實現 <code>Unpin</code> 的非同步函式</a></h2>
<p>如本 RFC 中所提議，所有非同步函式均未實現 <code>Unpin</code>，因此將它們從 <code>Pin</code> 中移出是不安全的。這允許它們包含跨越 yield point 的引用。</p>
<p>我們還可以透過註釋對非同步函式進行型別檢查，以確認它不包含任何跨越 yield point 的引用，從而允許它實做 <code>Unpin</code>。可啟用此功能的註釋暫時未指定。</p>
<h2 id="異步區塊中的--運算子和控制流構造"><a class="header" href="#異步區塊中的--運算子和控制流構造">異步區塊中的 <code>?</code> 運算子和控制流構造</a></h2>
<p>這個 RFC 沒有提出 <code>?</code> 運算子和控制流結構如 <code>return</code>、<code>break</code> 和 <code>continue</code> 應該如何在非同步區塊中工作。</p>
<p>不過有討論非同步區塊應該充當 <code>?</code> 運算子的邊界。讓它們適用於易出錯的 IO：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let reader: AsyncRead = ...;
async {
    let foo = await!(reader.read_to_end())?;
    Ok(foo.parse().unwrap_or(0))
}: impl Future&lt;Output = io::Result&lt;u32&gt;&gt;
<span class="boring">}</span></code></pre></pre>
<p>此外，還討論了允許使用 break 從非同步區塊中提前回傳：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async {
    if true { break &quot;foo&quot; }
}
<span class="boring">}</span></code></pre></pre>
<p>使用 <code>break</code> 關鍵字而不是 <code>return</code> 可能有助於表明它適用於非同步區塊而不是其周圍的函式。另一方面，這會給使用 <code>return</code> 關鍵字的 closure 和非同步 closure 帶來區別。</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature Name: <code>min_rust_version</code></li>
<li>Start Date: 2018-06-28</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/2495">rust-lang/rfcs#2495</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/65262">rust-lang/rust#65262</a></li>
<li>Translators: [<a href="https://github.com/weihanglo">@weihanglo</a>]</li>
<li>Commit: <a href="https://github.com/rust-lang/rfcs/blob/3071138d4ed510d6dfc1f8e1d7e9d4b099ea12e8/text/2495-min-rust-version.md">The commit link this page based on</a></li>
<li>Updated: 2020-09-07</li>
</ul>
<h1 id="總結-4"><a class="header" href="#總結-4">總結</a></h1>
<p>在 <code>Cargo.toml</code> 的 package 區塊加入 <code>rust</code> 欄位，用於指定 crate 的最低支援 Rust 版本（Minimum Supported Rust Version，MSRV）。</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
rust = &quot;1.30&quot;
</code></pre>
<h1 id="動機-7"><a class="header" href="#動機-7">動機</a></h1>
<p>當前 crate 無任何正式方法指定 MSRV，導致使用者無法在不建構該 crate 的情況下得知 crate 是否可透過他們的工具鏈（toolchain）建構。這也帶來有關如何在提升 MSRV 時管理 crate 版本的爭論，保守的作法是將之視為破壞性改動，這種作法會阻礙整個生態採納新功能，或使得版本號通膨式提升，進而讓下游的 crate 很難跟上。另一方面，若作法稍微寬鬆些，則導致採用較舊編譯器版本的使用者無法成功編譯它們的 crate。</p>
<h1 id="教學式解說-2"><a class="header" href="#教學式解說-2">教學式解說</a></h1>
<p>若你想指定一個特定 MSRV 版本，請在 <code>Cargo.toml</code> 的 <code>[package]</code> 區塊中的 <code>rust</code> 欄位設定指定的 Rust 版本。如果你建構一個 crate 時有任一依賴要求的 MSRV 比你當前工具鏈更高，會導致編譯錯誤，指明該依賴與它的 MSRV。這個行為可以透過 <code>--no-msrv-check</code> 選項來停用。</p>
<h1 id="技術文件式解說-2"><a class="header" href="#技術文件式解說-2">技術文件式解說</a></h1>
<p>在建構過程（包含 <code>run</code>、<code>test</code>、<code>benchmark</code>、<code>verify</code> 與 <code>publish</code> 子指令），<code>cargo</code> 會以依賴樹（dependency tree）的形式，檢查所有將要建構或檢查的所有 crate 之 MSRV 要求。在依賴樹內但不會被構建的 crate 不會執行此項檢查（例如特定目標平台或可選的 crate）。</p>
<p><code>rust</code> 欄位應至少遵循下列要求：</p>
<ul>
<li>其值需遵守語意化版號且不能有範圍運算子。注意，「1.50」是合法的值，代表「1.50.0」。</li>
<li>版本不能比當前 stable 工具鏈高（上傳 crate 時 crates.io 會檢查）。</li>
<li>版本不能低於 1.27（此版本將 <code>package.rust</code> 欄位從錯誤改為警告）。</li>
<li>版本不能比選用的 edition 釋出的版本低，舉例來說，同時出現 <code>rust = &quot;1.27&quot;</code> 與 <code>edition = 2018</code> 是非法的。</li>
</ul>
<h1 id="未來展望與延伸"><a class="header" href="#未來展望與延伸">未來展望與延伸</a></h1>
<h2 id="對版本解析之影響"><a class="header" href="#對版本解析之影響">對版本解析之影響</a></h2>
<p><code>rust</code> 欄位之值（手動設定或 <code>cargo</code> 自動選擇）會用於選擇合適的依賴版本。</p>
<p>舉例來說，想像你的 crate 相依 crate <code>foo</code>，一個發佈了從 <code>0.1.0</code> 到 <code>0.1.9</code> 十個版本的 crate，其中 <code>0.1.0</code> 到 <code>0.1.5</code> 版在 crates.io 上 <code>Cargo.toml</code> 的 <code>rust</code> 欄位為「1.30」，其他版本則為「1.40」。現在，你建構一個專案用了例如 Rust 1.33 版，<code>cargo</code> 會選用 <code>foo v0.1.5</code>。<code>foo v0.1.9</code> 只會在你用 Rust 1.40 或更高版本建構專案時選用。倘若你嘗試使用 Rust 1.29 建構專案，cargo 會回報錯誤。</p>
<p><code>rust</code> 欄位值也會被檢核。在 crate 建構過程，<code>cargo</code> 將檢查所有上游相依是否可以在指定 MSRV 下建構。（例如，檢查給定的 crate 與 Rust 版本限制條件下是否存在解）已除去（yank）的 crate 會略過這個檢查步驟。</p>
<p>期望實作這項功能得以替長久以來對 MSRV 提升是否為破壞性改動的爭論劃下休止符，並讓 crate 作者提升 crate 的 MSRV 不再如此綁手綁腳。（儘管對於已 1.0 的 crate 來說，透過提升修訂號（patch version）來提升 MSRV 次版號，以接納修復嚴重問題的 backport，可能是個有用的慣例）</p>
<p>注意，上述 MSRV 限制與依賴版本解析檢查，可以透過 <code>--no-msrv-check</code> 選項停用。</p>
<h2 id="發佈時檢查-msrv"><a class="header" href="#發佈時檢查-msrv">發佈時檢查 MSRV</a></h2>
<p><code>cargo publish</code> 將檢查上傳是以 <code>rust</code> 欄位指定的工具鏈版本完成，若工具鏈版本有異，<code>cargo</code> 會拒絕上傳該 crate。此確保機制避免因為未預期的 MSRV 提升導致錯誤的 <code>rust</code> 欄位值。這項檢查可透過既有的 <code>--no-verify</code> 選項停用。</p>
<h2 id="將-rust-欄位設為必填"><a class="header" href="#將-rust-欄位設為必填">將 <code>rust</code> 欄位設為必填</a></h2>
<p>未來（可能是下一個 edition），我們可以設定新上傳的 crate 的 <code>rust</code> 欄位為必填。既有 crate 的 MSRV 會透過 <code>edition</code> 決定。換句話說 <code>edition = 2018</code> 之 MSRV 必然是 <code>rust = &quot;1.31&quot;</code>，而 <code>edition = &quot;2015&quot;</code> 則是 <code>rust = &quot;1.0&quot;</code>。</p>
<p><code>cargo init</code> 將會使用當前工具鏈使用的版本。</p>
<h2 id="基於-cfg-的-msrv"><a class="header" href="#基於-cfg-的-msrv">基於 <code>cfg</code> 的 MSRV</a></h2>
<p>部分 crate 會根據不同目標架構平台或啟用的功能而有不同的 MSRV。可透過以下方式有效指定 MSRV 如何依賴這些配置：</p>
<pre><code class="language-toml">[package]
rust = &quot;1.30&quot;

[target.x86_64-pc-windows-gnu.package]
rust = &quot;1.35&quot;

[target.'cfg(feature = &quot;foo&quot;)'.package]
rust = &quot;1.33&quot;
</code></pre>
<p>在 <code>target</code> 區塊中所有 <code>rust</code> 值應等於或高於在 <code>package</code> 區塊的 <code>rust</code> 值。</p>
<p>若 <code>target</code> 的條件為真，<code>cargo</code> 會取用該區塊的 <code>rust</code> 值。若多個 target 區塊的條件為真，則取用最大值。</p>
<h2 id="nightly-與-stable-版本"><a class="header" href="#nightly-與-stable-版本">Nightly 與 stable 版本</a></h2>
<p>部分 crate 可能偏好在最新 stable 或 nighly 工具鏈，除了指定版本之外，我們可允許宣告 <code>stable</code> 或 <code>nightly</code> 值，讓維護者不需追蹤該 crate 的 MSRV 。</p>
<p>對於某些超前沿的 crate（例如： <code>rocket</code>）常常因為 Nightly 更新就壞，將可指定特定可成功建構的 Nightly 版本。透過下列語法來達成：</p>
<ul>
<li>自動選擇：<code>nightly</code> 此寫法與寫 <code>stable</code> 的行為一致，將使用等於當前或更高的 nightly 版本。</li>
<li>單一版本：<code>nightly: 2018-01-01</code> （主要寫法）</li>
<li>列舉：<code>nightly: 2018-01-01, 2018-01-15</code></li>
<li>類語意化版本條件：<code>nightly: &gt;=2018-01-01</code>、<code>nightly: &gt;=2018-01-01, &lt;=2018-01-15</code>、<code>nightly: &gt;=2018-01-01, &lt;=2018-01-15, 2018-01-20</code>。（後者會解讀為 「(version &gt;= 2018-01-01 &amp;&amp; version &lt;= 2018-01-20) || version == 2018-01-20」）</li>
</ul>
<p>這些條件或許很嚴苛，盼使用這功能的 crate 一隻手數得出來。</p>
<h1 id="缺點-6"><a class="header" href="#缺點-6">缺點</a></h1>
<ul>
<li>即使宣告了 MSRV 且檢查過，並無法保持 crate 能夠正確在指定 MSRV 下正確執行，只有合理配置的 CI 能做到此事。</li>
<li>更複雜的依賴版本解析演算法。</li>
<li>使用 <code>cargo publish</code> 配合 MSRV <code>rust = &quot;stable&quot;</code> 恐過於保守。</li>
</ul>
<h1 id="替代方案-5"><a class="header" href="#替代方案-5">替代方案</a></h1>
<ul>
<li>自動計算 MSRV。</li>
<li>不做任何事，依靠 <a href="https://github.com/rust-lang/rfcs/pull/2483">LTS 發行</a> 的 crate MSRV 提升。</li>
<li>允許在 <a href="https://github.com/rust-lang/rfcs/pull/2523">RFC 2523</a> 中提出基於版本與路徑的 <code>cfg</code> 屬性（attribute）</li>
</ul>
<h1 id="先驅技術"><a class="header" href="#先驅技術">先驅技術</a></h1>
<p>早先的提案：</p>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/pull/1707">RFC 1707</a></li>
<li><a href="https://github.com/rust-lang/rfcs/pull/1709">RFC 1709</a></li>
<li><a href="https://github.com/rust-lang/rfcs/pull/1953">RFC 1953</a></li>
<li><a href="https://github.com/rust-lang/rfcs/pull/2182">RFC 2182</a>（這個非常有爭議的離題了）</li>
</ul>
<h1 id="未解決問題-4"><a class="header" href="#未解決問題-4">未解決問題</a></h1>
<ul>
<li>瑣碎的命名問題：<code>rust</code> 或 <code>rustc</code> 還是 <code>min-rust-version</code></li>
<li>額外的檢查？</li>
<li>更優質地說明版本解析演算法</li>
<li>nightly 版本如何與「基於 cfg 的 MSRV」運作？</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature Name: <code>futures_api</code></li>
<li>Start Date: 2018-11-09</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/2592">rust-lang/rfcs#2592</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/59113">rust-lang/rust#59113</a></li>
<li>Translators: [<a href="https://github.com/FizzyElt">@FizzyElt</a>]</li>
<li>Commit: <a href="https://github.com/rust-lang/rfcs/blob/a31e5941133de5935b97b5d3e09b921b6e796abb/text/2592-futures.md">The commit link this page based on</a></li>
<li>Updated 2022-08-13</li>
</ul>
<h1 id="概要-3"><a class="header" href="#概要-3">概要</a></h1>
<p>此 RFC 提議替一等公民語法 <code>async</code>/<code>await</code> 穩定相關函式庫組件。特別是，它將穩定：</p>
<ul>
<li><code>std</code> 中任務系統所有的 API，例如 <code>std::task::*</code>。</li>
<li>核心 <code>Future</code> API，例如 <code>core::future::Future</code> 和 <code>std::future::Future</code>。</li>
</ul>
<p>它<strong>不提議</strong>穩定任何 <code>async</code>/<code>await</code> 語法本身，該語法自有另外的提議。它也不包括已在<a href="https://github.com/rust-lang/rust/issues/55766">別處</a>提出的 <code>Pin</code> API 的穩定性。</p>
<p>這是早期 <a href="https://github.com/rust-lang/rfcs/pull/2418">futures RFC</a> 的修訂和精簡版本，該 RFC 已暫緩，直到 nightly 版本獲得更多經驗之後。</p>
<h1 id="動機-8"><a class="header" href="#動機-8">動機</a></h1>
<h2 id="為何-future-要在-std-之中"><a class="header" href="#為何-future-要在-std-之中">為何 <code>Future</code> 要在 <code>std</code> 之中？</a></h2>
<p>此 RFC 的核心動機是穩定 <code>async</code>/<code>await</code> 語法的支援機制。語法本身是在（已經合併的）<a href="https://github.com/rust-lang/rfcs/pull/2394">配套 RFC</a> 中提出的，並且有一篇<a href="https://aturon.github.io/tech/2018/04/24/async-borrowing/">部落格文章</a>更詳細介紹它的重要性。</p>
<p>與 closures 一樣，<code>async</code> 語法涉及到生成一個匿名型別，該型別實作一個關鍵特徵：<code>Future</code>。因為 <code>async</code>/<code>await</code> 需要語言層級的支援，所以底層特徵也必須是標準函式庫的一部分。因此，這個 RFC 的目標是穩定這個 <code>Future</code> 特徵和它所依賴的型別。這是我們能夠穩定 <code>async</code>/<code>await</code> 本身之前所需的最後一步。</p>
<h2 id="這一步是如何融入更大的藍圖之中"><a class="header" href="#這一步是如何融入更大的藍圖之中">這一步是如何融入更大的藍圖之中？</a></h2>
<p><code>async</code>/<code>await</code> 語法是 Rust 中最渴求的特性之一，它將對整個生態系產生重大影響。自 2018 年 5 月下旬以來，該語法及此處描述的 API 已可於 nightly 版本使用，並被大量採用。</p>
<p>穩定此設計的 futures API 部分使函式庫更容易在穩定的 Rust 上工作並無縫支援在 nightly 版本使用 <code>async</code>/<code>await</code>。它還允許我們完成關於 API 部分的設計討論，並專注於在 <code>async</code> 語法穩定之前剩下的幾個問題。</p>
<h1 id="歷史背景"><a class="header" href="#歷史背景">歷史背景</a></h1>
<p>這些被提議要穩定的 API 有著悠久的歷史：</p>
<ul>
<li>
<p><code>Future</code> 特徵從 futures crate 開始； <a href="https://aturon.github.io/tech/2016/08/11/futures/">0.1 於 2016 年 8 月發布</a>。該版本確立了「任務/輪詢」模型的核心思想，以及此處保留的 API 的許多其他方面。 0.1 系列持續在整個 Rust 生態系和正式系統中大量使用。</p>
</li>
<li>
<p>2018 年初，隨著 <code>async</code>/<code>await</code> 的工作開始，futures 團隊建立了一個 RFC 流程並編寫了幾個 <a href="https://github.com/rust-lang-nursery/futures-rfcs/pulls?q=is%3Apr+is%3Aclosed">RFC</a>，以根據長期的社群回饋對核心 API 進行修訂。這些 RFC 最終產生了 <a href="https://aturon.github.io/tech/2018/02/27/futures-0-2-RC/">0.2le</a> 版本，並於 4 月<a href="https://aturon.github.io/tech/2018/04/06/futures2/">釋出</a>。</p>
</li>
<li>
<p>在同一時期，@withoutboats 在支援 <code>async</code> 區塊內借用的 pinning API 上的工作已經<a href="https://boats.gitlab.io/blog/post/2018-04-06-async-await-final/">完成</a>。<a href="https://github.com/rust-lang/rfcs/pull/2349">pinning API</a> 顛覆了過往一切，可在不使 future 的核心 API 成為 unsafe 前提下，支援 borrowing-across-yield。</p>
</li>
<li>
<p>2018 年 4 月，一對 RFC 正式提出了 <code>async</code>/<code>await</code> 語法以及 futures API 的進一步修訂（以利用 pinning API 帶來的好處）；後者經歷了許多修訂，包括一個新的 <a href="https://github.com/rust-lang/rfcs/pull/2418">RFC</a>。最終，語法 <a href="https://github.com/rust-lang/rfcs/pull/2394#issuecomment-387550523">RFC</a> 在 5 月被合併，而 API RFC 被關閉，進一步的設計疊代將在 nightly 版本進行，隨後是一個穩定的 RFC：這個！</p>
</li>
<li>
<p>這些 API 在 5 月底<a href="https://github.com/rust-lang/rust/pull/51263">加入到 <code>std</code></a>。</p>
</li>
<li>
<p>從那時起，隨著我們從 API 獲得的經驗，語法、<code>std</code> API 和 futures 0.3 crate 都在同步發展。這種體驗的主要驅動者是 Google 的 Fuchsia 專案，該專案在作業系統設置中大規模使用所有這些功能。</p>
</li>
<li>
<p>最近的修訂是在 8 月，其中涉及一些關於如何使 <code>Pin</code> API 有更清晰的<a href="https://boats.gitlab.io/blog/post/rethinking-pin/">見解</a>。這些 API 已被<a href="https://github.com/rust-lang/rust/issues/55766">提議要穩定</a>，以及它們作為 <a href="https://github.com/rust-lang/rust/issues/55786"><code>self</code> 型別的用途</a>。</p>
</li>
<li>
<p>有多個相容層可以同時使用 futures 0.1 和 0.3。這很重要，因為它允許現有生產程式碼的<strong>增量</strong>遷移。</p>
</li>
</ul>
<p>自從最初的 futures 0.3 發布以來，除了上面提到的改進之外，核心 <code>Future</code> 特徵和任務系統的變化相對較小。實際的 <code>Future</code> 特徵基本上與 4 月時相同。</p>
<h1 id="教學式解說-3"><a class="header" href="#教學式解說-3">教學式解說</a></h1>
<p><code>Future</code> 特徵代表了一個非同步和惰性計算，它最終可能會產生一個最終值，但不以阻塞當前執行緒為前提來達成。</p>
<p>Future 可以通過 <code>async</code> 區塊或 <code>async</code> 函式來創建，例如</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn read_frame(socket: &amp;TcpStream) -&gt; Result&lt;Frame, io::Error&gt; { ... }
<span class="boring">}</span></code></pre></pre>
<p>當呼叫這個 <code>async</code> 函式，會產生一個 future，代表完成了從给定的 socket 中讀取一個框（frame）。函式簽名等同於：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read_frame&lt;'sock&gt;(socket: &amp;'sock TcpStream)
    -&gt; impl Future&lt;Output = Result&lt;Frame, io::Error&gt;&gt; + 'sock;
<span class="boring">}</span></code></pre></pre>
<p>其他非同步函數可以 <strong>await</strong> 這個 future; 有關完整詳細信息，請參閱<a href="https://github.com/rust-lang/rfcs/pull/2394">隨附的 RFC</a>。</p>
<p>除了 <code>async fn</code> 定義，future 還可以使用轉接器（adapter）來創建，就像 <code>Iterator</code> 一樣。最初，這些轉接器將完全由其他 crate 所提供，但最终它們將帶入標準函式庫。</p>
<p>最終非同步計算以<strong>任務</strong>的形式執行，相當於輕量級執行緒。 <strong>executor</strong> 提供了從 <code>()</code> 生成的 <code>Future</code> 創建任務的能力。執行器將固定 <code>Future</code> 並對其進行 <code>poll</code>，直到為其創建的任務完成。</p>
<p>executor 的實作以協同式地（cooperative）排程它的任務。是否使用一個或多個作業系統執行緒以及可以在其之上平行生成多少任務取決於 executor 的實作。一些 executor 的實作可能只能驅動單個 <code>Future</code> 完成，而另一些則可以提供動態接受新 <code>Future</code> 的能力，這些 Future 是在任務中被驅動完成。</p>
<p>該 RFC 不包含任何 executor 的定義。它僅以 API 的形式定義了 executors、tasks 和 <code>Future</code> 之間的交互關係，這些 API 允許任務請求再次進行排程。 這些 API 由 <code>task</code> 模組提供，在手動實作 <code>Future</code> 或 executor 時需要這些 API。</p>
<h1 id="技術文件式解說-3"><a class="header" href="#技術文件式解說-3">技術文件式解說</a></h1>
<h2 id="coretask-模組"><a class="header" href="#coretask-模組"><code>core::task</code> 模組</a></h2>
<p>Rust 中非同步運算的基本機制是<strong>任務</strong>，它們是輕量級的執行緒；許多任務可以協同調度到單個作業系統執行緒上。</p>
<p>為了執行這種協作調度，我們使用了一種有時被稱為「<a href="https://en.wikipedia.org/wiki/Trampoline_(computing)">trampoline</a>」的技術。當一個任務需要阻塞等待某個事件時，它會保存一個物件，允許它稍後再次被調度並<strong>返回</strong>到運行它的執行器，然後它可以執行另一個任務。隨後的喚醒將任務放回就緒任務的執行者隊列中，就像作業系統中的執行緒調度程序一樣。</p>
<p>嘗試完成一個任務（或其中的非同步值）稱為<strong>輪詢</strong>，並且總是返回一個 <code>Poll</code> 值：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Indicates whether a value is available, or if the current task has been
/// scheduled for later wake-up instead.
#[derive(Copy, Clone, Debug, PartialEq)]
pub enum Poll&lt;T&gt; {
    /// Represents that a value is immediately ready.
    Ready(T),

    /// Represents that a value is not ready yet.
    ///
    /// When a function returns `Pending`, the function *must* also
    /// ensure that the current task is scheduled to be awoken when
    /// progress can be made.
    Pending,
}
<span class="boring">}</span></code></pre></pre>
<p>當一個任務返回 <code>Poll::Ready</code> 時，執行器知道該任務已經完成並且可以被刪除。</p>
<h3 id="喚醒"><a class="header" href="#喚醒">喚醒</a></h3>
<p>如果 future 在執行期間無法直接完成並返回 <code>Pending</code>，則它需要一種方法來稍後通知執行器它需要再次輪詢以取得進展。</p>
<p>此功能是透過一組 <code>Waker</code> 型別提供的。</p>
<p><code>Waker</code> 是作為參數傳遞給 <code>Future::poll</code> 調用的物件，並且可以透過這些 <code>Futures</code> 的實現來儲存。每當一個 <code>Future</code> 需要再次被輪詢時，它可以使用喚醒器的 <code>wake</code> 方法來通知執行器擁有 <code>Future</code> 的任務應該被再次調度和執行。</p>
<p>RFC 定義了一個具體的 <code>Waker</code> 型別，<code>Futures</code> 和非同步函式的實作者將與之互動。此型別定義了一個 <code>wake(&amp;self)</code> 方法，用於安排與 <code>Waker</code> 關聯的任務再次輪詢。</p>
<p>再次調度任務的機制取決於驅動任務的執行器。喚醒執行器的可能方法包含：</p>
<ul>
<li>如果執行器在條件變數上被阻塞，則需要通知條件變數。</li>
<li>如果執行器在諸如 <code>select</code> 之類的系統調用上被阻塞，它可能需要被諸如 <code>write</code> 管道之類的系統調用喚醒。</li>
<li>如果執行器的執行緒被放置，喚醒呼叫需要將其取消放置。</li>
</ul>
<p>為了讓執行器實現自定義喚醒行為，<code>Waker</code> 型別包含一個稱作 <code>RawWaker</code> 的型別，它由指向自定義可喚醒物件的指針和對其提供 <code>clone</code>、<code>wake</code> 和 <code>drop</code> 函式的虛擬函數指針表 (vtable) 的引用組成底層可喚醒物件。</p>
<p>選擇這種機制有利於特徵物件，因為它允許更靈活的記憶體管理方案。 <code>RawWaker</code> 可以單純根據全域函式和狀態、在引用計數物件之上或以其他方式實現。這種策略還可以更容易地提供不同的 vtable 函式，這些函式將執行不同的行為，儘管引用了相同底層可喚醒的物件型別。</p>
<p>這些 <code>Waker</code> 型別之間的關係在以下定義中進行了概述：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A `RawWaker` allows the implementor of a task executor to create a `Waker`
/// which provides customized wakeup behavior.
///
/// It consists of a data pointer and a virtual function pointer table (vtable) that
/// customizes the behavior of the `RawWaker`.
#[derive(PartialEq)]
pub struct RawWaker {
    /// A data pointer, which can be used to store arbitrary data as required
    /// by the executor. This could be e.g. a type-erased pointer to an `Arc`
    /// that is associated with the task.
    /// The value of this field gets passed to all functions that are part of
    /// the vtable as first parameter.
    pub data: *const (),
    /// Virtual function pointer table that customizes the behavior of this waker.
    pub vtable: &amp;'static RawWakerVTable,
}

/// A virtual function pointer table (vtable) that specifies the behavior
/// of a `RawWaker`.
///
/// The pointer passed to all functions inside the vtable is the `data` pointer
/// from the enclosing `RawWaker` object.
#[derive(PartialEq, Copy, Clone)]
pub struct RawWakerVTable {
    /// This function will be called when the `RawWaker` gets cloned, e.g. when
    /// the `Waker` in which the `RawWaker` is stored gets cloned.
    ///
    /// The implementation of this function must retain all resources that are
    /// required for this additional instance of a `RawWaker` and associated
    /// task. Calling `wake` on the resulting `RawWaker` should result in a wakeup
    /// of the same task that would have been awoken by the original `RawWaker`.
    pub clone: unsafe fn(*const ()) -&gt; RawWaker,

    /// This function will be called when `wake` is called on the `Waker`.
    /// It must wake up the task associated with this `RawWaker`.
    pub wake: unsafe fn(*const ()),

    /// This function gets called when a `RawWaker` gets dropped.
    ///
    /// The implementation of this function must make sure to release any
    /// resources that are associated with this instance of a `RawWaker` and
    /// associated task.
    pub drop_fn: unsafe fn(*const ()),
}

/// A `Waker` is a handle for waking up a task by notifying its executor that it
/// is ready to be run.
///
/// This handle encapsulates a `RawWaker` instance, which defines the
/// executor-specific wakeup behavior.
///
/// Implements `Clone`, `Send`, and `Sync`.
pub struct Waker {
    waker: RawWaker,
}

impl Waker {
    /// Wake up the task associated with this `Waker`.
    pub fn wake(&amp;self) {
        // The actual wakeup call is delegated through a virtual function call
        // to the implementation which is defined by the executor.
        unsafe { (self.waker.vtable.wake)(self.waker.data) }
    }

    /// Returns whether or not this `Waker` and other `Waker` have awaken the same task.
    ///
    /// This function works on a best-effort basis, and may return false even
    /// when the `Waker`s would awaken the same task. However, if this function
    /// returns `true`, it is guaranteed that the `Waker`s will awaken the same task.
    ///
    /// This function is primarily used for optimization purposes.
    pub fn will_wake(&amp;self, other: &amp;Waker) -&gt; bool {
        self.waker == other.waker
    }

    /// Creates a new `Waker` from `RawWaker`.
    ///
    /// The method cannot check whether `RawWaker` fulfills the required API
    /// contract to make it usable for `Waker` and is therefore unsafe.
    pub unsafe fn new_unchecked(waker: RawWaker) -&gt; Waker {
        Waker {
            waker: waker,
        }
    }
}

impl Clone for Waker {
    fn clone(&amp;self) -&gt; Self {
        Waker {
            waker: unsafe { (self.waker.vtable.clone)(self.waker.data) },
        }
    }
}

impl Drop for Waker {
    fn drop(&amp;mut self) {
        unsafe { (self.waker.vtable.drop_fn)(self.waker.data) }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>Waker</code> 必須滿足以下要求：</p>
<ul>
<li>它們必須是可以克隆的。</li>
<li>如果 <code>Waker</code> 的所有實體都已被刪除，並且它們的關聯任務已被驅動完成，則必須釋放為該任務分配的所有資源。</li>
<li>即使關聯的任務已經被驅動完成，在 <code>Waker</code> 上調用 <code>wake()</code> 也必須是安全的。</li>
<li><code>Waker::wake()</code> 必須喚醒執行器，即使它是從任意執行緒調用的。</li>
</ul>
<p>因此，實例化 <code>RawWaker</code> 的執行程器必須確保滿足這些要求。</p>
<h2 id="corefuture-模組"><a class="header" href="#corefuture-模組"><code>core::future</code> 模組</a></h2>
<p>有了上述所有任務的基礎設施，定義 <code>Future</code> 就很簡單了：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Future {
    /// The type of value produced on completion.
    type Output;

    /// Attempt to resolve the future to a final value, registering
    /// the current task for wakeup if the value is not yet available.
    ///
    /// # Return value
    ///
    /// This function returns:
    ///
    /// - [`Poll::Pending`] if the future is not ready yet
    /// - [`Poll::Ready(val)`] with the result `val` of this future if it
    ///   finished successfully.
    ///
    /// Once a future has finished, clients should not `poll` it again.
    ///
    /// When a future is not ready yet, `poll` returns `Poll::Pending` and
    /// stores a clone of the [`Waker`] to be woken once the future can
    /// make progress. For example, a future waiting for a socket to become
    /// readable would call `.clone()` on the [`Waker`] and store it.
    /// When a signal arrives elsewhere indicating that the socket is readable,
    /// `[Waker::wake]` is called and the socket future's task is awoken.
    /// Once a task has been woken up, it should attempt to `poll` the future
    /// again, which may or may not produce a final value.
    ///
    /// Note that on multiple calls to `poll`, only the most recent
    /// [`Waker`] passed to `poll` should be scheduled to receive a
    /// wakeup.
    ///
    /// # Runtime characteristics
    ///
    /// Futures alone are *inert*; they must be *actively* `poll`ed to make
    /// progress, meaning that each time the current task is woken up, it should
    /// actively re-`poll` pending futures that it still has an interest in.
    ///
    /// The `poll` function is not called repeatedly in a tight loop-- instead,
    /// it should only be called when the future indicates that it is ready to
    /// make progress (by calling `wake()`). If you're familiar with the
    /// `poll(2)` or `select(2)` syscalls on Unix it's worth noting that futures
    /// typically do *not* suffer the same problems of &quot;all wakeups must poll
    /// all events&quot;; they are more like `epoll(4)`.
    ///
    /// An implementation of `poll` should strive to return quickly, and must
    /// *never* block. Returning quickly prevents unnecessarily clogging up
    /// threads or event loops. If it is known ahead of time that a call to
    /// `poll` may end up taking awhile, the work should be offloaded to a
    /// thread pool (or something similar) to ensure that `poll` can return
    /// quickly.
    ///
    /// # Panics
    ///
    /// Once a future has completed (returned `Ready` from `poll`),
    /// then any future calls to `poll` may panic, block forever, or otherwise
    /// cause bad behavior. The `Future` trait itself provides no guarantees
    /// about the behavior of `poll` after a future has completed.
    ///
    /// [`Poll::Pending`]: ../task/enum.Poll.html#variant.Pending
    /// [`Poll::Ready(val)`]: ../task/enum.Poll.html#variant.Ready
    /// [`Waker`]: ../task/struct.Waker.html
    /// [`Waker::wake`]: ../task/struct.Waker.html#method.wake
    fn poll(self: Pin&lt;&amp;mut Self&gt;, waker: &amp;Waker) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>這裡的大部分解釋都遵循我們已經說過的關於任務系統的內容。一個轉折是 <code>Pin</code> 的使用，這使得可以在不同的 <code>poll</code> 調用中保留借用資訊（即「borrowing over yield
points」）。固定機制在介紹它的 <a href="https://github.com/rust-lang/rfcs/pull/2349">RFC</a> 和有關最新修訂的<a href="https://boats.gitlab.io/blog/post/rethinking-pin/">部落格文章</a>中進行了解釋。</p>
<h2 id="與-futures-01-的關係"><a class="header" href="#與-futures-01-的關係">與 futures 0.1 的關係</a></h2>
<p>上面歷史背景部分概述的各種討論涵蓋了從 futures 0.1 到這些 API 的演進。但是，簡而言之，有三個主要轉變：</p>
<ul>
<li>
<p>使用 <code>Pin&lt;&amp;mut self&gt;</code> 而不單純是 <code>&amp;mut self</code>，這是支援借用 <code>async</code> 區塊所必需的。 <code>Unpin</code> 標記特徵可用於在手動撰寫 futures 時恢復類似於 futures 0.1 的人因工程和安全性。</p>
</li>
<li>
<p>從 <code>Future</code> 中刪除<strong>內置</strong>錯誤，以支援 <code>Future</code> 在可能失敗時返回 <code>Result</code>。 futures 0.3 crate 提供了一個 <code>TryFuture</code> 特徵，該特徵在 <code>Result</code> 中處理，以便在使用 <code>Result</code>-producer futures 時提供更好的人因工程。刪除錯誤型別已在之前的執行緒中討論過，但最重要的理由是為 <code>async fn</code> 提供一個正交的、組合性的語義，以反映正常的 <code>fn</code>，而不是採用特定的錯誤處理風格。</p>
</li>
<li>
<p>顯式傳遞 <code>Waker</code>，而不是將其儲存在執行緒本地存儲中。自 futures 0.1 發布以來，這一直是一個備受爭議的問題，該 RFC 並不打算重新討論這個問題，但總而言之，主要優點是 (1) 在使用手動 futures（與 <code>async</code> 區塊相反）時，它更容易分辨哪裡需要環境任務，並且 (2) <code>no_std</code> 相容性明顯更好。</p>
</li>
</ul>
<p>為了彌補 futures 0.1 和 0.3 之間的差距，有幾個相容性鋪墊，包括一個內置於 futures crate 本身的，您可以簡單地透過使用 <code>.compat()</code> 組合器在兩者之間切換。這些相容層使現有生態系可以順利地使用新的 futures API，並使大型程式的漸進式轉換成為可能。</p>
<h1 id="原理缺點和替代方案"><a class="header" href="#原理缺點和替代方案">原理、缺點和替代方案</a></h1>
<p>該 RFC 是自 1.0 以來對 <code>std</code> 提出的最重要的補充之一。它讓我們在標準函式庫中包含一個特定的任務和輪詢模型，並將其與 <code>Pin</code> 聯繫起來。</p>
<p>到目前為止，我們已經能夠將「任務/輪詢」模型推向幾乎所有 Rust 希望佔據的利基點，而主要的缺點是缺乏 async/await 語法（以及它<a href="https://aturon.github.io/tech/2018/04/24/async-borrowing/">支援的借用</a>）。</p>
<p>該 RFC 並未嘗試提供對源自 futures crate 任務模型的完整介紹。可以在以下兩篇部落格文章中找到有關設計原理和替代方案的更完整說明：</p>
<ul>
<li><a href="https://aturon.github.io/tech/2016/08/11/futures/">Zero-cost futures in Rust</a></li>
<li><a href="https://aturon.github.io/tech/2016/09/07/futures-design/">Designing futures for Rust</a></li>
</ul>
<p>總而言之，futures 的主要替代模型是 callback-base 的方法，在發現當前方法之前嘗試了 callback-base 幾個月。根據我們的經驗，callback 方法在 Rust 中有幾個缺點：</p>
<ul>
<li>它幾乎在所有地方都強制分配（allocation），因此與 no_std 不相容。</li>
<li>它使取消變得<strong>非常</strong>困難，而對於提議的模型，刪除只是「drop」。</li>
<li>主觀上，組合器程式碼非常繁瑣，而基於任務的模型則可以輕鬆且快速達成。</li>
</ul>
<p>附帶的 <a href="https://github.com/rust-lang/rfcs/pull/2394">RFC</a> 中提供了整個 async/await 專案的一些其他先備知識和基本原理。</p>
<p>在本節的其餘部分，我們將深入探討特定的 API 設計問題，其中該 RFC 與 futures 0.2 不同。</p>
<h2 id="移除內嵌錯誤的基本原理缺點和替代方法"><a class="header" href="#移除內嵌錯誤的基本原理缺點和替代方法">移除內嵌錯誤的基本原理、缺點和替代方法</a></h2>
<p>在主要特徵中移除內嵌（built-in）錯誤型別有多種原因：</p>
<ul>
<li>
<p><strong>改進的型別檢查和推斷</strong>。錯誤型別是當今使用 futures 組合器時最大的痛點之一，無論是試圖讓不同的型別配對，還是在一段程式碼無法產生錯誤時導致推理失敗。更明確地說，當 <code>async</code> 語法可用時，這些問題將不再那麼明顯。</p>
</li>
<li>
<p><strong>非同步函式</strong>。如果我們保留一個內嵌的錯誤型別，那麼 <code>async fn</code> 應該如何工作就不太清楚了：它是否應該總是要求回傳型別是一個 <code>Result</code>？如果不是，當回傳非 <code>Result</code> 型別時會發生什麼？</p>
</li>
<li>
<p><strong>組合器清晰度</strong>。按照組合器依賴錯誤與否來將其拆分，可闡明其語義。尤其對於 stream 來說更是如此，其中錯誤處理是常見的混淆來源。</p>
</li>
<li>
<p><strong><a href="https://en.wikipedia.org/wiki/Orthogonality_(programming)">正交性（orthogonality）</a></strong>。一般來說，產生和處理錯誤與核心輪詢機制是分開的，所以在同等條件的情況下，遵循 Rust 的一般設計原則，藉由<strong>組合</strong> <code>Result</code> 來處理錯誤似乎更好。</p>
</li>
</ul>
<p>綜上所述，即使使用 <code>TryFuture</code>，對大量涉及錯誤處理的程式碼來說，仍有真正的缺點：</p>
<ul>
<li>
<p>需要額外的引入（如果程式碼引入 future prelude，則可以避免，我們也許可以更直接地鼓勵這麼做）。</p>
</li>
<li>
<p>從程式碼角度來說，受一個特徵的<strong>約束</strong>卻<strong>實作</strong>另一個特徵可能會令人困惑。</p>
</li>
</ul>
<p>該 RFC 的錯誤處理部分與其他部分是分開的，因此主要的替代方案是保留內嵌的錯誤型別。</p>
<h2 id="核心特徵設計的基本原理缺點和替代方案-wrt-pin"><a class="header" href="#核心特徵設計的基本原理缺點和替代方案-wrt-pin">核心特徵設計的基本原理、缺點和替代方案 (wrt <code>Pin</code>)</a></h2>
<p>撇開上面討論過的錯誤處理之正交性不談，這個 RFC 中的另一主要項目是核心輪詢方法向 <code>Pin</code> 轉移，以及它與 <code>Unpin</code>/手動撰寫的 futures 之間的關係。在 RFC 討論過程中，我們基本上確定了解決這個問題的三種主要方法：</p>
<ul>
<li>
<p><strong>一個核心特徵</strong>。這就是主要 RFC 文本中採用的方法：只有一個核心 <code>Future</code> 特徵，它適用於 <code>Pin&lt;&amp;mut Self&gt;</code>。另外還有一個 <code>poll_unpin</code> 輔助器，用於在手動實現中使用 <code>Unpin</code> futures。</p>
</li>
<li>
<p><strong>兩個核心特徵</strong>。我們可以提供兩個特徵，例如 <code>MoveFuture</code> 和 <code>Future</code>，其中一個在 <code>&amp;mut self</code> 上運行，另一個在 <code>Pin&lt;&amp;mut Self&gt;</code> 上運行。這使得我們可以繼續以 futures 0.2 的風格編寫程式，即無需引入 <code>Pin</code>/<code>Unpin</code> 或以其他方式談論 pin。一個關鍵要求是需要可交互運作性（interoperation），以便可以在任何需要 <code>Future</code> 的地方使用 <code>MoveFuture</code>。至少有兩種方法可以實現這種互操作：</p>
<ul>
<li>
<p>透過對 <code>T: MoveFuture</code> 的 <code>Future</code> 全面實作（blanket implementation）。這種方法目前阻止了一些<strong>其他</strong>所需的實作（特別圍繞在 <code>Box</code> 和 <code>&amp;mut</code>），但這似乎不是問題的根本。</p>
</li>
<li>
<p>透過子特徵的關係，使得 <code>T: Future</code> 本質上被定義為 <code>for&lt;'a&gt; Pin&lt;&amp;mut 'a T&gt;: MoveFuture</code> 的別名。不幸的是，這種「更高等級」的特徵關係目前在特徵系統中效果不佳，而且這種方法在手動實現 <code>Future</code> 時也使事情變得更加複雜，收益相對較小。</p>
</li>
</ul>
</li>
</ul>
<p>該 RFC 採用的「一個核心特徵」方法的缺點是，它在手動編寫可移動 future 時與人因工程相衝突：您現在需要為您的型別引入 <code>Pin</code> 和 <code>Unpin</code>、調用 <code>poll_unpin</code> 和實現 <code>Unpin</code>。這一切都很機械化，但這是痛苦的。而 <code>Pin</code> 的人因工程學的改進可能會消除其中一些問題，但仍存在許多未解決的問題。</p>
<p>另一方面，雙特徵方法也有缺點。如果我們<strong>還</strong>移除錯誤型別，則會出現組合爆炸，因為我們最終需要每個特徵的 <code>Try</code> 變體（這也延伸到相關的特徵，例如 <code>Stream</code>）。更廣泛地說，使用單一特徵方法，<code>Unpin</code> 充當一種「獨立旋鈕」，可以與其他關注點作正交應用；使用雙特徵方法，它是「混合的」。目前這兩種雙特徵方法都受到了編譯器的限制，儘管這不應該被視為決定因素。</p>
<p><strong>該 RFC 選擇單一特徵方法的主要原因是它是保守的、前向相容（forward-compatible）的選擇，並且已經在實際中證明了自己</strong>。可以在未來的任何時候添加 <code>MoveFuture</code> 以及一個全面實作。因此，從本 RFC 中提出的單一 <code>Future</code> 特徵開始，在我們獲得經驗的同時，我們的選項也保持最大限度的開放。</p>
<h2 id="喚醒設計-waker-的基本原理缺點和替代方案"><a class="header" href="#喚醒設計-waker-的基本原理缺點和替代方案">喚醒設計 (Waker) 的基本原理、缺點和替代方案</a></h2>
<p>該提議的先前疊代包括一個單獨的喚醒型別 <code>LocalWaker</code>，它是 <code>!Send + !Sync</code> 並且可用於實作最佳化的執行器行為，而無需原子引用計數或原子喚醒。然而，實際上，這些相同的最佳化可以使用執行緒本地喚醒佇列（queue）來實作，攜帶 ID 而不是指向喚醒物件的指標，並追蹤執行程序 ID 或執行緒 ID 以執行未發送 <code>Waker</code> 的 runtime 斷言執行緒。舉個簡單的例子，零原子的單執行緒鎖定執行器可以如下實現：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Executor {
    // map from task id (usize) to task
    tasks: Slab&lt;Task&gt;,
    // list of woken tasks to poll
    work_queue: VecDeque&lt;usize&gt;,
}

thread_local! {
  pub static EXECUTOR: RefCell&lt;Option&lt;Executor&gt;&gt; = ...;
}

static VTABLE: &amp;RawWakerVTable = &amp;RawWakerVTable {
    clone: |data: *const ()| RawWaker { data, vtable: VTABLE, },
    wake: |data: *const ()| EXECUTOR.borrow_mut().as_mut().expect(...).work_queue.push(data as usize),
    drop,
};
<span class="boring">}</span></code></pre></pre>
<p>雖然此解決方案向 <code>LocalWaker</code> 方法提供了較差的錯誤訊息（因為在錯誤的執行緒上發生 <code>wake</code> 之前，它不会恐慌，而不是在 <code>LocalWaker</code> 轉換為 <code>Waker</code> 時發生恐慌），它極大地透過去除 <code>LocalWaker</code> 和 <code>Waker</code> 型別的重複，簡化了給使用者的 API 。</p>
<p>在實際情況下，非常可能 Rust 生態系統中最常見的執行器繼續與多執行緒相容（就像現在一樣），因此在更特化的情況，針對這種情況最佳化其人因工程學，優先於更好的錯誤訊息。</p>
<h1 id="現有技術-1"><a class="header" href="#現有技術-1">現有技術</a></h1>
<p>以 async/await 語法和以 future（又名 promise）為基礎的大量現有技術。提議的 futures API 是受到 Scala 的 futures 的影響，並且與各種其他語言的 API 大體相似（就以提供的轉接器而言）。</p>
<p>此 RFC 中模型的獨特之處在於使用了任務，而不是 callback。RFC 的作者不知道其他 <em>future</em> 函式庫是否使用這種技術，但它是 functional programming 中一種相當知名且更普遍的技術。有關於最近的範例，請參閱這篇關於 Haskell 平行的<a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2011/01/monad-par.pdf">論文</a>。這個 RFC 似乎是一个將 「trampoline」 技術與明確的、開放式的任務/喚醒模型结合起来的新想法。</p>
<h1 id="未解決的問題-2"><a class="header" href="#未解決的問題-2">未解決的問題</a></h1>
<p>暫時沒有。</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature Name: sparse_index</li>
<li>Start Date: 2019-10-18</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/2789">rust-lang/rfcs#2789</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/9069">rust-lang/rust#9069</a></li>
<li>Translators: [<a href="https://github.com/weihanglo">@weihanglo</a>]</li>
<li>Commit: <a href="https://github.com/rust-lang/rfcs/blob/3fec7e2e44884cff1a8f6c4a278bd6896ce04227/text/2789-sparse-index.md">The commit link this page based on</a></li>
<li>Updated: 2022-04-02</li>
</ul>
<h1 id="總結-5"><a class="header" href="#總結-5">總結</a></h1>
<p>可透過 HTTP 選擇性下載 crates-io 索引，類於 Ruby 的 Bundler 的作法。傳輸方式從預先（ahead-of-time）Git clone 改變為 HTTP 按需下載。既有的索引結構和內容維持不變。重要的是，此提案可與靜態檔案協同運作，而不需客製化的伺服器端 API。</p>
<h1 id="動機-9"><a class="header" href="#動機-9">動機</a></h1>
<p>完整的 crate 索引相對龐大且下載慢。它還會隨著 crates.io 增長而增長，讓情況每況愈下。需要下載完整索引這件事拖累了首次使用 Cargo 的速度。尤其是在無狀態的 CI 環境下更是緩慢又浪費且只使用完整索引的非常小一部分，剩下全都給拋棄。快取索引在 CI 環境可謂困難重重（<code>.cargo</code> 目錄很巨）又經常低效（如：在 Travis Ci 上傳下載大型快取幾乎和下載新鮮索引一樣慢）。</p>
<p>目前索引的儲存資料格式和 git 協定搭配起來並不是很舒服。未壓縮的索引內容 tarball（截止 eb037b4863）佔 176MiB，<code>gzip -1</code> 需要 16MiB，而 <code>xz -6</code> 壓縮則要 10MiB。然 Git clone 卻回報下載了 215 MiB，比未壓縮的最新索引內容還大，且是壓縮後 tarball 的 <strong>二十倍之多</strong>。</p>
<p>將 git 歷史記錄 shallow clone 或 squash 只是暫時解。且不論事實上 <a href="http://blog.cocoapods.org/Master-Spec-Repo-Rate-Limiting-Post-Mortem/">GitHub 指出它們不想支援大型儲存庫的 shallow clone</a>，也不論 libgit2 尚未支援 shallow clone，實際上這作法仍未解決客戶端必須下載包含所有 crate 的整包索引。</p>
<h1 id="教學式解說-4"><a class="header" href="#教學式解說-4">教學式解說</a></h1>
<p>將索引作為純文字檔案，透過 HTTP 開放出來。開放既有的索引佈局排列也夠用（就像從 raw.githubusercontent.com 看到的長相），不過以 HTTP 來說 URL scheme 可能可以簡化。</p>
<p>欲了解 crate 資訊和解析依賴，Cargo（或其他客戶端）可對每個依賴建立請求，並送往已知的 URL 以取得需要的資訊，例如：<code>https://index.example.com/se/rd/serde</code>。對各個依賴來說，客戶端也會繼續請求其依賴資訊， 遞迴循環，直到取得所有依賴（並快取）到本機端。</p>
<p>請求依賴檔案是有辦法平行化運作的，所以依賴解析最差情況下的延遲會限制在依賴樹的最大深度。實務上最差情況非常少見，因為依賴通常會多次出現在樹中，因此可以提前發現並增加平行化機會。且，若已有 lock 檔案，所有列在其中的依賴也都可平行化核對處理，</p>
<h2 id="離線支援"><a class="header" href="#離線支援">離線支援</a></h2>
<p>此提議的解法完全保留了 Cargo 離線工作的功能。（連線的情況下）欲取得 crate 必然要下載足夠的索引來使用，之後所有資料會快取留作離線使用。</p>
<h2 id="減少頻寬使用"><a class="header" href="#減少頻寬使用">減少頻寬使用</a></h2>
<p>Cargo 支援 HTTP/2，可有效率地處理多個相似的請求。</p>
<p>所有已獲取的依賴檔案可被快取，並透過條件式 HTTP 請求（<code>Etag</code> 或 <code>If-Modified-Since</code> 標頭）來避免重複下載未改變的檔案。</p>
<p>依賴的檔案易於壓縮，目前 <code>rustc-ap-rustc_data_structures</code> 內最大的檔案可用 Brotli 從 1MiB 壓縮到 26KiB。許多伺服器支援透明地提供預壓縮檔案（例如：可從帶有適當內容編碼標頭的 <code>rustc-ap-rustc_data_structures.gz</code> 提供 <code>/rustc-ap-rustc_data_structures</code> 的請求處理），因此索引可以保有高壓縮率但不必花費過多 CPU 以提供這些檔案。</p>
<p>就算是最糟的完整索引一個檔案一個檔案的下載狀況，比起 git clone 仍然使用更少頻寬（所有檔案分別壓縮加起來大小 39MiB）。</p>
<p>提供「增量式變更記錄」檔（在「未來展望」詳述）可以避免過多的條件式請求。</p>
<h2 id="處理移除的-crate"><a class="header" href="#處理移除的-crate">處理移除的 crate</a></h2>
<p>有需要的話，本提議的解法可支援 crate 移除。當客戶端欲檢查一個已移除的 crate 的新鮮度，會向伺服器請求並獲得 404/410/451 HTTP 狀態。客戶端可以根據情況處理，並清理本機端的資料（甚至是 tarball 和原始碼已簽出的情況下）。 </p>
<p>若客戶端對該移除 crate 不感興趣，就不會檢查之，但極大機率從來不會這樣做，也不會下載它。若主動清除已移除的 crate 快取資訊非常重要，則可以延伸「增量式變更記錄」來通知該移除。</p>
<h1 id="缺點-7"><a class="header" href="#缺點-7">缺點</a></h1>
<ul>
<li>crates-io 計畫替索引加上加密簽章，作為 HTTP 上額外一層保護。對 git 索引來說加密驗證非常直觀，不過簽署鬆散的 HTTP 索引可能蠻有挑戰性的。</li>
<li>在還沒有增量式變更記錄前，一個基本的實作，需要許多請求來更新索引。和 git fetch 相比會有更高的延遲。然而，在一些早期的效能比較下，若 CDN 支援足夠（&gt;60）多的平行請求，會比 git fetch 更快。對 Github 上的索引來說，Cargo 有一個捷徑會檢查 master 分支是否改變。若有增量式變更記錄檔，同樣的捷徑可以透過條件式 HTTP 請求該變更記錄檔來達成（例如，檢查 <code>ETag</code> 或 <code>Last-Modified</code>）。</li>
<li>此解法高效與否仰賴於建立多個平行小請求。支援 HTTP/2 的伺服器上做檢查是 HTTP/1.1 的兩倍快，但其實速度超越 HTTP/1.1 很合理。</li>
<li>替代 registry 的功能目前已穩定，代表基於 git 索引協定也穩定且無法移除了。</li>
<li>發送模糊搜尋索引的工具（例如 <code>cargo add</code>）可能需要發送數個請求，或是改用其他方法。URL 已全數正規化到小寫，所以不分大小寫的不需要額外的請求。</li>
</ul>
<h1 id="原理及替代方案-1"><a class="header" href="#原理及替代方案-1">原理及替代方案</a></h1>
<h2 id="查詢-api"><a class="header" href="#查詢-api">查詢 API</a></h2>
<p>顯而易見的替代方案是建立可供查詢依賴解析的伺服器端 API（例如提供依賴清單就回傳一個 lockfile 或類似的東西）。然而，這會需要在伺服器端跑依賴解析。維護這種至關重要的動態 API 給幾乎所有 Rust 使用者每天使用，比其靜態檔案更難花費更高。</p>
<p>本提議之解法並不需要伺服器端任何邏輯。索引可以放在靜態檔案 CDN 上，且非常容易快取或鏡像。不需要修改索引如何取出。標準版本的索引可以繼續以 git 儲存庫形式維持完整的歷史記錄。這能保持與過往 Cargo 版本的相容性，並且第三方工具可以使用當前的索引格式。</p>
<h2 id="從-rustup-提供初始索引"><a class="header" href="#從-rustup-提供初始索引">從 rustup 提供初始索引</a></h2>
<p>Rust／Cargo 的安裝可以打包初始版本的索引，這樣當 Cargo 運作時，就不需要從 git 下載整份索引檔，只需要做與種子版本差異更新。這個索引需要 rustup 更聰明地分別處理，避免在安裝或更新不同版本的 Cargo 時，造成重複下載索引多次。這會讓索引的下載和壓縮更好，讓做法可使目前的實作撐更久，但仍沒辦法解決索引不斷增長的問題。</p>
<p>本提議之解法更是伸縮自如，因為 Cargo 只要下載和快取「需要用到」的索引，未使用／棄用／垃圾 crate 不會造成任何花費。</p>
<h2 id="rsync"><a class="header" href="#rsync">Rsync</a></h2>
<p>rsync 協定需要掃描並校驗原始碼與目標檔案的檢查碼異同，這需要許多不必要的 I/O，且需要 SSH 或在伺服器上運行的客製化系統服務（daemon），這限制了架設索引的選項。</p>
<h1 id="先驅技術-1"><a class="header" href="#先驅技術-1">先驅技術</a></h1>
<p>https://andre.arko.net/2014/03/28/the-new-rubygems-index-format/</p>
<p>Bundler 曾經是預先下載完整索引，和 Cargo 一樣，直到它變得太大太大。然後它改用中心化的查詢 API，直到問題多到難以支援。然後就切換到增量式下載偏平檔案索引格式，和本提議解法相似。</p>
<h1 id="未解決問題-5"><a class="header" href="#未解決問題-5">未解決問題</a></h1>
<ul>
<li>如何設定索引（包含替代 registry）該從 git 或新的 HTTP 下載？目前的語法使用 <code>https://</code> URL 當作 git-over-HTTP。</li>
<li>我們如何確保切換到 HTTP registry 不會導致 lock 檔案出現巨大差異？</li>
<li>如何改寫當前的解析器，開啟平行取得索引檔案的功能？目前所有索引需要同時都可用，這杜絕了平行化的可能性。</li>
</ul>
<h1 id="實作可行性"><a class="header" href="#實作可行性">實作可行性</a></h1>
<p>目前已有一個經過測試的實作，是以簡單「貪婪」演算法來取得索引檔案，在 https://github.com/rust-lang/cargo/pull/8890 ，並且證實了不錯的效能，尤其是全新的建構。該實驗性實作的 PR 建議一個修改解析器的做法，以移除不必要的貪婪取得階段。</p>
<h1 id="未來展望"><a class="header" href="#未來展望">未來展望</a></h1>
<h2 id="增量式的-crate-檔案"><a class="header" href="#增量式的-crate-檔案">增量式的 crate 檔案</a></h2>
<p>Bundler 替每個獨立的依賴檔案使用僅允許附加（append-only）格式，以盡可能只增量下載新版本資訊。Cargo 的格式幾乎就是 append-only（除了 yank），所以如果單一檔案成長到是個問題，應該要版本修復它。然而，當前最大的 crate <code>rustc-ap-rustc_data_structures</code> 天天發佈新版本，每個版本增加 44 位元組（壓縮後），所以就算十年後它也才 190KB（壓縮後），看起來並沒有駭人到需要解決。</p>
<h2 id="增量式變更記錄"><a class="header" href="#增量式變更記錄">增量式變更記錄</a></h2>
<p>截至目前，本方案在每次更新索引時，都必須重驗證每個索引檔案的新鮮度，即使許多檔案根本沒變。執行 <code>cargo update</code> 會導致索引更新，不過也有其他時機會導致更新，例如專案缺少 lockfile，或是添加了新的依賴。雖然 HTTP/2 pipeline 和條件式 GET 請求使得請求多個未改變檔案<a href="https://github.com/rust-lang/cargo/pull/8890#issuecomment-737472043">不錯有效率</a>，但如果我們能避免那些無謂的請求，只請求有更改的檔案會更好。</p>
<p>一個解決方案是提供一個索引的概覽，讓客戶端可以快速確認本機端的索引檔是否過期。為了避免客戶端無謂的請求完整引樹快照，索引可以維護一個僅允許附加（append-only）的變更記錄。當改變發生（crate 版本發佈或 yank），記錄檔會附加新的一條記錄：epoch number（下面解釋之）、最後修改時間戳記、變更的 crate 名稱，未來需要也可添加其他額外資訊。</p>
<p>因為這個記錄檔只允許附加，所以客戶端可以利用 <code>Range</code> HTTP 請求漸增地更新它。客戶端不必下載完整的記錄檔來用，下載從任意一點到檔案結束這段即可，這用 <code>Range</code> 請求來達成簡單易懂。當在記錄裡（從最末端開始）找到一個 crate，並且其更動時間和本機快取一致，如此客戶端就不需要額外對該檔案發送 HTTP 請求。
當記錄檔成長過大，epoch number 遞增，記錄檔就可以重設到空白。即使在客戶端對該新記錄檔的 <code>Range</code> 請求合法的狀況下，epoch number 仍可讓客戶端有辦法偵測記錄檔是否有重設。</p>
<p>最終，這個 RFC 並沒有建議此方案，因為記錄檔恐導致<a href="https://github.com/rust-lang/cargo/commit/bda120ad837e6e71edb334a44e64533119402dee">程式碼變得十分複雜</a>，且<a href="https://github.com/rust-lang/cargo/pull/8890#issuecomment-738316828">比起簡單的下載正面效益不大</a>。若索引快照跟著 registry signing 一起實作了，此 RFC 的實作就可利用該快照機制當作變更記錄。</p>
<h2 id="應付不一致的-http-快取"><a class="header" href="#應付不一致的-http-快取">應付不一致的 HTTP 快取</a></h2>
<p>索引並不需要將所有檔案合併產生一個快照。索引是一次更新一個檔案，並且只需保留部分更新排序。從 Cargo 的角度來看，各個依賴可允許獨立更新。</p>
<p>過期的快取僅在於新版本的 crate 使用了最新版本且剛發佈的依賴時，且該 crate 的快取失效得比其依賴早，才可能產生問題。Cargo 要求依賴需在可見的索引上有充分版本資訊，並且不會發佈任何「毀損」的 crate。</p>
<p>然而，CDN 快取總是有機會過期或失效的順序不一致。若 Cargo 偵測到索引的快取過期了（例如一個 crate 的依賴尚未出現在索引中），它可從該狀況復原，附加「快取破壞者」（如當前時間戳記）在 URL 上，以重新向索引請求檔案。就算 CDN 並不理會請求中的 <code>cache-control: no-cache</code>，這還是可靠能繞過過期快取的方法。</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature Name: <code>llvm_asm</code></li>
<li>Start Date: 2019-12-31</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/2843">rust-lang/rfcs#2843</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/70173">rust-lang/rust#70173</a></li>
<li>Translators: [<a href="https://github.com/TSOTSI1">@TSOTSI1</a>]</li>
<li>Commit: <a href="https://github.com/Amanieu/rfcs/blob/9911615f81471229684b0ab704409c9fcae55ede/text/2843-llvm-asm.md">The commit link this page based on</a></li>
<li>Updated: 2022-06-29</li>
</ul>
<h1 id="總結-6"><a class="header" href="#總結-6">總結</a></h1>
<p>棄用現有的 <code>asm!</code> 巨集（macro），並提供一個名為 <code>llvm_asm!</code> 的相同巨集（macro）。功能開關也從 <code>asm</code> 重新命名為 <code>llvm_asm</code> 。
與 <code>asm!</code> 不同的是， <code>llvm_asm!</code> 不打算成為穩定版。</p>
<h1 id="動機-10"><a class="header" href="#動機-10">動機</a></h1>
<p>這個變更將 <code>asm!</code> 巨集（macro）釋放了，使它可用於內嵌組合語言項目組新設計的 <code>asm!</code> 巨集（macro），
同時為現在使用 <code>asm!</code> 的用戶提供一個簡單的方法來保持代碼的正常運作。</p>
<p>對尚未支援新的 <code>asm!</code> 巨集（macro）的架構，在（nightly 版本）上執行內嵌組合語言可能會有用。</p>
<h1 id="教學式解說-5"><a class="header" href="#教學式解說-5">教學式解說</a></h1>
<p>Rust 團隊目前正在重新設計 <code>asm!</code> 巨集（macro）。您應該將所有使用 <code>asm!</code> 的代碼都替換為 <code>llvm_asm!</code> ，以避免代碼在實施新的 <code>asm!</code> 巨集（macro）時毀壞。</p>
<h1 id="技術文件式解說-4"><a class="header" href="#技術文件式解說-4">技術文件式解說</a></h1>
<p>編譯器內所有對 <code>asm!</code> 的參考都將改參考 <code>llvm_asm!</code> 。
<code>asm!</code> 將變成一個單純（已棄用）的 <code>macro_rules!</code> ，它會重新導到<code>llvm_asm!</code>。
棄用警告將告知使用者 <code>asm!</code> 將來的語義會作改變，並邀請他們使用 <code>llvm_asm!</code> 來替代。<code>llvm_asm!</code> 巨集（macro）將由 <code>llvm_asm</code> 功能開關來把控。</p>
<h1 id="缺點-8"><a class="header" href="#缺點-8">缺點</a></h1>
<p>此變更可能需要人為變更兩次代碼：首先變更為 <code>llvm_asm!</code> ，然後再實施新的 <code>asm!</code> 巨集（macro）。</p>
<h1 id="原理及替代方案-2"><a class="header" href="#原理及替代方案-2">原理及替代方案</a></h1>
<p>我們可以跳過棄用期，並同時執行重新命名新的 <code>asm!</code> 巨集（macro）。
總之用 Rust（nightly 版本）保證能一次破壞大量代碼，就無需任何過渡期。</p>
<h1 id="先驅技術-2"><a class="header" href="#先驅技術-2">先驅技術</a></h1>
<p>D 語言也支援兩種形式的內嵌組合語言。<a href="https://dlang.org/spec/iasm.html">first one</a> 提供用於內嵌組合語言的嵌入式 DSL，它可以在不用 Clobber 情況下直接存取範圍內的變量，但只能在x86和x86_64的架構上使用。
<a href="https://wiki.dlang.org/LDC_inline_assembly_expressions">second one</a> 是 LLVM 內部內嵌組合語言句法的 RAM 接口，但它只適用於 DSL 的後端架構。</p>
<h1 id="未解決問題-6"><a class="header" href="#未解決問題-6">未解決問題</a></h1>
<p>無</p>
<h1 id="未來展望-1"><a class="header" href="#未來展望-1">未來展望</a></h1>
<p>當下執行的會在 <a href="https://github.com/rust-lang/rfcs/pull/2873">new <code>asm!</code> macro</a> 被執行後替換掉，這會破壞那些尚未轉換 <code>llvm_asm!</code> 的代碼。
由於運算元分隔符將從 <code>:</code> 更改為 <code>,</code> ，所以不會有靜默的錯誤編譯，新的 <code>asm!</code> 巨集（macro）會出現語法錯誤，來保證現有 <code>asm!</code> 的任何呼叫都會失敗，</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature Name: <code>io_safety</code></li>
<li>Start Date: 2021-05-24</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/3128">rust-lang/rfcs#3128</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/87074">rust-lang/rust#87074</a></li>
<li>Translators: [<a href="https://github.com/weihanglo">@weihanglo</a>]</li>
<li>Commit: <a href="https://github.com/rust-lang/rfcs/blob/88b30e7a0b7ac5b0f52370a58b70c165a9a252af/text/3128-io-safety.md">The commit link this page based on</a></li>
<li>Updated: 2021-08-2o</li>
</ul>
<h1 id="總結-7"><a class="header" href="#總結-7">總結</a></h1>
<p>透過引進<strong>輸入輸出安全性</strong>（I/O safety）之概念與一系列新型別與特徵，保障 <code>AsRaw</code> 及相關特徵的使用者對原始資源 handle （raw resource handle）之使用，以彌補 Rust 封裝邊界的漏洞。</p>
<h1 id="動機-11"><a class="header" href="#動機-11">動機</a></h1>
<p>Rust 標準函式庫幾乎算是已經提供了<strong>輸入輸出安全性</strong>，保證程式的一部分若私自持有一個原始 handle （raw handle），其他部分就無法存取。例如 <a href="https://doc.rust-lang.org/stable/std/os/unix/io/trait.FromRawFd.html#tymethod.from_raw_fd"><code>FromRawFd::from_raw_fd</code></a> 標示為不安全，它不允許使用者在 safe Rust 之下執行如 <code>File::from_raw_fd(7)</code> 等操作，或是在程式各處私自持有檔案描述子（file descriptor）來執行輸入輸出。</p>
<p>不過仍有漏網之魚。許多函式庫的 API 透過接受 <a href="https://doc.rust-lang.org/stable/std/os/unix/io/trait.AsRawFd.html"><code>AsRawFd</code></a>/<a href="https://doc.rust-lang.org/stable/std/os/unix/io/trait.IntoRawFd.html"><code>IntoRawFd</code></a> 來執行輸入輸出操作：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn do_some_io&lt;FD: AsRawFd&gt;(input: &amp;FD) -&gt; io::Result&lt;()&gt; {
    some_syscall(input.as_raw_fd())
}
<span class="boring">}</span></code></pre></pre>
<p><code>AsRawFd</code> 並無限制 <code>as_raw_fd</code> 的回傳值，所以 <code>do_some_io</code> 最終會對任意 <code>RawRd</code> 的值執行輸入輸出。由於 <a href="https://doc.rust-lang.org/stable/std/os/unix/io/type.RawFd.html"><code>RawFd</code></a> 本身實作了 <code>AsRawFd</code>，甚至可以寫出 <code>do_some_io(&amp;7)</code>。</p>
<p>這會使得程式<a href="https://cwe.mitre.org/data/definitions/910.html">存取錯誤的資源</a>，更甚者為其他地方私有的原始 handle 建立多個別名（alias），從而打破封裝的邊界，造成<a href="https://en.wikipedia.org/wiki/Action_at_a_distance_(computer_programming)">遠處來的詭異行為</a>。</p>
<p>而在特殊情況下，違反輸入輸出安全性恐導致違反記憶體安全性。舉例來說，理論上替透過 Linux <a href="https://man7.org/linux/man-pages/man2/memfd_create.2.html"><code>memfd_create</code></a> 系統呼叫建立出來的檔案描述子打造  <code>mmap</code> 的安全封裝，並將之傳給 safe Rust 是可行的，畢竟它就是匿名的被開啟的檔案（anonymous open file），表示其他行程（process）無法存取之。然而，在沒有輸入輸出安全性且沒有永久封閉該檔案的情況下，該程式中其他程式碼恐意外地對該檔案描述子呼叫 <code>write</code> 或 <code>ftruncate</code>，進而打破記憶體安全性 <code>&amp;[u8]</code> 不變的規則。</p>
<p>這個 RFC 透過以下幾點，開闢一條逐步關閉此漏洞的道路：</p>
<ul>
<li>一個新概念：輸入輸出安全性。其概念會撰寫在標準函式庫文件中。</li>
<li>一系列全新的型別與特徵。</li>
<li>替 <a href="https://doc.rust-lang.org/stable/std/os/unix/io/trait.FromRawFd.html#tymethod.from_raw_fd"><code>from_raw_fd</code></a>/<a href="https://doc.rust-lang.org/stable/std/os/windows/io/trait.FromRawHandle.html#tymethod.from_raw_handle"><code>from_raw_handle</code></a>/<a href="https://doc.rust-lang.org/stable/std/os/windows/io/trait.FromRawSocket.html#tymethod.from_raw_socket"><code>from_raw_socket</code></a> 撰寫新文件，解釋就輸入輸出安全性而言，它們為何不安全，順便解決出現好<a href="https://github.com/rust-lang/rust/issues/72175">幾</a><a href="https://users.rust-lang.org/t/why-is-fromrawfd-unsafe/39670">次</a>的相同問題。</li>
</ul>
<h1 id="教學式解說-6"><a class="header" href="#教學式解說-6">教學式解說</a></h1>
<h2 id="輸入輸出安全性概念"><a class="header" href="#輸入輸出安全性概念">輸入輸出安全性概念</a></h2>
<p>Rust 標準函式庫提供了低階型別，以表示原始的作業系統資源 handle：類 Unix 平台的 <a href="https://doc.rust-lang.org/stable/std/os/unix/io/type.RawFd.html"><code>RawFd</code></a> 和 Windows 上的 <a href="https://doc.rust-lang.org/stable/std/os/windows/io/type.RawHandle.html"><code>RawHandle</code></a> 與 <a href="https://doc.rust-lang.org/stable/std/os/windows/io/type.RawSocket.html"><code>RawSocket</code></a>。然而，它們並沒有提供任何自身的行為，而是僅作為一個標識符（identifier），並在低階的作業系統 API 間傳遞。</p>
<p>這些原始 handle 可以視為原始指標（raw pointer）且具有相同的危險性。雖然<strong>取得</strong>一個原始指標是安全的，但當該原始指標是非法指標，或是比其指向記憶體之處活得更久時，對原始指標<strong>取值</strong>（dereference）都可能引發未定義行為（undefined behavior）。無獨有偶，透過 <a href="https://doc.rust-lang.org/stable/std/os/unix/io/trait.AsRawFd.html#tymethod.as_raw_fd"><code>AsRawFd::as_raw_fd</code></a> 或類似方法<strong>取得</strong>一個原始 handle 是安全的，但當它並非合法 handle 或在關閉之後才拿來用時，用該 handle 來執行輸入輸出恐導致「損毀的輸出結果」、「遺失或洩漏輸入資料」或「違反封裝的邊界」。在這兩個案例中，影響不僅限於本地，也會影響程式的其他部分。保護原始指標免於危險稱作記憶體安全性，所以保護原始 handle 免於危險我們叫它<strong>輸入輸出安全性</strong>。</p>
<p>Rust 標準函式庫也有高階型別如 <a href="https://doc.rust-lang.org/stable/std/fs/struct.File.html"><code>File</code></a> 和 <a href="https://doc.rust-lang.org/stable/std/net/struct.TcpStream.html"><code>TcpStream</code></a> 來提供高階的作業系統 API 界面，這些型別包裝了原始 handle。</p>
<p>這些高階型別同時實作了在類 Unix 平台的 <a href="https://doc.rust-lang.org/stable/std/os/unix/io/trait.FromRawFd.html"><code>FromRawFd</code></a> 特徵，以及 Windows 上的 <a href="https://doc.rust-lang.org/stable/std/os/windows/io/trait.FromRawHandle.html"><code>FromRawHandle</code></a>/<a href="https://doc.rust-lang.org/stable/std/os/windows/io/trait.FromRawSocket.html"><code>FromRawSocket</code></a> 。這些特徵提供許多函式將底層的值封裝產生出高階的值。由於這些函式無法確保輸入輸出的安全性，因此標示為不安全。型別系統並不會限制這些型別傳入：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use std::fs::File;
    use std::os::unix::io::FromRawFd;

    // 建立一個檔案。
    let file = File::open(&quot;data.txt&quot;)?;

    // 從任意整數值構建一個 `File`，這個型別能通過檢查，但 7 可能在執行期間無法
    // 被識別為任何活生生的資源，或它可能不慎指向程式其他地方封裝好的原始 handle
    // 一個 `unsafe` 區塊告知呼叫者對此有責任，需使其免於這些風險。
    let forged = unsafe { File::from_raw_fd(7) };

    // 取得一個 `file` 內部的原始 handle 的副本。
    let raw_fd = file.as_raw_fd();

    // 關閉 `file`。
    drop(file);

    // 開啟一些無關的檔案。
    let another = File::open(&quot;another.txt&quot;)?;

    // 其他對 `raw_fd`（也就是 `file` 內部的原始 handle）的使用有可能使其生命週
    // 期長於與作業系統的關聯。這恐導致意外建立別名指向其他封裝起來的 `File`
    // 實例，例如 `another`。因此，一個 `unsafe` 區塊告知呼叫者對此有責任，需使
    // 其免於這些風險。
    let dangling = unsafe { File::from_raw_fd(raw_fd) };
<span class="boring">}</span></code></pre></pre>
<p>呼叫端必須確保傳入 <code>from_raw_fd</code> 的值一定是從作業系統回傳所得，並且 <code>from_raw_fd</code> 的回傳值的生命週期不會長於和作業系統關聯的 handle。</p>
<p>雖然將輸入輸出安全性作為明確的概念是個新作法，但其實它也反映出許多常見的實踐。除了引入一些新型別與特徵及其實作外，Rust <code>std</code> 並不需改變已經穩定的界面。在推行之初，並不需讓整個 Rust 生態系馬上支援輸入輸出安全性，而是可以漸進式地採用之。</p>
<h2 id="ownedfd-與-borrowedfdfd"><a class="header" href="#ownedfd-與-borrowedfdfd"><code>OwnedFd</code> 與 <code>BorrowedFd&lt;'fd&gt;</code></a></h2>
<p>這兩個型別概念上將取代 <code>RawFd</code>，並分別表示擁有和借用的 handle 值。<code>OwnedFd</code> 擁有一個檔案描述子，當 <code>OwnedFd</code> 釋放時就會關閉其檔案描述子。<code>BorrowedFd</code> 的生命週期標示該檔案描述子被借用多久。這些型別皆會自動實施其輸入輸出安全性不變的規則。</p>
<p>至於在 Windows 上，會以 <code>Handle</code> 和 <code>Socket</code> 形式呈現相應的型別。</p>
<p>這些型別在輸入輸出扮演的角色可類比 Rust 既有的記憶體管理相關型別：</p>
<div class="table-wrapper"><table><thead><tr><th>型別</th><th>類似於</th></tr></thead><tbody>
<tr><td><code>OwnedFd</code></td><td><code>Box&lt;_&gt;</code></td></tr>
<tr><td><code>BorrowedFd&lt;'a&gt;</code></td><td><code>&amp;'a _</code></td></tr>
<tr><td><code>RawFd</code></td><td><code>*const _</code></td></tr>
</tbody></table>
</div>
<p>不過兩者還是有差，輸入輸出安全性並不區分可不可變。在 Rust 的掌控之外，作業系統資源能以各種形式共享，所以輸入輸出可以視為使用了<a href="https://doc.rust-lang.org/reference/interior-mutability.html">內部可變性</a>。</p>
<h2 id="asfdintoownedfd-與-fromownedfd"><a class="header" href="#asfdintoownedfd-與-fromownedfd"><code>AsFd</code>、<code>Into&lt;OwnedFd&gt;</code> 與 <code>From&lt;OwnedFd&gt;</code></a></h2>
<p>這三個型別概念上，在大多數用例中分別取代 <code>AsRawFd::as_raw_fd</code>、<code>IntoRawFd::into_raw_fd</code>，以及 <code>FromRawFd::from_raw_fd</code>。它們依據 <code>OwnedFd</code> 及 <code>BorrowedFd</code> 來運作，所以也會自動實施其輸入輸出安全性不變的規則。</p>
<p>使用這些型別後，就能避免在<a href="3128-io-safety.html#%E5%8B%95%E6%A9%9F">動機</a>一節的 <code>do_some_io</code> 範例中提及的問題。由於只有合理擁有或借用檔案描述子的型別能實作 <code>AsFd</code>，所以這個版本的 <code>do_some_io</code> 不需要擔心偽造或迷途（dangling）的檔案描述子傳入。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn do_some_io&lt;FD: AsFd&gt;(input: &amp;FD) -&gt; io::Result&lt;()&gt; {
    some_syscall(input.as_fd())
}
<span class="boring">}</span></code></pre></pre>
<p>至於在 Windows 上，會以 <code>Handle</code> 和 <code>Socket</code> 形式呈現相應的型別。</p>
<h2 id="漸進式採用"><a class="header" href="#漸進式採用">漸進式採用</a></h2>
<p>輸入輸出安全性及其新型別與新特徵並不需要一次性全面導入，而是能夠分階段漸進採用：</p>
<ul>
<li>首先，在 <code>std</code> 新增這些新型別與新特徵，並替相關的型別實作之。這是向下相容的改變。</li>
<li>在此之後，crate 可以開始用這些新型別，並替 crate 自己的型別實作這些新特徵。這些改變相對小，而且符合語意化版號相容性，不需其他特殊處理。</li>
<li>當標準函式庫和夠多的熱門 crate 實作這些新特徵後，其他 crate 可按照它們的開發步調，將這些新特徵作為泛型引數的限定條件（bound)。雖然這些改變不符合語意化版號的相容性，不過多數 API 使用者改用新特徵時並不需改變程式碼。</li>
</ul>
<h1 id="技術文件式解說-5"><a class="header" href="#技術文件式解說-5">技術文件式解說</a></h1>
<h2 id="輸入輸出安全性概念-1"><a class="header" href="#輸入輸出安全性概念-1">輸入輸出安全性概念</a></h2>
<p>Rust 語言除了有記憶體安全性之外，Rust 標準函式庫同時提供了對輸入輸出安全性的保證。一個合法的輸入輸出操作，其所操作的原始 handle（<a href="https://doc.rust-lang.org/stable/std/os/unix/io/type.RawFd.html"><code>RawFd</code></a>、 <a href="https://doc.rust-lang.org/stable/std/os/windows/io/type.RawHandle.html"><code>RawHandle</code></a>、<a href="https://doc.rust-lang.org/stable/std/os/windows/io/type.RawSocket.html"><code>RawSocket</code></a>）必為明確從作業系統回傳之值，且這些操作僅發生在與作業系統關聯之生命週期內。當一段 Rust 程式碼宣稱輸入輸出安全性，代表該程式碼不可能導致非法的輸入輸出操作。</p>
<p>雖然有些作業系統的文件中說明其檔案描述子的配置演算法，但從這些演算法旁敲側擊出來的 handle 值並不會視為「明確從作業系統回傳之值」。</p>
<p>對接受任意原始輸入輸出 handle 值（<a href="https://doc.rust-lang.org/stable/std/os/unix/io/type.RawFd.html"><code>RawFd</code></a>、<a href="https://doc.rust-lang.org/stable/std/os/windows/io/type.RawHandle.html"><code>RawHandle</code></a>、<a href="https://doc.rust-lang.org/stable/std/os/windows/io/type.RawSocket.html"><code>RawSocket</code></a>）的函式，若安全的 API 會藉由這些 handle 執行輸入輸出，應標示為 <code>unsafe</code>。</p>
<h2 id="ownedfd-與-borrowedfdfd-1"><a class="header" href="#ownedfd-與-borrowedfdfd-1"><code>OwnedFd</code> 與 <code>BorrowedFd&lt;'fd&gt;</code></a></h2>
<p><code>OwnedFd</code> 與 <code>BorrowedFd</code> 皆為 <code>repr(transparent)</code>，並帶有一個 <code>RawFd</code> 值，且兩者皆可應用區位最佳化（niche optimizations），所以和 <code>Option&lt;OwnedFd&gt;</code> 與 <code>Option&lt;BorrowedFd&lt;'_&gt;&gt;</code> 的大小相同，而且可在 FFI 宣告的函式中使用，例如 <code>open</code>, <code>read</code>, <code>write</code>, <code>close</code> 等。若以上述方法使用之，它們將確保 FFI 邊界的輸入輸出安全性。</p>
<p>這些型別同時會實作既有的 <code>AsRawFd</code>、<code>IntoRawFd</code>，以及 <code>FromRawFd</code> 特徵，所以它們可和既有程式碼的 <code>RawFd</code> 型別交互使用。</p>
<h2 id="asfdintoownedfd-與-fromownedfd-1"><a class="header" href="#asfdintoownedfd-與-fromownedfd-1"><code>AsFd</code>、<code>Into&lt;OwnedFd&gt;</code> 與 <code>From&lt;OwnedFd&gt;</code></a></h2>
<p>這些型別提供 <code>as_fd</code>、<code>into</code> 與 <code>from</code> 函式，類似於 <code>AsRawFd::as_raw_fd</code>、<code>IntoRawFd::into_raw_fd</code> 與 <code>FromRawFd::from_raw_fd</code>。</p>
<h2 id="原型實作"><a class="header" href="#原型實作">原型實作</a></h2>
<p>上述所有原型放在：</p>
<p><a href="https://github.com/sunfishcode/io-lifetimes">https://github.com/sunfishcode/io-lifetimes</a></p>
<p>README.md 有文件鏈結、範例、和當前提供類似功能的 crate 之調查研究。</p>
<h1 id="缺點-9"><a class="header" href="#缺點-9">缺點</a></h1>
<p>Crate 若用到檔案描述子，如 <a href="https://crates.io/crates/nix"><code>nix</code></a> 或 <a href="https://crates.io/crates/mio"><code>mio</code></a>，將需要遷移到有實作 <code>AsFd</code> 的型別，或將這類函式標示為不安全。</p>
<p>crates 若用 <code>AsRawFd</code> 或 <code>IntoRawFd</code> 來接收任何「類檔案」或「類 socket」型別，如 <a href="https://crates.io/crates/socket2"><code>socket2</code></a> 的 <a href="https://docs.rs/socket2/0.4.0/socket2/struct.SockRef.html#method.from"><code>SockRef::from</code></a>，將需換成 <code>AsFd</code> 或 <code>Into&lt;OwnedFd&gt;</code>，或將這類函式標示為不安全。</p>
<h1 id="原理及替代方案-3"><a class="header" href="#原理及替代方案-3">原理及替代方案</a></h1>
<h2 id="有關unsafe-僅為了記憶體安全性"><a class="header" href="#有關unsafe-僅為了記憶體安全性">有關「unsafe 僅為了記憶體安全性」</a></h2>
<p>Rust 有個慣例：<code>unsafe</code> 只適用於標示記憶體安全性。舉個有名的案例， <a href="https://doc.rust-lang.org/std/mem/fn.forget.html"><code>std::mem::forget</code></a> 曾標示為不安全，但後來<a href="https://rust-lang.github.io/rfcs/1066-safe-mem-forget.html">被改為安全</a>，且其結論指出 unsafe 僅該用作標示記憶體安全性，而不該用來標示可能作繭自縛的情況或恫嚇應避免使用的 API 上。</p>
<p>記憶體安全性造成的危害比其他程式設計面向更甚，它不僅要避免意外行為發生，且仍需避免無法限制一段程式碼能做什麼。</p>
<p>輸入輸出安全性也落在這個範疇，有兩個因素：</p>
<ul>
<li>（若作業系統存在 <code>mmap</code> 相關 API）在安全封裝的 <code>mmap</code> 中，輸入輸出安全性的錯誤仍會導致記憶體安全性的錯誤。</li>
<li>輸入輸出安全性之錯誤也意味著一段程式碼可以在沒有通知或被授予任何引用的情形下，讀寫或刪除程式其他部分正在使用的資料。這使得在無法通曉一個 crate 鏈結到的其他 crate 的所有實作細節下，非常難以限制這個 crate 可以做什麼。</li>
</ul>
<p>原始 handle 更像指向單獨的位址空間（address space）的原始指標，它們可能迷途（dangle）或造假。輸入輸出安全性近似於記憶體安全性，兩者皆竭力杜絕遠處來的詭異行為（spooky-action-at-a-distance），且對兩者來說，所有權都可作為建立穩健抽象化的主要根基，所以自然而然共用了相似的安全性概念。</p>
<h2 id="將輸入輸出-handle-當作純資料"><a class="header" href="#將輸入輸出-handle-當作純資料">將輸入輸出 Handle 當作純資料</a></h2>
<p>主要的替代方案的說法是原始 handle 為純資料（plain data），並沒有輸入輸出安全性，和作業系統資源的生命週期也無任何與生俱來的關係。至少在類 Unix 平台，這些永遠不會導致記憶體不安全或是未定義行為。</p>
<p>不過，大部分的 Rust 程式碼不直接與原始 handle 互動。撇開本 RFC 不談，不與原始 handle 互動是件好事。所謂資源，一定會有生命週期，若大部分的 Rust 程式碼能使用各方面都更易上手又能自動管理生命週期的更高階的型別，這樣鐵定更棒。不過，純資料的方案對於相對不常見的案例，最多只能讓原始 handle 的操作容易撰寫些。這可能只是蠅頭小利，甚至可能是個缺點，有可能最後變相鼓勵大家在不需要時去用了原始 handle 。</p>
<p>純資料的方案亦不需要變更任何 crate 的程式碼。而輸入輸出安全性的方案則需改動如 <a href="https://crates.io/crates/socket2"><code>socket2</code></a>、<a href="https://crates.io/crates/nix"><code>nix</code></a> 和 <a href="https://crates.io/crates/mio"><code>mio</code></a> 這些用到 <a href="https://doc.rust-lang.org/stable/std/os/unix/io/trait.AsRawFd.html"><code>AsRawFd</code></a> 和 <a href="https://doc.rust-lang.org/stable/std/os/unix/io/type.RawFd.html"><code>RawFd</code></a> 的 crate，不過這改動可以漸進推廣到整個生態系，而不必一次性完成。</p>
<h2 id="iosafe-特徵與它的前身-ownsraw"><a class="header" href="#iosafe-特徵與它的前身-ownsraw"><code>IoSafe</code> 特徵（與它的前身 <code>OwnsRaw</code>）</a></h2>
<p>這個 RFC 在早先幾個版本提議過一個 <code>IoSafe</code> 特徵，這個特徵會帶來小程度但具侵入性的修復。來自該 RFC 的回饋促使一系列新型別與特徵的開發。這個開發牽扯更廣的 API 範圍，也意味著需要更多設計和審核。並且隨著時間推移，整個 crate 生態系需要更大規模的改動。然而，早期跡象指出，本 RFC 引入的新型別與特徵更易理解，使用上更順手且安全，所以長期來說有更穩健的基礎。</p>
<p><code>IoSafe</code> 早期叫做 <code>OwnsRaw</code>。我們很難替這個特徵找到恰到好處的名字，這也許是個訊號，表示它並非良好設計的特徵。</p>
<h1 id="先驅技術-3"><a class="header" href="#先驅技術-3">先驅技術</a></h1>
<p>大部分記憶體安全的程式語言都對原始 handle 做了安全的抽象層。多數情況下，它們僅是簡單地避免暴露原始 handle，例如 <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.file?view=net-5.0">C#</a>、<a href="https://docs.oracle.com/javase/7/docs/api/java/io/File.html?is-external=true">Java</a> 等。若將透過原始 handle 執行輸入輸出標示為不安全，可讓 safe Rust 與這些程式語言達到相同程度的安全保證。</p>
<p>在 crates.io 上有好幾個 crate 封裝了擁有或借用的檔案描述子。<a href="https://github.com/sunfishcode/io-lifetimes#prior-art">io-lifetimes 的 README.md 中 Prior Art 一節</a>詳細描述了其與其他既有 crate 的同異。從高層次角度來看，既有的 crate 都與 io-lifetimes 共享相同的基本概念。這些 crate 都圍繞著 Rust 生命週期與所有權概念打造，而這恰恰說明這些概念非常適合這個問題。</p>
<p>Android 有特殊的 API 會偵測不恰當的 <code>close</code>，詳見 <a href="https://github.com/rust-lang/rust/pull/74680">rust-lang/rust#74860</a>。這些 API 的動機就是一種輸入輸出安全性的應用。Android 的特殊 API 用了動態檢查，讓它們可以在跨來源語言的邊界實施這些規則。本 RFC 提議的輸入輸出安全性的型別和特徵只專注在 Rust 程式碼本身實施這些規則，所以它們可在編譯期間利用 Rust 的型別系統實施這些規則，而非延遲到執行期間。</p>
<h1 id="未解決問題-7"><a class="header" href="#未解決問題-7">未解決問題</a></h1>
<h2 id="形式化所有權"><a class="header" href="#形式化所有權">形式化所有權</a></h2>
<p>此 RFC 並沒有為原始 handle 的所有權和生命週期定義一個形式化模型（formal model）。這 RFC 對原始 handle 規範之定位尚不明朗。當 handle 只是整數型別時，與其關聯資源之生命週期意義為何？所有具有相同值的整數型別會共享該關連嗎？</p>
<p>Rust <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">參考手冊</a>根據 <a href="http://llvm.org/docs/LangRef.html#pointer-aliasing-rules">LLVM 的指標別名規則</a>定義了記憶體的未定義行為；輸入輸出可能需要類似的 handle 別名規則。這對目前的實際需求而言似非必要，但未來可對此進行探索。</p>
<h1 id="未來展望-2"><a class="header" href="#未來展望-2">未來展望</a></h1>
<p>以下包含一些從此 RFC 延伸的可能想法：</p>
<ul>
<li>
<p>Clippy 警吿常見的輸入輸出不安全狀況。</p>
</li>
<li>
<p>一個原始 handle 所有權形式化模型。可想像為延伸 Miri 使其揪出「關閉後使用」和「使用偽造的 handle」這類錯誤。</p>
</li>
<li>
<p>一個屬於 Rust，細緻且基於能力的安全模型（capabability-based security model）。藉由此模型提供的保證，在 safe Rust 語境下就不可能偽造出假的原始 handle 高階封裝。</p>
</li>
<li>
<p>還可替有實作 <code>AsFd</code>、<code>Into&lt;OwnedFd&gt;</code> 或 <code>From&lt;OwnedFd&gt;</code> 的型別添加一些方便的功能：</p>
<ul>
<li><code>from_into_fd</code> 函式：取得 <code>Into&lt;OwnedFd&gt;</code> 並將之轉為 <code>From&lt;OwnedFd&gt;</code>，讓使用者一步執行這些常見的轉換步驟。</li>
<li><code>as_filelike_view::&lt;T&gt;()</code> 函式：回傳一個 <code>View</code>，其中包含內部檔案描述子構建出來的暫時實例 T，讓使用者能以 <code>File</code> 或 <code>TcpStream</code> 等方式查看原始的檔案描述子。</li>
</ul>
</li>
<li>
<p>簡單使用情景的可攜性。由於 Windows 有兩種不同的 handle 型別，但 Unix 只有一種，因此在這領域中達成可攜性並非易事。然而，在部分案例中，可將 <code>AsFd</code> 和 <code>AsHandle</code> 一視同仁，而另外一些情況則可以把 <code>AsFd</code> 和 <code>AsSocket</code> 當作相同的。在這兩類情形，普通的 <code>FileLike</code> 和 <code>SocketLike</code> 抽象化能讓程式碼泛用在 Unix 和 Windows 上。</p>
<p>類似的可攜性也能推廣到 <code>From&lt;OwnedFd&gt;</code> 及 <code>Into&lt;OwnedFd&gt;</code>。</p>
</li>
</ul>
<h1 id="致謝"><a class="header" href="#致謝">致謝</a></h1>
<p>感謝 Ralf Jung (<a href="https://github.com/RalfJung">@RalfJung</a>) 引導我理解這個主題至此，鼓勵我和審核這個 RFC 的草案，並耐心回答我諸多問題！</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature Name: scoped_threads</li>
<li>Start Date: 2019-02-26</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/3151">rust-lang/rfcs#3151</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/93203">rust-lang/rust#93203</a></li>
<li>Translators: [<a href="https://github.com/FizzyElt">@FizzyElt</a>]</li>
<li>Commit: <a href="https://github.com/rust-lang/rfcs/blob/6de9eb35193852dd910c38f5c2c41e6f3e2a8ed4/text/3151-scoped-threads.md">The commit link this page based on</a></li>
<li>Updated: 2022-07-05</li>
</ul>
<h1 id="概要-4"><a class="header" href="#概要-4">概要</a></h1>
<p>在標準函式庫中新增作用域執行緒，其允許產生可借用父執行緒之變數的執行緒。</p>
<p>範例:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let var = String::from(&quot;foo&quot;);

thread::scope(|s| {
    s.spawn(|_| println!(&quot;borrowed from thread #1: {}&quot;, var));
    s.spawn(|_| println!(&quot;borrowed from thread #2: {}&quot;, var));
});
<span class="boring">}</span></code></pre></pre>
<h1 id="動機-12"><a class="header" href="#動機-12">動機</a></h1>
<p>在 Rust 1.0 發布之前，我們有與作用域執行續相同作用的 <a href="https://docs.rs/thread-scoped/1.0.2/thread_scoped/"><code>thread::scoped()</code></a>，但後來發現一個健全性的問題，可能導致 use-after-frees，所以它已被移除。這一歷史事件稱為<a href="http://cglab.ca/~abeinges/blah/everyone-poops/">洩密事件</a>。</p>
<p>幸運的是，舊的作用域執行緒可被修復，透過閉包（closure）而非守護（guard)，來確保生成的執行緒會自動會合（join）。但我們對在 Rust 1.0 中加入的作用域執行緒並不放心，所以我們決定將其放在外部 crates 之中，並有可能在未來的某個時刻回到標準函式庫中。四年過去了，那個未來就是現在。</p>
<p>作用域執行緒在 <a href="https://docs.rs/crossbeam/0.7.1/crossbeam/thread/index.html">Crossbeam</a> 中經過多年的經驗累積，我們的設計已經趨於成熟，足以被推廣到標準函式庫中。</p>
<p>更多內容請看<a href="3151-scoped-threads.html#rationale-and-alternatives">基本理由及替代方案</a>部分。</p>
<h1 id="教學式解說-7"><a class="header" href="#教學式解說-7">教學式解說</a></h1>
<p>執行緒生成的 &quot;hello world&quot; 可能如下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let greeting = String::from(&quot;Hello world!&quot;);

let handle = thread::spawn(move || {
    println!(&quot;thread #1 says: {}&quot;, greeting);
});

handle.join().unwrap();
<span class="boring">}</span></code></pre></pre>
<p>現在讓我們嘗試生成兩個使用相同 greeting 的執行緒。不幸的是，我們必須克隆它，因為 <a href="https://doc.rust-lang.org/std/thread/fn.spawn.html"><code>thread::spawn()</code></a> 有 <code>F: 'static</code> 要求，這意味著執行緒不能借用局部變數：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let greeting = String::from(&quot;Hello world!&quot;);

let handle1 = thread::spawn({
    let greeting = greeting.clone();
    move || {
        println!(&quot;thread #1 says: {}&quot;, greeting);
    }
});

let handle2 = thread::spawn(move || {
    println!(&quot;thread #2 says: {}&quot;, greeting);
});

handle1.join().unwrap();
handle2.join().unwrap();
<span class="boring">}</span></code></pre></pre>
<p>作用域執行緒來解決！透過打開一個新的 <code>thread::scope()</code> 區塊，我們可以向編譯器證明在這作用域內產生的所有執行緒也會在這個作用域內結束生命。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let greeting = String::from(&quot;Hello world!&quot;);

thread::scope(|s| {
    let handle1 = s.spawn(|_| {
        println!(&quot;thread #1 says: {}&quot;, greeting);
    });

    let handle2 = s.spawn(|_| {
        println!(&quot;thread #2 says: {}&quot;, greeting);
    });

    handle1.join().unwrap();
    handle2.join().unwrap();
});
<span class="boring">}</span></code></pre></pre>
<p>這意味著可以毫無顧忌地借用作用域之外的變數！</p>
<p>現在我們不必再手動會合執行緒，因為所有未會合的執行緒將在作用域結束時自動會合：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let greeting = String::from(&quot;Hello world!&quot;);

thread::scope(|s| {
    s.spawn(|_| {
        println!(&quot;thread #1 says: {}&quot;, greeting);
    });

    s.spawn(|_| {
        println!(&quot;thread #2 says: {}&quot;, greeting);
    });
});
<span class="boring">}</span></code></pre></pre>
<p>當以這種方式利用自動會合時，請注意，如果任何自動會合的執行緒出現恐慌，<code>thread::scope()</code> 將出現恐慌。</p>
<p>你可能已經注意到作用域執行緒現在只接受一個參數，它只是對 <code>s</code> 的另一個引用。由於 <code>s</code> 存在於作用域內，我們不能直接借用它。使用傳遞的參數來生成巢狀執行緒：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thread::scope(|s| {
    s.spawn(|s| {
        s.spawn(|_| {
            println!(&quot;I belong to the same `thread::scope()` as my parent thread&quot;)
        });
    });
});
<span class="boring">}</span></code></pre></pre>
<h1 id="技術文件式解說-6"><a class="header" href="#技術文件式解說-6">技術文件式解說</a></h1>
<p>我們在 <code>std::thread</code> 模組中新增兩個新的型別：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Scope&lt;'env&gt; {}
struct ScopedJoinHandle&lt;'scope, T&gt; {}
<span class="boring">}</span></code></pre></pre>
<p>生命週期 <code>'env</code> 代表作用域外的環境，而 <code>'scope</code> 代表作用域本身。更準確地說，作用域外的所有內容都比 <code>'env</code> 和 <code>'scope</code> 內的所有內容都長。生命週期的關係是：</p>
<pre><code>'variables_outside: 'env: 'scope: 'variables_inside
</code></pre>
<p>接下來，我們需要 <code>scoped()</code> 跟 <code>spawn()</code> 函式：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn scope&lt;'env, F, T&gt;(f: F) -&gt; T
where
    F: FnOnce(&amp;Scope&lt;'env&gt;) -&gt; T;

impl&lt;'env&gt; Scope&lt;'env&gt; {
    fn spawn&lt;'scope, F, T&gt;(&amp;'scope self, f: F) -&gt; ScopedJoinHandle&lt;'scope, T&gt;
    where
        F: FnOnce(&amp;Scope&lt;'env&gt;) -&gt; T + Send + 'env,
        T: Send + 'env;
}
<span class="boring">}</span></code></pre></pre>
<p>這就是作用域執行緒的要點，真的。</p>
<p>現在我們只需要再做兩件事來使 API 完整。首先，<code>ScopedJoinHandle</code> 等同於 <code>JoinHandle</code>，但與 <code>'scope</code> 生命週期掛勾，所以它將有同樣的方法。第二，執行緒生成器需要能夠在一個作用域内生成執行緒。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'scope, T&gt; ScopedJoinHandle&lt;'scope, T&gt; {
    fn join(self) -&gt; Result&lt;T&gt;;
    fn thread(&amp;self) -&gt; &amp;Thread;
}

impl Builder {
    fn spawn_scoped&lt;'scope, 'env, F, T&gt;(
        self,
        &amp;'scope Scope&lt;'env&gt;,
        f: F,
    ) -&gt; io::Result&lt;ScopedJoinHandle&lt;'scope, T&gt;&gt;
    where
        F: FnOnce(&amp;Scope&lt;'env&gt;) -&gt; T + Send + 'env,
        T: Send + 'env;
}
<span class="boring">}</span></code></pre></pre>
<h1 id="缺點-10"><a class="header" href="#缺點-10">缺點</a></h1>
<p>作用域執行緒的主要缺點是使標準函式庫有點大。</p>
<h1 id="基本原理和替代方案"><a class="header" href="#基本原理和替代方案">基本原理和替代方案</a></h1>
<ul>
<li>
<p>將作用域執行緒保留在外部 crates 之中。</p>
<p>將他們放在標準函式庫有幾個優點：</p>
<ul>
<li>
<p>這是一個非常常見和實用的工具，非常適合學習、測試和探索性程式設計。每個學習 Rust 的人都會在某個時候遇到借用和執行緒的互動。有一個非常重要的教訓是執行緒實際上<strong>可以</strong>借用局部變數，但標準函式庫並沒有反映這一點。</p>
</li>
<li>
<p>有些人可能會爭辯說我們應該完全不鼓勵使用執行緒，而是將人們指向像 Rayon 和 Tokio 這樣的執行器。但是，<code>thread::spawn()</code> 需要 F: <code>F: 'static</code> 並且無法繞過它，這感覺就像是標準函式庫中缺少的部分。</p>
</li>
<li>
<p>實現作用域執行緒非常難處理，因此最好有標準函式庫提供一個可靠的解決方案。</p>
</li>
<li>
<p>官方文檔和書籍中有許多範例可以透過作用域執行緒進行簡化。</p>
</li>
<li>
<p>作用域執行緒通常是比 <code>thread::spawn()</code> 更好的預設值，因為它們確保生成的執行緒被連接並且不會意外 「洩漏」。這有時是單元測試中的一個問題，如果單元測試產生執行緒並忘記會合它們，「迷途」 的執行緒可能會積累。</p>
</li>
<li>
<p>使用者一直在 IRC 和論壇上詢問作用域執行緒。將它們作為 <code>std::thread</code> 中的「祝福」模式對每個人都有好處。</p>
</li>
</ul>
</li>
<li>
<p>從 <code>scope</code> 回傳一個 <code>Result</code>，包括所有捕獲的恐慌。</p>
<ul>
<li>這很快變得複雜，因為多個執行緒可能已經恐慌。回傳 <code>Vec</code> 或其他恐慌的集合並不總是最有用的介面，而且通常是不必要的。如果使用者想要處理它們，在 <code>ScopedJoinHandle</code> 上顯式使用 <code>.join()</code> 來處理恐慌是最靈活且最有效的方法。</li>
</ul>
</li>
<li>
<p>不要將 <code>&amp;Scope</code> 參數傳遞給執行緒。</p>
<ul>
<li>假如使用 <code>scope.spawn(|| ..)</code> 而不是 <code>scope.spawn(|scope| ..)</code>，則需要 <code>move</code> 關鍵字 (<code>scope.spawn(move || ..)</code>)，如果你想在 closure 內使用作用域，將變得不符合人因工程。</li>
</ul>
</li>
</ul>
<h1 id="現有技術-2"><a class="header" href="#現有技術-2">現有技術</a></h1>
<p>自 Rust 1.0 以來，Crossbeam 就有了<a href="https://docs.rs/crossbeam/0.7.1/crossbeam/thread/index.html">作用域執行緒</a>。</p>
<p>Crossbeam 的作用域執行緒有兩種設計。舊的是在 <code>thread::scoped()</code> 被刪除後，我們想在 Rust 1.0 時代有一個合理的替代方案。新的則是在去年的大改版之中。</p>
<ul>
<li>舊: https://docs.rs/crossbeam/0.2.12/crossbeam/fn.scope.html</li>
<li>新: https://docs.rs/crossbeam/0.7.1/crossbeam/fn.scope.html</li>
</ul>
<p>新舊作用域執行緒之間存在一些差異：</p>
<ol>
<li>
<p><code>scope()</code> 現在從子執行緒傳播未處理的恐慌。在舊的設計中，恐慌被默默地忽略了。使用者仍然可以透過手動操作 <code>ScopedJoinHandle</code> 來處理恐慌。</p>
</li>
<li>
<p>傳遞給 <code>Scope::spawn()</code> 的 closure 現在需要一個 <code>&amp;Scope&lt;'env&gt;</code> 參數，該參數允許生成巢狀執行緒，這在舊設計中是不可能的。 Rayon 類似地傳遞了對子任務的引用。</p>
</li>
<li>
<p>我們刪除了 <code>Scope::defer()</code>，因為它不是真的有用，有錯誤，並且有不明顯的行為。</p>
</li>
<li>
<p><code>ScopedJoinHandle</code> 在 <code>'scope</code> 上進行了參數化，以防止它逃離作用域。</p>
</li>
</ol>
<p>Rayon 也有作用域，但它們在不同的抽象級別上工作——Rayon 產生任務而不是執行緒。它的 API 與本 RFC 中提出的 API 相同。</p>
<h1 id="未解決的問題-3"><a class="header" href="#未解決的問題-3">未解決的問題</a></h1>
<p>這個概念可以延伸到非同步嗎？會有任何行為或 API 差異嗎？</p>
<h1 id="未來的可能性"><a class="header" href="#未來的可能性">未來的可能性</a></h1>
<p>在未来，我們也可以有一個像 Rayon 那樣的執行緒池，可以生成作用域内的任務。</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature Name: leadership-council</li>
<li>Start Date: 2022-08-01</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/3392">rust-lang/rfcs#3392</a></li>
<li>Rust Issue: N/A</li>
<li>Commit: <a href="https://github.com/rust-lang/rfcs/blob/075f4b30f5c33315163c8e6a75e3210af6229ded/text/3392-leadership-council.md">The commit link this page based on</a></li>
</ul>
<h1 id="摘要"><a class="header" href="#摘要">摘要</a></h1>
<p>This RFC establishes a Leadership Council as the successor of the core team<sup class="footnote-reference"><a href="#core">1</a></sup> and the new governance structure through which Rust Project members collectively confer the authority<sup class="footnote-reference"><a href="#authority">2</a></sup> to ensure successful operation of the Project. The Leadership Council delegates much of this authority to teams (which includes subteams, working groups, etc.<sup class="footnote-reference"><a href="#teams">3</a></sup>) who autonomously make decisions concerning their purviews. However, the Council retains some decision-making authority, outlined and delimited by this RFC.</p>
<p>The Council will be composed of representatives delegated to the Council from each <a href="3392-leadership-council.html#%E4%B8%80%E7%B4%9A%E5%9C%98%E9%9A%8A%E5%96%AE%E4%BD%8D">top-level team</a>.</p>
<p>The Council is charged with the success of the Rust Project as a whole. The Council will identify work that needs to be done but does not yet have a clear owner, create new teams to accomplish this work, hold existing teams accountable for the work in their purview, and coordinate and adjust the organizational structure of Project teams.</p>
<h1 id="大綱"><a class="header" href="#大綱">大綱</a></h1>
<ul>
<li><a href="3392-leadership-council.html#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99">參考資料</a></li>
<li><a href="3392-leadership-council.html#%E5%8B%95%E6%A9%9F">動機</a></li>
<li><a href="3392-leadership-council.html#%E7%90%86%E4%BA%8B%E6%9C%83%E4%B9%8B%E8%81%B7%E8%B2%AC%E3%80%81%E6%9C%9F%E5%BE%85%E8%88%87%E9%99%90%E5%88%B6">理事會之職責、期待與限制</a></li>
<li><a href="3392-leadership-council.html#%E7%90%86%E4%BA%8B%E6%9C%83%E7%B5%84%E7%B9%94%E6%9E%B6%E6%A7%8B">理事會組織架構</a>
<ul>
<li><a href="3392-leadership-council.html#%E4%B8%80%E7%B4%9A%E5%9C%98%E9%9A%8A%E5%96%AE%E4%BD%8D">一級團隊單位</a>
<ul>
<li><a href="3392-leadership-council.html#%E4%B8%80%E7%B4%9A%E5%9C%98%E9%9A%8A%E5%88%9D%E5%A7%8B%E5%90%8D%E5%96%AE">一級團隊初始名單</a></li>
<li><a href="3392-leadership-council.html#%E5%95%9F%E5%8B%95%E5%8F%B0-%E4%B8%80%E7%B4%9A%E5%9C%98%E9%9A%8A">「啟動台」 一級團隊</a></li>
<li><a href="3392-leadership-council.html#%E5%BB%A2%E9%99%A4%E4%B8%80%E7%B4%9A%E5%9C%98%E9%9A%8A">廢除一級團隊</a></li>
</ul>
</li>
<li><a href="3392-leadership-council.html#%E5%80%99%E8%A3%9C%E8%88%87%E6%94%BE%E6%A3%84%E4%BB%A3%E8%A1%A8%E6%AC%8A%E5%88%A9">候補與放棄代表權利</a></li>
<li><a href="3392-leadership-council.html#%E4%BB%BB%E6%9C%9F%E9%99%90%E5%88%B6">任期限制</a></li>
<li><a href="3392-leadership-council.html#%E5%B0%8D%E5%96%AE%E4%B8%80%E5%85%AC%E5%8F%B8%E6%88%96%E5%AF%A6%E9%AB%94%E4%BB%A3%E8%A1%A8%E4%B9%8B%E9%99%90%E5%88%B6">對單一公司或實體代表之限制</a></li>
<li><a href="3392-leadership-council.html#%E5%80%99%E9%81%B8%E8%B3%87%E6%A0%BC">候選資格</a></li>
<li><a href="3392-leadership-council.html#%E8%88%87-core-%E5%9C%98%E9%9A%8A%E4%B9%8B%E9%97%9C%E4%BF%82">與 Core 團隊之關係</a></li>
<li><a href="3392-leadership-council.html#%E8%88%87-rust-%E5%9F%BA%E9%87%91%E6%9C%83%E4%B9%8B%E9%97%9C%E4%BF%82">與 Rust 基金會之關係</a></li>
</ul>
</li>
<li><a href="3392-leadership-council.html#%E7%90%86%E4%BA%8B%E6%9C%83%E6%B1%BA%E7%AD%96%E6%B5%81%E7%A8%8B">理事會決策流程</a>
<ul>
<li><a href="3392-leadership-council.html#%E7%87%9F%E9%81%8B%E8%88%87%E6%94%BF%E7%AD%96%E6%B1%BA%E7%AD%96">營運與政策決策</a></li>
<li><a href="3392-leadership-council.html#%E9%87%8D%E8%A4%87%E8%88%87%E4%BE%8B%E5%A4%96">重複與例外</a></li>
<li><a href="3392-leadership-council.html#%E5%85%B1%E8%AD%98%E6%B1%BA%E7%AD%96%E6%B5%81%E7%A8%8B">共識決策流程</a>
<ul>
<li><a href="3392-leadership-council.html#%E6%A0%B8%E5%87%86%E6%A8%99%E6%BA%96">核准標準</a></li>
</ul>
</li>
<li><a href="3392-leadership-council.html#%E8%AE%8A%E6%9B%B4%E8%88%87%E8%AA%BF%E6%95%B4%E6%B1%BA%E7%AD%96%E6%B5%81%E7%A8%8B">變更與調整決策流程</a></li>
<li><a href="3392-leadership-council.html#%E8%AD%B0%E7%A8%8B%E8%88%87%E5%BE%85%E8%BE%A6%E4%BA%8B%E9%A0%85">議程與待辦事項</a></li>
<li><a href="3392-leadership-council.html#%E8%A7%A3%E6%B1%BA%E5%83%B5%E5%B1%80">解決僵局</a></li>
<li><a href="3392-leadership-council.html#%E5%9B%9E%E9%A5%8B%E8%88%87%E8%A9%95%E4%BC%B0">回饋與評估</a></li>
</ul>
</li>
<li><a href="3392-leadership-council.html#%E6%B1%BA%E7%AD%96%E6%B5%81%E7%A8%8B%E4%B9%8B%E9%80%8F%E6%98%8E%E5%BA%A6%E5%92%8C%E7%9B%A3%E7%9D%A3">決策流程之透明度和監督</a>
<ul>
<li><a href="3392-leadership-council.html#%E7%90%86%E4%BA%8B%E6%9C%83%E5%8F%AF%E5%9C%A8%E5%85%A7%E9%83%A8%E5%81%9A%E5%87%BA%E4%B9%8B%E6%B1%BA%E5%AE%9A">理事會可在內部做出之決定</a></li>
<li><a href="3392-leadership-council.html#%E7%90%86%E4%BA%8B%E6%9C%83%E9%A0%88%E7%A7%81%E4%B8%8B%E4%BF%9D%E5%AF%86%E5%81%9A%E5%87%BA%E4%B9%8B%E6%B1%BA%E5%AE%9A">理事會須私下保密做出之決定</a></li>
<li><a href="3392-leadership-council.html#%E7%90%86%E4%BA%8B%E6%9C%83%E9%A0%88%E7%B6%93%E5%85%AC%E9%96%8B%E6%8F%90%E6%A1%88%E5%81%9A%E5%87%BA%E4%B9%8B%E6%B1%BA%E5%AE%9A">理事會須經公開提案做出之決定</a></li>
<li><a href="3392-leadership-council.html#%E5%88%A9%E7%9B%8A%E8%A1%9D%E7%AA%81">利益衝突</a></li>
<li><a href="3392-leadership-council.html#%E7%A2%BA%E5%AE%9A%E8%88%87%E6%9B%B4%E6%94%B9%E5%9C%98%E9%9A%8A%E6%AC%8A%E8%B2%AC">確定與更改團隊權責</a></li>
</ul>
</li>
<li><a href="3392-leadership-council.html#%E7%9B%A3%E7%9D%A3%E8%88%87%E5%95%8F%E8%B2%AC%E6%A9%9F%E5%88%B6">監督與問責機制</a>
<ul>
<li><a href="3392-leadership-council.html#%E7%A2%BA%E4%BF%9D%E8%83%BD%E8%BF%BD%E7%A9%B6%E7%90%86%E4%BA%8B%E6%9C%83%E4%B9%8B%E8%B2%AC%E4%BB%BB">確保能追究理事會之責任</a></li>
<li><a href="3392-leadership-council.html#%E7%A2%BA%E4%BF%9D%E8%83%BD%E8%BF%BD%E7%A9%B6%E7%90%86%E4%BA%8B%E6%9C%83%E4%BB%A3%E8%A1%A8%E4%B9%8B%E8%B2%AC%E4%BB%BB">確保能追究理事會代表之責任</a></li>
<li><a href="3392-leadership-council.html#%E7%A2%BA%E4%BF%9D%E8%83%BD%E8%BF%BD%E7%A9%B6%E5%9C%98%E9%9A%8A%E4%B9%8B%E8%B2%AC%E4%BB%BB">確保能追究團隊之責任</a></li>
</ul>
</li>
<li><a href="3392-leadership-council.html#%E5%AF%A9%E6%A0%B8%E3%80%81%E5%88%86%E6%AD%A7%E8%88%87%E8%A1%9D%E7%AA%81">審核、分歧與衝突</a>
<ul>
<li><a href="3392-leadership-council.html#%E5%9C%98%E9%9A%8A%E9%96%93%E4%B9%8B%E5%88%86%E6%AD%A7">團隊間之分歧</a></li>
<li><a href="3392-leadership-council.html#%E6%B6%89%E5%8F%8A%E5%9C%98%E9%9A%8A%E6%88%96%E5%B0%88%E6%A1%88%E6%88%90%E5%93%A1%E4%B9%8B%E8%A1%9D%E7%AA%81">涉及團隊或專案成員之衝突</a></li>
<li><a href="3392-leadership-council.html#%E5%AF%A9%E6%A0%B8%E4%BA%BA%E4%BB%A3%E8%A1%A8%E5%9C%98">審核人代表團</a></li>
<li><a href="3392-leadership-council.html#%E5%AF%A9%E6%A0%B8%E5%9C%98%E9%9A%8A%E4%B9%8B%E6%94%BF%E7%AD%96%E8%88%87%E7%A8%8B%E5%BA%8F">審核團隊之政策與程序</a></li>
<li><a href="3392-leadership-council.html#%E7%A8%BD%E6%A0%B8">稽核</a></li>
<li><a href="3392-leadership-council.html#%E6%9C%80%E7%B5%82%E5%95%8F%E8%B2%AC%E6%A9%9F%E5%88%B6">最終問責機制</a></li>
<li><a href="3392-leadership-council.html#%E6%B6%89%E5%8F%8A%E5%B0%88%E6%A1%88%E6%88%90%E5%93%A1%E4%B9%8B%E5%AF%A9%E6%A0%B8%E6%8E%AA%E6%96%BD">涉及專案成員之審核措施</a></li>
<li><a href="3392-leadership-council.html#%E6%B6%89%E5%8F%8A%E7%90%86%E4%BA%8B%E6%9C%83%E4%BB%A3%E8%A1%A8%E4%B9%8B%E8%A1%9D%E7%AA%81">涉及理事會代表之衝突</a></li>
<li><a href="3392-leadership-council.html#%E6%B6%89%E5%8F%8A%E5%AF%A9%E6%A0%B8%E5%9C%98%E9%9A%8A%E6%88%90%E5%93%A1%E4%B9%8B%E8%A1%9D%E7%AA%81">涉及審核團隊成員之衝突</a></li>
</ul>
</li>
<li><a href="3392-leadership-council.html#%E6%9C%AC%E6%A1%88%E4%B9%8B%E6%89%B9%E5%87%86">本案之批准</a></li>
<li><a href="3392-leadership-council.html#%E9%99%84%E8%A8%BB">附註</a></li>
</ul>
<h1 id="參考資料"><a class="header" href="#參考資料">參考資料</a></h1>
<p>To reduce the size of this RFC, non-binding reference materials appear in separate documents:</p>
<ul>
<li><a href="3392-leadership-council/motivation.html">Full motivation</a>
<ul>
<li><a href="https://blog.rust-lang.org/inside-rust/2022/05/19/governance-update.html">Further research into the needs of Project-wide governance (Inside Rust blog post)</a></li>
</ul>
</li>
<li><a href="3392-leadership-council/non-goals.html">Non-goals of this RFC</a></li>
<li><a href="3392-leadership-council/alternatives.html">Rationale and alternatives</a></li>
<li><a href="3392-leadership-council/initial-work-of-the-council.html">Recommendations for initial work of the Council</a></li>
</ul>
<h1 id="動機-13"><a class="header" href="#動機-13">動機</a></h1>
<p>The Rust project consists of hundreds of globally distributed people, organized into teams with various purviews. However, a great deal of work falls outside the purview of any established team, and still needs to get done.</p>
<p>Historically, the core team both identified and prioritized important work that fell outside of team purviews, and also attempted to do that work itself. However, putting both of those activities in the same team has not scaled and has led to burnout.</p>
<p>The Leadership Council established by this RFC focuses on identifying and prioritizing work outside of team purviews. The Council primarily delegates that work, rather than doing that work itself. The Council can also serve as a coordination, organization, and accountability body between teams, such as for cross-team efforts, roadmaps, and the long-term success of the Project.</p>
<p>This RFC also establishes mechanisms for oversight and accountability between the Council as a whole, individual Council members, the moderation team, the Project teams, and Project members.</p>
<h1 id="理事會之職責期待與限制"><a class="header" href="#理事會之職責期待與限制">理事會之職責、期待與限制</a></h1>
<p>高層級描述下，理事會<strong>只</strong>負責以下職責：</p>
<ul>
<li>識別、優先排序以及追蹤由於缺乏明確負責者而無法執行的工作（而不應對負責者刻意降低優先度、置於待辦事項等的工作）。</li>
<li>委派該工作，並潛在可建立全新的（並可能為<strong>暫時性的</strong>）團隊來負責此工作。</li>
<li>為沒有明確負責者的<strong>緊急</strong>事項下達決策。
<ul>
<li>此行為只能在特例情境下執行，即該決策無法委派給既有團隊也無法交付給全新團隊時。</li>
</ul>
</li>
<li>為團隊、架構或流程協調橫跨專案的變更。</li>
<li>確保一級團隊能為其權責、對其他團隊以及對專案本身負責。</li>
<li>確保各個團隊能有完成其工作所需的人力與資源。</li>
<li>為 Rust 專案整體建立起官方的定位、觀點或意願。
<ul>
<li>藉此能幫助降低橫跨專案的協調需求，尤其是面對長期公開投票與共識建立流程不夠實際的情境。舉例來說，要對第三方單位溝通 Rust 專案整體「 所想要的目標」時。</li>
</ul>
</li>
</ul>
<p>除了這些職責外，對理事會也有額外的期待與限制，以幫助判斷理事會是否正常運作：</p>
<ul>
<li><strong>委派工作</strong>：理事會不應該主動執行本案沒有明確指派的工作；理事會必須委派給既有團隊或者成員與理事會不重複的全新團隊。執行工作的團隊中可以有理事會的代表，但是做為團隊成員並不屬於理事會代表的權責。</li>
<li><strong>為了確保專案長期的流暢運作</strong>：理事會應該要確保非緊急專案管理工作有接受優先度排序，並且能定期完成以確保專案不會累積成整個組織級別的負擔。</li>
<li><strong>負責任</strong>：由於理事會擁有廣泛的權力，理事會與理事會代表必須要為自己的行為負責任。他們應該要傾聽他人的回饋，並且能對他們是否可以繼續達到該職位所需的職責與期待進行主動的反思。</li>
<li><strong>做好代表</strong>：理事會代表不只要能代表整個專案各形式的考量，也要能盡可能代表 Rust 社群的各方面（人口分布、技術背景等等）。</li>
<li><strong>共享負擔</strong>：所有理事會代表都必須共享理事會職責的負擔。</li>
<li><strong>尊重他人的權責</strong>：理事會必須尊重委派給各團隊的權責。理事會必須與各團隊諮商並且共同合作解決問題，並且盡量不作出違背任何團隊意願的決策。</li>
<li><strong>以良善原則行事</strong>：理事會代表應該以 Rust 專案<strong>整體</strong>的利益作出決策，即便這些決策可能會與各個團隊、雇主以及其他外部單位的利益衝突。</li>
<li><strong>保持透明</strong>：雖然不是所有決策（以及決策的各方面）都能被公開，理事會應該要盡可能維持其決策的公開與透明。理事會也應該要確保專案的組織架構很明確透明。</li>
<li><strong>尊重隱私</strong>：理事會的成員絕不能為了透明性而洩漏個人或者機密情報，包含可能會意外洩漏重要資訊的周邊資訊。</li>
<li><strong>維持健康的工作環境</strong>：理事會代表應該要為他們的貢獻與其性質感到滿意。他們不應認為自己在理事會中的存在只是義務所為，而必須是因為他們用有意義的方式主動參與。</li>
<li><strong>持續演化</strong>：理事會受到期待會隨著時間演化以應對團隊、專案以及社群的演化。</li>
</ul>
<p>理事會代表、審核團隊成員以及其他專案成員都應該能為身邊的人以及更廣泛的社群做好示範。這些職位都有對應的責任與領導，也因此這些人的行為都帶有份量而會對社群造成重大影響，也因此必須注意行使職權。選擇要行使這些職權的人都應該要知道身邊的人會以對應的高標準看待他們。</p>
<h1 id="理事會組織架構"><a class="header" href="#理事會組織架構">理事會組織架構</a></h1>
<p>理事會由一群團隊代表所組成，各代表一支<a href="3392-leadership-council.html#%E4%B8%80%E7%B4%9A%E5%9C%98%E9%9A%8A%E5%96%AE%E4%BD%8D">一級團隊</a>以及其子團隊。</p>
<p>每支一級團隊都能用各自所選的程序選出恰好一名代表。</p>
<p>任何一級團隊的成員或其子團隊的成員都能作為其代表。團隊必須提供子團隊成員對潛在候選給予意見與回饋的經驗。</p>
<p>各個代表最多代表一支一級團隊，就算他們也是其他團隊的成員。代表任何 Rust 團隊的主要責任將由其所屬的一級團隊代表負責。<sup class="footnote-reference"><a href="#under-multiple-teams">4</a></sup></p>
<p>所有 Rust 專案團隊都必須至少隸屬於一支一級團隊。對於目前沒有母團隊的團隊，本案會建立起<a href="3392-leadership-council.html#%E3%80%8C%E5%95%9F%E5%8B%95%E5%8F%B0%E3%80%8D%E4%B8%80%E7%B4%9A%E5%9C%98%E9%9A%8A">「啟動台團隊」</a>作為暫時性的隸屬對象。以確保所有團隊都在理事會有對應的代表。</p>
<h2 id="一級團隊單位"><a class="header" href="#一級團隊單位">一級團隊單位</a></h2>
<p>理事會將會透過公開政策決策建立一級團隊。一般來說，一級團隊應該要符合以下條件：</p>
<ul>
<li>有對 Rust 專案具備根本重要性的權責</li>
<li>是該權責全面向的最終決策者</li>
<li>所有權責不隸屬於其他團隊權責（不能為子團隊或相似管理架構所有）</li>
<li>有著能期待無止盡持續的開放權責</li>
<li>目前為 Rust 專案中活躍的存在</li>
</ul>
<p>一級團隊的數量必須介於 4 到 9（包含）之間，傾向介於 5 到 8 之間。這個數字能相對平衡多元性的需求以及相對小的架構，同時又在進行有效對話與共識凝聚時具備實務性。<sup class="footnote-reference"><a href="#number-of-representatives">5</a></sup></p>
<p>當理事會建立起全新一級團隊時，該團隊則該指派一名理事會代表。<sup class="footnote-reference"><a href="#bootstrapping-new-teams">6</a></sup>當建立起全新的一級團隊時，理事會必須提供為何該一級團隊不能作為子團隊或者其他管理架構存在的解釋。</p>
<h3 id="一級團隊初始名單"><a class="header" href="#一級團隊初始名單">一級團隊初始名單</a></h3>
<p>一級團隊的初始名單由本案使發表時列於 <a href="https://www.rust-lang.org/governance">rust-lang.org 網站的一級管理區域</a>的所有團隊組成（除去 Core 團隊與校友），再加上<a href="3392-leadership-council.html#%E3%80%8C%E5%95%9F%E5%8B%95%E5%8F%B0%E3%80%8D%E4%B8%80%E7%B4%9A%E5%9C%98%E9%9A%8A">「啟動台」團隊</a>：</p>
<ul>
<li>編譯器</li>
<li>Crates.io</li>
<li>開發工具</li>
<li>基礎架構</li>
<li>語言</li>
<li>啟動台</li>
<li>函式庫</li>
<li>審核</li>
<li>發佈</li>
</ul>
<p>本清單並不是最佳的一級團隊組成。本案建議理事會的最開始的工作就是檢視既存的管理架構並確保所有架構都在一個或多個一級團隊中有直接或間接的代表，並且確保所有一級團隊都有符合能被認定為一級團隊的條件。這將會涉及對一級團隊組成的調整。</p>
<h3 id="啟動台一級團隊"><a class="header" href="#啟動台一級團隊">「啟動台」一級團隊</a></h3>
<p>本案會建立「啟動台（launching pad）」團隊以<strong>暫時</strong>接受沒有對應一級團隊可以歸類的子團隊。這樣能夠確保在更加永久性的母團隊被找到或者建立起之前，所有團隊都在理事會有代表。</p>
<p>「啟動台」是個雨傘團隊：該團隊沒有直接成員，只有子團隊代表。</p>
<p>理事會應該要致力於為所有「啟動台」子團隊找尋或者建立更合適的母團隊，並且隨之將子團隊移轉至對應的母團隊。</p>
<p>在某些情況下，雖有合適的母團隊但尚未準備好接受子團隊時，啟動台能作為臨時歸宿容納這些例子。</p>
<p>而對於團隊面臨移除或重組時，如果移除或重組時並沒有明確將其子團隊納入其他組織中的母團隊，則啟動台將會作為這些子團隊的預設歸宿。</p>
<p>理事會必須每六個月審視「啟動台」中的子團隊成員狀況，以確保有合適的流程在協助所有子團隊成員找到新的母團隊。而與其它一級團隊相同的是，只要理事會認為「啟動台」團隊不再需要，就可以將之撤除（並且移除掉其在理事會中的代表）。撤除「啟動台」團隊的流程與其他一級團隊同理。除此之外，理事會也可以給予「啟動台」團隊自己的權責，但是此措施不屬於本案的範圍內。</p>
<h3 id="廢除一級團隊"><a class="header" href="#廢除一級團隊">廢除一級團隊</a></h3>
<p>任何要移除團隊的一級指定（或其他會導致無法參與理事會）的決策，都需要除卻將被移除的一級團隊代表外所有理事會代表的共識。雖然如此，必須要邀請考慮移除的團隊代表參與關於團隊移除的理事會審議，而理事會也只能在極端特例下不顧團隊反對將之移除。</p>
<p>理事會不得移除審核團隊。理事會不能在沒有審核團隊的同意下改變審核團隊的權責。</p>
<h2 id="候補與放棄代表權利"><a class="header" href="#候補與放棄代表權利">候補與放棄代表權利</a></h2>
<p>A representative may end their term early if necessary, such as due to changes in their availability or circumstances. The respective top-level team must then begin selecting a new representative. The role of representative is a volunteer position. No one is obligated to fill that role, and no team is permitted to make serving as a representative a necessary obligation of membership in a team. However, a representative is obligated to fulfill the duties of the position of representative, or resign that position.</p>
<p>A top-level team may decide to temporarily relinquish their representation, such as if the team is temporarily understaffed and they have no willing representative. However, if the team does not designate a Council representative, they forgo their right to actively participate in decision-making at a Project-wide level. All Council procedures including decision-making should not be blocked due to this omission. The Council is still obligated to consider new information and objections from all Project members. However, the Council is not obligated to block decisions to specially consider or collate a non-represented team's feedback.</p>
<p>Sending a representative to the Council is considered a duty of a top-level team, and not being able to regularly do so means the team is not fulfilling its duties. However, a Council representative does not relinquish their role in cases of short absence due to temporary illness, vacation, etc.</p>
<p>A top-level team can designate an alternate representative to serve in the event their primary representative is unavailable. This alternate assumes the full role of Council representative until the return of the primary representative. Alternate representatives do not regularly attend meetings when the primary representative is present (to avoid doubling the number of attendees).</p>
<p>If a team's representative <em>and</em> any alternates fail to participate in any Council proceedings for 3 consecutive weeks, the team's representative ceases to count towards the decision-making quorum requirements of the Council until the team can provide a representative able to participate. The Council must notify the team of this before it takes effect. If a team wishes to ensure the Council does not make decisions without their input or without an ability for objections to be made on their behalf, they should ensure they have an alternate representative available.</p>
<p>A top-level team may change their representative before the end of their term, if necessary.  However, as maintaining continuity incurs overhead, teams should avoid changing their representatives more than necessary. Teams have the primary responsibility for briefing their representative and alternates on team-specific issues or positions they wish to handle on an ongoing basis. The Council and team share the responsibilities of maintaining continuity for ongoing issues within the Council, and of providing context to alternates and other new representatives.</p>
<p>For private matters, the Council should exercise discretion on informing alternates, to avoid spreading private information unnecessarily; the Council can brief alternates if they need to step in.</p>
<h2 id="任期限制"><a class="header" href="#任期限制">任期限制</a></h2>
<p>理事會代表任期為一年。對於任何已被認可的代表團（來自特定一級團隊的代表團），每位代表有最多連任三次的非硬性限制。一位代表在理事會收到來自個別團隊明確指出他們無法產生另一位代表時，得超過任期限制（舉例來說，因為缺乏其他有意願的候選人，或是因為團隊成員對其他任何候選人提出反對意見）。</p>
<p>除此之外，對於單一代表在其他一級團隊服務的任期數、或是在單一一級團隊的非連續任期，並沒有任何硬性限制。團隊應該力求在經驗的存續與代表的替換之間取得平衡，以提供更多人這樣的經驗。<sup class="footnote-reference"><a href="#representative-selection">7</a></sup></p>
<p>一半的代表將在（每年的）三月底進行任命，另一半則在九月底進行任命。這避免了同時更換所有理事會代表。對於初始的理事會以及在任何時候的一級團隊組成發生改變，理事會以及一級團隊應該共同努力使任期結束日大約平均落在在三月與九月各半。然而，每個任期應該至少持續六個月（為了避免任期過短，暫時的不平衡是可被接受的）。</p>
<p>如果理事會及一級團隊無法就適當的任期結束日變更達成共識，代表將在三月底或九月底兩者之間被隨機分配一個任期結束日（且在至少 6 個月後）以維持平衡。</p>
<h2 id="對單一公司或實體代表之限制"><a class="header" href="#對單一公司或實體代表之限制">對單一公司或實體代表之限制</a></h2>
<p>Council representatives must not disproportionately come from any one company, legal entity, or closely related set of legal entities, to avoid impropriety or the appearance of impropriety. If the Council has 5 or fewer representatives, no more than 1 representative may have the same affiliation; if the Council has 6 or more representatives, no more than 2 representatives may have the same affiliation.</p>
<p>Closely related legal entities include branches/divisions/subsidiaries of the same entity, entities connected through substantial ownership interests, or similar. The Council may make a judgment call in unusual cases, taking care to avoid conflicts of interest in that decision.</p>
<p>A Council representative is affiliated with a company or other legal entity if they derive a substantive fraction of their income from that entity (such as from an employer, client, or major sponsor). Representatives must promptly disclose changes in their affiliations.</p>
<p>If this constraint does not hold, whether by a representative changing affiliation, top-level teams appointing new representatives, or the Council size changing, restore the constraint as follows:</p>
<ul>
<li>Representatives with the same affiliation may first attempt to resolve the issue amongst themselves, such that a representative voluntarily steps down and their team appoints someone else.
<ul>
<li>This must be a decision by the representative, not their affiliated entity; it is considered improper for the affiliated entity to influence this decision.</li>
<li>Representatives have equal standing in such a discussion; factors such as seniority in the Project or the Council must not be used to pressure people.</li>
</ul>
</li>
<li>If the representatives with that affiliation cannot agree, one such representative is removed at random. (If the constraint still does not hold, the remaining representatives may again attempt to resolve the issue amongst themselves before repeating this.) This is likely to produce suboptimal results; a voluntary solution will typically be preferable.</li>
<li>While a team should immediately begin the process of selecting a successor, the team's existing representative may continue to serve up to 3 months of their remaining term.</li>
<li>The existing representative should coordinate the transition with the incoming representative but it is the team's choice which one is an actual representative during the up to 3 month window. There is only ever one representative from the top-level team.</li>
</ul>
<h2 id="候選資格"><a class="header" href="#候選資格">候選資格</a></h2>
<p>以下是決定理想候選人的標準，這些標準雖類似團隊領導者或共同領導者的標準，但並不完全相同。儘管團隊領導者<strong>可能</strong>也能成為傑出的理事會代表，但擔任團隊領導者和委員會代表都需要大量時間投入，這會促使將這些角色分配給不同的人。這些標準並非硬性要求，但可用於決定誰最適合成為團隊代表。簡而言之，代表應具備以下條件：</p>
<ul>
<li>有充沛的時間與精力，以滿足委員會的需求。</li>
<li>有興趣協助處理專案營運和治理相關事務。</li>
<li>廣泛了解專案的需求，且不限於其所在團隊或積極貢獻之領域。</li>
<li>對自己的團隊需求有敏銳的感知。</li>
<li>具備代表他人的氣質和能力，超越任何私人事務。</li>
<li>能夠代表其團隊的所有觀點，不僅僅是部分觀點，也不僅僅是團隊成員同意的觀點。</li>
</ul>
<p>儘管有些團隊目前可能沒有足夠的候選人符合這些標準，委員會應積極培養這些技能之人才，因為這些技能不僅對委員會成員資格有幫助，也對這個專案有益。</p>
<h2 id="與-core-團隊之關係"><a class="header" href="#與-core-團隊之關係">與 Core 團隊之關係</a></h2>
<p>The Leadership Council serves as the successor to the core team in all capacities. This RFC was developed with the participation and experience of the core team members, and the Council should continue seeking such input and institutional memory when possible, especially while ramping up.</p>
<p>External entities or processes may have references to &quot;the Rust core team&quot; in various capacities. The Council doesn't use the term &quot;core team&quot;, but the Council will serve in that capacity for the purposes of any such external references.</p>
<h2 id="與-rust-基金會之關係"><a class="header" href="#與-rust-基金會之關係">與 Rust 基金會之關係</a></h2>
<p>The Council is responsible for establishing the process for selecting Project directors. The Project directors are the mechanism by which the Rust Project's interests are reflected on the Rust Foundation board.</p>
<p>The Council delegates a purview to the Project directors to represent the Project's interests on the Foundation Board and to make certain decisions on Foundation-related matters. The exact boundaries of that purview are out of scope for this RFC.</p>
<h1 id="理事會決策流程"><a class="header" href="#理事會決策流程">理事會決策流程</a></h1>
<p>The Leadership Council make decisions of two different types: operational decisions and policy decisions. Certain considerations may be placed on a given decision depending on its classification. However, by default, the Council will use a consent decision-making process for all decisions regardless of classification.</p>
<h2 id="營運與政策決策"><a class="header" href="#營運與政策決策">營運與政策決策</a></h2>
<p>Operational decisions are made on a daily basis by the Council to carry out their aims, including regular actions taking place outside of meetings (based on established policy). Policy decisions provide general reusable patterns or frameworks, meant to frame, guide, and support operations. In particular, policy decisions can provide partial automation for operational decisions or other aspects of operations. The council defaults to the consent decision making process for all decisions unless otherwise specified in this RFC or other policy.</p>
<p>This RFC does not attempt to precisely define which decisions are operations versus policy; rather, they fall somewhere along a continuum. The purpose of this distinction is not to direct or constrain the council's decision-making procedures. Instead, this distinction provides guidance to the Council, and clarifies how the Council intends to record, review, and refine its decisions over time. For the purposes of any requirements or guidance associated with the operational/policy classification, anything not labeled as either operational or policy in this or future policy defaults to policy. </p>
<h2 id="重複與例外"><a class="header" href="#重複與例外">重複與例外</a></h2>
<p>Policy decisions often systematically address what might otherwise require repeated operational decisions. The Council should strive to recognize when repeated operational decisions indicate the need for a policy decision, or a policy change. In particular, the Council should avoid allowing repeated operational decisions to constitute de facto policy.</p>
<p>Exceptions to existing policy cannot be made via an operational decision unless such exceptions are explicitly allowed in said policy. Avoiding ad-hoc exceptions helps avoid <a href="https://en.wikipedia.org/wiki/Normalization_of_deviance">&quot;normalization of deviance&quot;</a>.</p>
<h2 id="共識決策流程"><a class="header" href="#共識決策流程">共識決策流程</a></h2>
<p>The Council will initially be created with a single process for determining agreement to a proposal. It is however expected that the Council will add additional processes to its toolbox soon after creation.</p>
<p>Consent means that no representative's requirements (and thus those of the top-level team and subteams they represent) can be disregarded. The Council hears all relevant input and sets a good foundation for working together equitably with all voices weighted equally.</p>
<p>The Council uses consent decision-making where instead of being asked &quot;do you agree?&quot;, representatives are asked &quot;do you object?&quot;. This eliminates &quot;pocket vetoes&quot; where people have fully reviewed a proposal but decide against approving it without giving clear feedback as to the reason. Concerns, feedback, preferences, and other less critical forms of feedback do not prevent making a decision, but should still be considered for incorporation earlier in drafting and discussion. Objections, representing an unmet requirement or need, <em>must</em> be considered and resolved to proceed with a decision.</p>
<h3 id="核准標準"><a class="header" href="#核准標準">核准標準</a></h3>
<p>The consent decision-making process has the following approval criteria:</p>
<ul>
<li>Posting the proposal in one of the Leadership Council's designated communication spaces (a meeting or a specific channel).</li>
<li>Having confirmation that at least N-2 Council representatives (where N is the total number of Council representatives) have fully reviewed the final proposal and give their consent.</li>
<li>Having no outstanding explicit objections from any Council representative.</li>
<li>Providing a minimum 10 days for feedback.</li>
</ul>
<p>The approval criteria provides a quorum mechanism, as well as sufficient time for representatives to have seen the proposal. Allowing for two non-signoffs is an acknowledgement of the volunteer nature of the Project, based on experience balancing the speed of decisions with the amount of confirmation needed for consent and non-objection; this assumes that those representatives have had time to object if they wished to do so. (This is modeled after the process used today for approval of RFCs.)</p>
<p>The decision-making process can end at any time if the representative proposing it decides to retract their proposal. Another representative can always adopt a proposal to keep it alive.</p>
<p>If conflicts of interest result in the Council being unable to meet the N-2 quorum for a decision, the Council cannot make that decision unless it follows the process documented in <a href="3392-leadership-council.html#conflicts-of-interest">the &quot;Conflicts of interest&quot; section for how a decision may proceed with conflicts documented</a>. In such a case, the Council should consider appropriate processes and policies to avoid future recurrences of a similar conflict.</p>
<h2 id="變更與調整決策流程"><a class="header" href="#變更與調整決策流程">變更與調整決策流程</a></h2>
<p>Using the public policy process, the Council can establish different decision-making processes for classes of decisions.</p>
<p>For example, the Council will almost certainly also want a mechanism for quick decision-making on a subset of operational decisions, without having to wait for all representatives to affirmatively respond. This RFC doesn't define such a mechanism, but recommends that the Council develop one as one of its first actions.</p>
<p>When deciding on which decision-making process to adopt for a particular class of decision, the Council balances the need for quick decisions with the importance of confidence in full alignment. Consent decision-making processes fall on the following spectrum:</p>
<ul>
<li>Consensus decision making (prioritizes confidence in full alignment at the expense of quick decision making): team members must review and prefer the proposal over all others, any team members may raise a blocking objection</li>
<li>Consent decision making (default for the Council, balances quick decisions and confidence in alignment): team members must review and may raise a blocking objection</li>
<li>One second and no objections (prioritizes quick decision making at the expense of confidence in alignment): one team member must review and support, any team member may raise a blocking objection</li>
</ul>
<p>Any policy that defines decision-making processes must at a minimum address where the proposal may be posted, quorum requirements, number of reviews required, and minimum time delay for feedback. A lack of objections is part of the approval criteria for all decision-making processes.</p>
<p>If conflicts of interest prevent more than a third of the Council from participating in a decision, the Council cannot make that decision unless it follows the process documented in <a href="3392-leadership-council.html#conflicts-of-interest">the &quot;Conflicts of interest&quot; section for how a decision may proceed with conflicts documented</a>. (This is true regardless of any other quorum requirements for the decision-making process in use.) In such a case, the Council should consider appropriate processes and policies to avoid future recurrences of a similar conflict.</p>
<p>The Council may also delegate subsets of its own decision-making purviews via a public policy decision, to teams, other governance structures, or roles created and filled by the Council, such as operational lead, meeting facilitator, or scribe/secretary.</p>
<p>Note that the Council may delegate the drafting of a proposal without necessarily delegating the decision to approve that proposal. This may be necessary in cases of Project-wide policy that intersects the purviews of many teams, or falls outside the purview of any team. This may also help when bootstrapping a new team incrementally.</p>
<h2 id="議程與待辦事項"><a class="header" href="#議程與待辦事項">議程與待辦事項</a></h2>
<p>The Council's agenda and backlog are the primary interface through which the Council tracks and gives progress updates on issues raised by Project members throughout the Project.</p>
<p>To aid in the fairness and effectiveness of the agenda and backlog, the Council must:</p>
<ul>
<li>Use a tool that allows Project members to submit requests to the Council and to receive updates on those requests.</li>
<li>Use a transparent and inclusive process for deciding on the priorities and goals for the upcoming period. This must involve regular check-ins and feedback from all representatives.</li>
<li>Strive to maintain a balance between long-term strategic goals and short-term needs in the backlog and on the agenda.</li>
<li>Be flexible and adaptable and be willing to adjust the backlog and agenda as needed in response to changing circumstances or priorities.</li>
<li>Regularly review and update the backlog to ensure that it accurately reflects the current priorities and goals of the Council.</li>
<li>Follow a clear and consistent process for moving items from the backlog to the agenda, such as delegating responsibility to roles (e.g. meeting facilitator and scribe), and consenting to the agenda at the start of meetings. Any agenda items rejected during the consent process must have their objections documented in the published meeting minutes of the Council.</li>
</ul>
<h2 id="解決僵局"><a class="header" href="#解決僵局">解決僵局</a></h2>
<p>In some situations the Council might need to make an decision urgently and not feel it can construct a proposal in that time that everyone will consent to. In such cases, if everyone agrees that a timely decision they disagree with would be a better outcome than no timely decision at all, the Council may use an alternative decision-making method to attempt to resolve the deadlock. The alternative process is informal, and the council members must still re-affirm their consent to the outcome through the existing decision making process. Council members may still raise objections at any time.</p>
<p>For example, the Council can consent to a vote, then once the vote is complete all of the council members would consent to whatever decision the vote arrived to. The Council should strive to document the perceived advantages and disadvantages for choosing a particular alternative decision-making model.</p>
<p>There is, by design, no mandatory mechanism for deadlock resolution. If the representatives do not all consent to making a decision even if they don't prefer the outcome of that decision, or if any representative feels it is still possible to produce a proposal that will garner the Council's consent, they may always maintain their objections.</p>
<p>If a representative withdraws an objection, or consents to a decision they do not fully agree with (whether as a result of an alternative decision-making process or otherwise), the Council should schedule an evaluation or consider shortening the time until an already scheduled evaluation, and should establish a means of measuring/evaluating the concerns voiced. The results of this review are intended to determine whether the Council should consider changing its prior decision.</p>
<h2 id="回饋與評估"><a class="header" href="#回饋與評估">回饋與評估</a></h2>
<p>All policy decisions should have an evaluation date as part of the policy. Initial evaluation periods should be shorter in duration than subsequent evaluation periods. The length of evaluation periods should be adjusted based on the needs of the situation. Policies that seem to be working well and require few changes should be extended so less time is spent on unnecessary reviews. Policies that have been recently adjusted or called into question should have shortened evaluation periods to ensure they're iterating towards stability more quickly. The Council should establish standardized periods for classes of policy to use as defaults when determining periods for new policy. For instance, roles could have an evaluation date of 3 months initially then 1 year thereafter, while general policy could default to 6 months initially and 2 years thereafter.</p>
<ul>
<li>New policy decisions can always modify or replace existing policies.</li>
<li>Policy decisions must be published in a central location, with version history.</li>
<li>Modifications to the active policy docs should include or link to relevant context for the policy decision, rather than expecting people to find that context later.</li>
</ul>
<h1 id="決策流程之透明度和監督"><a class="header" href="#決策流程之透明度和監督">決策流程之透明度和監督</a></h1>
<p>Decisions made by the Leadership Council will necessarily require varying levels of transparency and oversight based on the kind of decision being made. This section gives guidance on how the Council will seek oversight for its decisions, and what qualifies decisions to be made in private or in public.</p>
<p>This RFC places certain decisions into each category. All decisions not specifically enumerated must use the public policy process. The Council may evolve the categorization through the <a href="decisions-that-the-Council-must-make-via-public-proposal">public policy process</a>.</p>
<p>Decisions made by the Council fall into one of three categories, based on the level of oversight possible and necessary:</p>
<ul>
<li>Decisions that the Council may make internally</li>
<li>Decisions that the Council must necessarily make privately</li>
<li>Decisions that the Council must make via public proposal</li>
</ul>
<h2 id="理事會可在內部做出之決定"><a class="header" href="#理事會可在內部做出之決定">理事會可在內部做出之決定</a></h2>
<p>Some types of operational decisions can be made internally by the Council, with the provision that the Council has a mechanism for community feedback on the decision after it has been made.</p>
<p>Adding a new decision to the list of decisions the Council can make internally requires a public policy decision. Any decisions that impact the structure, decision-makers, or oversight of the Council itself should not be added to this list.</p>
<p>The Council should also strive to avoid establishing de facto unwritten policy via repeated internal decisions in an effort to avoid public proposal. See <a href="3392-leadership-council.html#repetition-and-exceptions">&quot;Repetition and exceptions&quot;</a> for more details.</p>
<p>This list exhaustively enumerates the set of decisions that the Council may make internally:</p>
<ul>
<li>Deciding to start a process that itself will play out in public (e.g. &quot;let's start developing and posting the survey&quot;, &quot;let's draft an RFC for this future public decision&quot;).</li>
<li>Expressing and communicating an official position statement of the Rust Project.</li>
<li>Expressing and communicating the position of the Rust Project directly to another entity, such as the Rust Foundation.</li>
<li>Communicating via Rust Project communication resources (via the blog or all@).</li>
<li>Making most operational decisions about the Council's own internal processes, including how the Council coordinates, the platforms it uses to communicate, where and when it meets, templates used for making and recording decisions (subject to requirements elsewhere in this RFC).</li>
<li>Appointing officers or temporary roles within the Council, for purposes such as leading/facilitating meetings, recording and publishing minutes, obtaining and collating feedback from various parties, etc.<sup class="footnote-reference"><a href="#council-roles">8</a></sup> Note that any such roles (titles, duties, and current holders) must be publicly disclosed and documented.</li>
<li>Inviting specific attendees other than Council representatives to specific Council meetings or discussions, or holding a meeting open to the broader community. (In particular, the Council is encouraged to invite stakeholders of a particular decision to meetings or discussions where said decision is to be discussed.)</li>
<li>Making decisions requested by one or more teams that would be within the normal purviews of those teams to make without a public proposal. (Note that teams can ask for Council input without requesting a Council decision.)</li>
<li>Making one-off judgment calls in areas where the purviews of teams overlap or are ambiguous (though <em>changing</em> the purviews of those teams must be a public policy decision).</li>
<li>Any decision that this RFC or future Council policy specifies as an operational decision.</li>
</ul>
<p>See the <a href="3392-leadership-council.html#mechanisms-for-oversight-and-accountability">accountability section</a> for details on the feedback mechanism for Council decisions.</p>
<h2 id="理事會須私下保密做出之決定"><a class="header" href="#理事會須私下保密做出之決定">理事會須私下保密做出之決定</a></h2>
<p>Some decisions necessarily involve private details of individuals or other entities, and making these details public would have a negative impact both on those individuals or entities (e.g. safety) and on the Project (eroding trust).</p>
<p>This additional constraint should be considered an exceptional case. This does not permit making <a href="3392-leadership-council.html#decisions-that-the-Council-must-make-via-public-proposal">decisions that would require a public proposal per the next section</a>. However, this does permit decisions that the Council makes internally to be kept private, without full information provided for public oversight.</p>
<p>The Council may also decline to make a decision privately, such as if the Council considers the matter outside their purview (and chooses to defer to another team) or believes the matter should be handled publicly. However, even in such a case, the Council still cannot publicly reveal information shared with it in confidence (since otherwise the Council would not be trusted to receive such information). Obvious exceptions exist for imminent threats to safety.</p>
<p>Private decisions must not establish policy. The Council should also strive to avoid establishing de facto unwritten policy via repeated private decisions in an effort to avoid public proposal. See <a href="3392-leadership-council.html#repetition-and-exceptions">&quot;Repetition and exceptions&quot;</a> for more details.</p>
<p>This list exhaustively enumerates the set of decisions that the Council may make either partly or entirely in private:</p>
<ul>
<li>Determining relationships with new industry / Open Source initiatives, that require confidentiality before launching.</li>
<li>Discussing the personal aspects of a dispute between teams that involves some interpersonal dynamics/conflicts.</li>
<li>Participating in contract negotiations on behalf of the Project with third parties (e.g. accepting resources provided to the Project).</li>
<li>Decisions touching on Project-relevant controversial aspects of politics, personal safety, or other topics in which people may not be safe speaking freely in public.</li>
<li>Discussing whether and why a team or individual needs help and support, which may touch on personal matters.</li>
<li>Any decision that this RFC or future Council policy specifies as a private decision.</li>
</ul>
<p>The Council may pull in members of other teams for private discussions leading to either a private or public decision, unless doing so would more broadly expose private information disclosed to the Council without permission. When possible, the Council should attempt to pull in people or teams affected by a decision. This also provides additional oversight.</p>
<p>Some matters may not be fit for full public disclosure while still being fine to share in smaller, more trusted circles (such as with all Project members, with team leads, or with involved/affected parties). The Council should strive to share information with the largest appropriate audiences for that information.</p>
<p>The Council may decide to withhold new decisions or aspects of decisions when it's unclear whether the information is sensitive. However, as time progresses and it becomes clearer who the appropriate audience is or that the appropriate audience has expanded, the council should revisit its information-sharing decisions.</p>
<p>The Council should always loop in the moderation team for matters involving interpersonal conflict/dispute, both because such matters are the purview of the moderation team, and to again provide additional oversight.</p>
<p>The council should evaluate which portions of a decision or its related discussions necessarily need to be private, and should consider whether it can feasibly make non-sensitive portions public, rather than keeping an entire matter private just because one portion of it needs to be. This may include the existence of the discussion, or the general topic, if those details are not themselves sensitive.</p>
<p>Private matters may potentially be able to become public, or partially public, at a later date if they're no longer sensitive. However, some matters may potentially <em>never</em> be able to become public, which means they will never become subject to broader review and oversight. Thus, the Council must exercise caution and prudence before making a private decision.</p>
<p>The Council should make every effort to not make private decisions. The Council should have appropriate additional processes in place to encourage representatives to collectively review such decisions and consider their necessity.</p>
<h2 id="理事會須經公開提案做出之決定"><a class="header" href="#理事會須經公開提案做出之決定">理事會須經公開提案做出之決定</a></h2>
<p>Decisions in this category require the Council to publicly seek feedback from the broader Rust Project <em>in advance</em> of the decision being made. Such decisions are proposed and decided via the appropriate public decision process, currently the RFC process (though the Council may adopt a different public proposal process in the future). The public decision process must require the consent of representatives (either affirmatively or via non-objection), must allow for blocking objections by Council representatives, must provide reasonable time for public evaluation and discussion, and must provide a clear path for public feedback to the Council. </p>
<p>Following the existing RFC process, public proposals must have a minimum time-delay for feedback before the decision takes effect. Any representative may request that the feedback period for a particular decision is extended to at most 20 days total. The Council may make an internal operational decision to extend the feedback period beyond 20 days. The time-delay for feedback starts only when the necessary threshold for approval is otherwise met, including there not being any raised objections. If objections are raised and resolved during the time-delay, the waiting period starts again.</p>
<p>The Leadership Council is expected to evolve over time to meet the evolving needs of the teams, the Rust Project, and the community. Such evolutionary changes may be small or large in scope and require corresponding amounts of oversight. Changes that materially impact the shape of the Council would need to be part of a public decision process.</p>
<p>As an exception to the above, modifications or removals of a single top-level team (other than the moderation team) may occur with the unanimous agreement of the Council absent the representative delegated by that top-level team.</p>
<p>The Council is permitted to have private <em>discussions</em> even on something that ultimately ends up as a public proposal or a publicly disclosed internal decision. The Council may wish to do this if the discussions are sensitive to allow decision participants to speak more frankly and freely. Additionally, in some cases, private information that can't be disclosed may impact an otherwise public decision/proposal; the Council should strive to be as transparent and non-misleading as possible and avoid having opaque decisions where all rationale is private.</p>
<p>Note that all decisions fall into this category unless explicitly designated (via this RFC or future public proposals) to fall into another category, so this list (unlike those in the other two categories) is intentionally vague/broad: it is intended to give guidance on what likely should belong in this category without necessarily being prescriptive.</p>
<ul>
<li>Any decision that has the effect of modifying the list of decision-makers on the Leadership Council or the decision-making process of the Leadership Council. For instance:
<ul>
<li>Changing this list (or this RFC in general).</li>
<li>Modifying the publication and approval process used for the Council's public proposals. Such a proposal must use the existing established process, not the proposed process.</li>
<li>Adding, modifying, or removing policies affecting eligibility for Council representatives.</li>
<li>Adding, modifying, or removing one or more top-level teams. This includes:
<ul>
<li>modifying the purview of a top-level team to such an extent that it meaningfully becomes a different team.</li>
<li>reorganizing the Project such that top-level teams move underneath other teams.</li>
</ul>
</li>
<li>Adding other types of Council representatives other than those delegated by top-level teams.</li>
<li>Adding, modifying, or removing policies regarding Council quorums or the locations in which binding decisions can be made.</li>
</ul>
</li>
<li>Any policy decision, as opposed to a one-off operational decision. (See the <a href="3392-leadership-council.html#the-council-s-decision-making-process">decision-making section</a> for details on policy decisions versus operational decisions.) This includes any decision that binds the decisions of other parts of the Project (e.g. other teams or individuals), effectively serving as an exception to the normal purviews of all teams. Some examples of policy decisions:
<ul>
<li>Modifying or extending existing policies, including those previously made via RFC.</li>
<li>A legal/licensing policy affecting Rust Project software or other work of the Rust Project.</li>
<li>A change to the Code of Conduct.</li>
<li>A policy affecting eligibility for membership in the Rust Project or any team thereof.</li>
<li>A change to how the moderation team moderates Council representatives or the Leadership Council as a whole. Such decisions must be made jointly with the moderation team.</li>
<li>An agreement with another project or organization that makes any ongoing commitments on behalf of the Rust Project. (One-off commitments involving teams that have agreed to those commitments are fine.)</li>
<li>Creating or substantially modifying legal structures (e.g. additional Foundations, changing relationship with the Rust Foundation, partnering with other legal entities).</li>
<li>Making policy decisions requested by one or more teams that would be within the normal purviews of those teams. (Note that teams can ask for Council input without requesting a Council decision.)</li>
<li>Deciding that a class of future decisions always belongs within the Council, rather than being delegated to any other team.</li>
</ul>
</li>
<li>Any decision that this RFC or future Council policy specifies as a public policy decision.</li>
</ul>
<h2 id="利益衝突"><a class="header" href="#利益衝突">利益衝突</a></h2>
<p>A Council representative must not take part in or influence a decision in which they have a conflict of interest.</p>
<p>Potential sources of conflicts of interest include, but are not limited to:</p>
<ul>
<li>Personal: a decision about themselves</li>
<li>Financial: a decision with any substantive financial impact on the representative</li>
<li>Employment or equivalent: a decision involves another person at the same company, or would benefit/harm that company disproportionately more than others</li>
<li>Professional or other affiliation: a decision involves an organization the representative is associated with, such as an industry/professional/standards/governmental organization</li>
<li>Familial/Friendship: a decision about a person the representative cannot be expected to be impartial about, including a conflict of interest of another type through that person (such as a family member's business)</li>
</ul>
<p>Council representatives must promptly disclose conflicts of interest and recuse themselves from affected decisions. Council representatives must also proactively disclose likely sources of potential conflict annually to other representatives and to the moderation team.</p>
<p>Note that conflicts of interest can arise even if a proposal does not name a specific entity. Council representatives cannot, for instance, use their position to tailor requirements in a proposal to disproportionately benefit their employer.</p>
<p>A proposal favored widely across the Rust community does not automatically represent a conflict of interest for a representative merely because that representative's employer or equivalent also favors the general area of that proposal, as long as the proposal does not favor any particular entities. For example, a proposal to improve the security of a particular Rust component is not a conflict of interest for representatives just because their employers generally care about Rust security; however, a proposal to engage specific developers or security experts, or one's compensation being predicated on such a proposal, might still raise a conflict.</p>
<p>The Council may not waive a conflict of interest if one applies, even if the Council considers it minor. However, the Council may evaluate <em>whether</em> a conflict exists at all. Council representatives must raise potential conflicts so that the Council can make such a determination.</p>
<p>The Council may request specific information from a recused representative, and the recused representative may provide that information upon request.</p>
<p>Where possible and practical, the Council should separate decisions to reduce the scope of a conflict of interest. For instance, the Council could separate a decision to arrange access to a class of hardware (without setting specific requirements or selecting vendors) from the decision of which exact hardware to purchase and where to purchase it, if doing so made a conflict of interest only apply to the latter decision.</p>
<p>A representative simultaneously considering the interests of the Rust Project and the interests of any Project team is not necessarily a conflict of interest. In particular, representatives are <em>expected</em> to regularly take part in decisions involving their teams, as delegates from those teams.</p>
<p>In the unlikely event that a proposed decision produces a conflict of interest with enough representatives that the remainder cannot meet a previously established quorum requirement, and the decision must still be made, then either top-level teams must provide alternate representatives for the purposes of the specific decision, or (for public decisions only) the Council may elect to proceed with the decision while publicly documenting all conflicts of interest. (Note that proceeding with a public decision, even with conflicts documented, does not actually eliminate the conflicts or prevent them from influencing the decision; it only allows the public to judge whether the conflicts might have influenced the decision. Eliminating the conflicts entirely is always preferable.) In such a case, the Council should consider appropriate processes and policies to avoid future recurrences of a similar conflict.</p>
<h2 id="確定與更改團隊權責"><a class="header" href="#確定與更改團隊權責">確定與更改團隊權責</a></h2>
<p>The Council can move an area or activity between the purviews of top-level teams either already existing or newly created (other than the moderation team). Though the purview of a given top-level team may be further sub-divided by that team, the Council only moves or adjusts top-level purviews. If a sub-divided purview is moved, the Council will work with the involved teams to coordinate the appropriate next steps. This mechanism should be used when the Council believes the existing team's purview is too broad, such that it is not feasible to expect the team to fulfill the full purview under the current structure.  However, this should not happen when a team only <em>currently</em> lacks resources to perform part of its duties.</p>
<p>The Council also must approve expansions of a top-level team's purview, and must be notified of reductions in a top-level team's purview. This most often happens when a team self-determines that they wish to expand or reduce their purview. This could also happen as part of top-level teams agreeing to adjust purviews between themselves. Council awareness of changes to a purview is necessary, in part, to ensure that the purview can be re-assigned elsewhere or intentionally left unassigned by the Council.</p>
<p>However, teams (individually or jointly) may further delegate their purviews to subteams without approval from the Council. Top-level teams remain accountable for the full purviews assigned to them, even if they delegate (in other words, teams are responsible for ensuring the delegation is successful).</p>
<p>The Council should favor working with teams on alternative strategies prior to shifting purviews between teams, as this is a relatively heavyweight step. It's also worth noting that one of the use cases for this mechanism is shifting a purview previously delegated to a team that functionally no longer exists (for instance, because no one on the team has time), potentially on a relatively temporary basis until people arrive with the time and ability to re-create that team. This section of the RFC intentionally does not put constraints on the Council for exactly how (or whether) this consultation should happen.</p>
<h1 id="監督與問責機制"><a class="header" href="#監督與問責機制">監督與問責機制</a></h1>
<p>The following are various mechanisms that the Council uses to keep itself and others accountable.</p>
<h2 id="確保能追究理事會之責任"><a class="header" href="#確保能追究理事會之責任">確保能追究理事會之責任</a></h2>
<p>The Council must publicly ensure that the wider Project and community's expectations of the Council are consistently being met. This should be done both by adjusting the policies, procedures, and outcomes of the Council as well as education of the Project and community when their expectations are not aligned with the reality.</p>
<p>To achieve this, in addition to rotating representatives and adopting a &quot;public by default&quot; orientation, the Council must regularly (at least on a quarterly basis) provide some sort of widely available public communication on their activities as well as an evaluation of how well the Council is functioning using the list of duties, expectations, and constraints as the criteria for this evaluation.</p>
<p>Each year, the Council must solicit feedback on whether the Council is serving its purpose effectively from all willing and able Project members and openly discuss this feedback in a forum that allows and encourages active participation from all Project members. To do so, the Council and other Project members consult the high-level duties, expectations, and constraints listed in this RFC and any subsequent revisions thereof to determine if the Council is meeting its duties and obligations.</p>
<p>In addition, it is every representative's <em>individual</em> responsibility to watch for, call out, and refuse to go along with failures to follow this RFC, other Council policies and procedures, or any other aspects of Council accountability. Representatives should strive to actively avoid <a href="https://en.wikipedia.org/wiki/Diffusion_of_responsibility">&quot;diffusion of responsibility&quot;</a>, the phenomenon in which a group of people collectively fail to do something because each individual member (consciously or subconsciously) believes that someone else will do so. The Council may also wish to designate a specific role with the responsibility of handling and monitoring procedural matters, and in particular raising procedural points of order, though others can and should still do so as well.</p>
<p>If any part of the above process comes to the conclusion that the Council is <em>not</em> meeting its obligations, then a plan for how the Council will change to better be able to meet their obligations must be presented as soon as possible. This may require an RFC changing charter or similar, a rotation of representatives, or other substantive changes. Any plan should have concrete measures for how the Council and/or Rust governance as a whole will evolve in light of the previous year's experience.</p>
<h2 id="確保能追究理事會代表之責任"><a class="header" href="#確保能追究理事會代表之責任">確保能追究理事會代表之責任</a></h2>
<p>Council representatives should participate in regular feedback with each other and with their respective top-level team (the nature of which is outside the scope of this RFC) to reflect on how well they are fulfilling their duties as representatives. The goal of the feedback session is to help representatives better understand how they can better serve the Project. This feedback must be shared with all representatives, all members of the representative's top-level team, and with the moderation team. This feedback should ask for both what representatives have done well and what they could have done better.</p>
<p>Separately, representatives should also be open to private feedback from their teams and fellow representatives at any time, and should regularly engage in self-reflection about their role and efficacy on the Council.</p>
<p>Artifacts from these feedback processes must never be made public to ensure a safe and open process. The Council should also reflect on and adjust the feedback process if the results do not lead to positive change.</p>
<p>If other members of the Council feel that a Council representative is not collaborating well with the rest of the Council, they should talk to that representative, and if necessary to that representative's team. Council representatives should bring in moderation/mediation resources as needed to facilitate those conversations. Moderation can help resolve the issue, and/or determine if the issue is actionable and motivates some level of escalation.</p>
<p>While it is out of scope for this RFC to specify how individual teams ensure their representatives are held accountable, we encourage teams to use the above mechanisms as inspiration for their own policies and procedures.</p>
<h2 id="確保能追究團隊之責任"><a class="header" href="#確保能追究團隊之責任">確保能追究團隊之責任</a></h2>
<p>Teams regularly coordinate and cooperate with each other, and have conversations about their needs; under normal circumstances the Council must respect the autonomy of individual teams.</p>
<p>However, the Council serves as a means for teams to jointly hold each other accountable, to one another and to the Project as a whole. The Council can:</p>
<ul>
<li>Ask a team to reconsider a decision that failed to take the considerations of other teams or the Project as a whole into consideration.</li>
<li>Encourage teams to establish processes that more regularly take other teams into consideration.</li>
<li>Ensure a shared understanding of teams' purviews.</li>
<li>Ensure teams are willing and able to fulfill those purviews.</li>
<li>Establish new teams that split a team's purview up into more manageable chunks.</li>
</ul>
<p>The accountability process must not be punitive, and the process must be done with the active collaboration of the teams in question.</p>
<p>In extreme circumstances where teams are willfully choosing to not act in good faith with regards to the wider Project, the Council has the authority to change a team's purview, move some subset of a team's purview to another team, or remove a team entirely. This is done through the Council's regular decision making process. (This does not apply to the moderation team; see the next section for accountability between the Council and moderation team.)</p>
<h1 id="審核分歧與衝突"><a class="header" href="#審核分歧與衝突">審核、分歧與衝突</a></h1>
<p>This section describes the roles of the Leadership Council and the moderation team in helping resolve disagreements and conflicts, as well as the interactions between those teams.</p>
<p>Disagreements and conflicts fall on a spectrum of interpersonal interaction. Disagreements are more factual and/or technical misalignments, while conflicts are more social or relational roadblocks to collaboration. Many interactions might display aspects of both disagreement and conflict. The Council can help with aspects of disagreement, while aspects of conflict are the purview of the moderation team.</p>
<p>This RFC does not specify moderation policy in general, only the portion of it necessary to specify interactions with the Council and the checks and balances between the Council and the moderation team. General moderation policy is out of scope for this RFC.</p>
<p>Much of the work of the Rust Project involves collaboration with other people, all of whom care deeply about their work. It's normal for people to disagree, and to feel strongly about that disagreement. Disagreement can also be a powerful tool for surfacing and addressing issues, and ideally, people who disagree can collaboratively and (mostly) amicably explore those disagreements without escalating into interpersonal conflicts.</p>
<p>Situations where disagreements and conflicts arise may be complex. Disagreements can escalate into conflicts, and conflicts can de-escalate into disagreements. If the distinction between a disagreement and a conflict is not clear in the situation, or if participants disagree, assume the situation is a conflict.</p>
<p>In the event of a conflict, involved parties should reach out to the moderation team to help resolve the conflict as soon as possible. Time is a critical resource in attempting to resolve a conflict before it gets worse or causes more harm.</p>
<h2 id="團隊間之分歧"><a class="header" href="#團隊間之分歧">團隊間之分歧</a></h2>
<p>Where possible, teams should attempt to resolve disagreements on their own, with assistance from the Council as needed. The Council can make judgment calls to settle disagreements, but teams need to maintain good working relationships with each other to avoid persistent disagreements or escalations into conflicts.</p>
<p>Potential resolution paths for disagreements between teams could include selecting a previously discussed option, devising a new option, deciding whose purview the decision falls in, or deciding that the decision is outside the purviews of both teams and leaving it to the Council to find a new home for that work.</p>
<h2 id="涉及團隊或專案成員之衝突"><a class="header" href="#涉及團隊或專案成員之衝突">涉及團隊或專案成員之衝突</a></h2>
<p>Conflicts involving teams or Project members should be brought to the moderation team as soon as possible. The Council can help mitigate the impact of those conflicts on pending/urgent decisions, but the moderation team is responsible for helping with conflicts and interpersonal issues, across teams or otherwise.</p>
<p>Individuals or teams may also voluntarily engage in other processes to address conflicts or interpersonal issues, such as non-binding external mediation. Individuals or teams should keep the moderation team in the loop when doing so, and should seek guidance from the moderation team regarding appropriate resources or approaches for doing so. Individuals or teams must not use resources that would produce a conflict of interest.</p>
<h2 id="審核人代表團"><a class="header" href="#審核人代表團">審核人代表團</a></h2>
<p>The moderation team must at all times maintain a publicly documented list of &quot;contingent moderators&quot;, who must be approved by both the moderation team and the Council via internal consent decision. The moderation team and contingent moderation team should both consist of at least three members each. The contingent moderators must be:</p>
<ul>
<li>Not part of the current moderation team <em>or</em> the Leadership Council.</li>
<li>Widely trusted by Rust Project members as jointly determined by the Council and moderation team; this will often mean they're already part of the Project in some capacity.</li>
<li>Qualified to do moderation work and <a href="3392-leadership-council.html#audits">audits</a> as jointly determined by the Council and moderation team. More detailed criteria and guidelines will be established by moderation policy, which is out of scope for this RFC.</li>
<li>Willing to serve as contingent moderators: willing to do audits, and willing to do interim moderation work if the moderation team dissolves or becomes unavailable, until they can appoint new full moderators. (The contingent moderators are not expected to be willing to do moderation work long-term.)</li>
<li>Willing to stay familiar with moderation policy and procedure to the standards expected of a moderation team member (including any associated training). Contingent moderators should receive the same opportunities for training as the moderation team where possible.</li>
</ul>
<p>The need for contingent moderators arises in a high-tension situation, and the Project and Council must be prepared to trust them to step into that situation. Choosing people known and trusted by the rest of the Project helps lower tensions in that situation.</p>
<p>Moderation is a high-burnout activity, and individual moderators or the moderation team may find itself wishing to step away from that work. Note that one or more individual moderators may always choose to step down, in which case the moderation team should identify and bring in new moderators to fill any gaps or shortfalls; if the moderation team asks a contingent moderator to become a full moderator, the team should then appoint a new contingent moderator. An individual moderator who stepped down <em>may</em> be selected as a contingent moderator. If the moderation team as a whole becomes simultaneously unavailable (as determined jointly by the Council and contingent moderators via internal consent decision), or chooses to step down simultaneously, the contingent moderators become the interim moderation team and must promptly appoint new contingent moderators and start seeking new full moderators.</p>
<p>As the contingent moderator role does not have any regular required activities outside of exceptional situations, those appointed to that role must have regular check-ins with the moderation team, to reconfirm that they're still willing to serve in that role, and to avoid a circumstance in which the contingent moderators are abruptly needed and turn out to be unavailable.</p>
<h2 id="審核團隊之政策與程序"><a class="header" href="#審核團隊之政策與程序">審核團隊之政策與程序</a></h2>
<p>The moderation team has a duty to have robust policies and procedures in place. The Council provides oversight and assistance to ensure that the moderation team has those policies and procedures and that they are sufficiently robust.</p>
<p>The Council may provide feedback to the moderation team and the moderation team is required to consider all feedback received. If the Council feels the moderation team has not followed moderation policies and procedures, the Council may <a href="3392-leadership-council.html#audits">require an audit</a> by the contingent moderators. However, the Council may not overrule a moderation decision or policy.</p>
<h2 id="稽核"><a class="header" href="#稽核">稽核</a></h2>
<p>If any Council member believes a moderation decision (or series of decisions) has not followed the moderation team's policies and procedures, they should promptly inform the moderation team. The Council and moderation team should then engage with each other, discuss and understand these concerns, and work to address them.</p>
<p>One of the mechanisms this RFC provides for checking the moderation team's actions in a privacy-preserving manner is an audit mechanism. In any case where any Council member believes moderation team actions have not followed documented policies or procedures, the Council member may decide to initiate the audit process. (In particular, they might do this in response to a report from a community member involved in a moderation situation.) This happens <em>in addition</em> to the above engagement and conversation; it is not a replacement for direct communication between the Council and the moderation team.</p>
<p>In an audit, the contingent moderation team works with the moderation team to establish whether the moderation team followed documented policies and procedures. This mechanism necessarily involves the contingent moderation team using their own judgment to evaluate moderation policy, specific evidence or communications, and corresponding moderation actions or proposed actions. However, this mechanism is not intended to second-guess the actions themselves; the audit mechanism focuses on establishing whether the moderation team is acting according to its established policy and procedures.</p>
<p>The contingent moderators also reach out to the Council to find out any additional context they might need.</p>
<p>Moderation processes and audits both take time, and must be performed with diligence. However, the Council, contingent moderators, and moderation team should all aim to communicate their concerns and expectations to each other in a reasonably timely fashion and maintain open lines of communication.</p>
<p>Contingent moderators must not take part in decisions or audits for which they have a conflict of interest. Contingent moderators must not have access to private information provided to moderation before the contingent moderator was publicly listed as part of the contingent moderation team; this gives people speaking with the moderation team the opportunity to evaluate potential concerns or conflicts of interest.</p>
<p>The discussions with the Council and the contingent moderation team may discover that the moderation team had to make an exception in policy for a particular case, as there was an unexpected condition in policies or that there was contextual information that couldn't be incorporated in policy. This is an expected scenario that merits additional scrutiny by the contingent moderation team on the rationale for making an exception and the process for deciding the necessity to make an exception, but is not inherently a violation of moderation team responsibilities.</p>
<p>As the audit process and the Council/moderation discussions proceed, the moderation team may decide to alter moderation policies and/or change the outcome of specific moderation decisions or proposed decisions. This is solely a decision for the moderation team to make.</p>
<p>The contingent moderation team must report the results of the audit to the moderation team and the Council for their review. This must not include any details that may reveal private information, either directly or indirectly. Together with the discussions with the moderation team, this should aim to address the concerns of the Council.</p>
<h2 id="最終問責機制"><a class="header" href="#最終問責機制">最終問責機制</a></h2>
<p>The Leadership Council and moderation team each have substantial power within the Rust Project. This RFC provides many tools by which they can work out conflicts. This section outlines the last-resort mechanisms by which those teams can hold each other accountable. This section is written in the hopes that it will never be needed, and that teams will make every possible effort to resolve conflicts without reaching this point.</p>
<p>If the Council believes there is a systemic problem with the moderation team (whether based on an audit report from the contingent moderation team or otherwise), and the Council and moderation team cannot voluntarily come to agreement on how to address the situation, then as a <strong>last resort</strong>, the Council (by unanimous decision) may simultaneously dissolve itself and the moderation team. The top-level teams must then appoint new representatives to the Council, and the contingent moderation team becomes the new interim moderation team.</p>
<p>Conversely, if the moderation team believes the Council has a systemic problem, and the Council and moderation team cannot voluntarily come to agreement on how to address the situation, then as a <strong>last resort</strong>, the moderation team (by unanimous decision) may simultaneously dissolve itself and the Council. This process can only be enacted if there are at least three moderation team members. The top-level teams must then appoint new representatives to the Council, and the contingent moderation team becomes the new interim moderation team.</p>
<p>The moderation team's representative is recused from the decision to dissolve the Council and moderation team to avoid conflicts of interest, though that representative must still step down as well.</p>
<p>The removed representatives and moderators may not serve on either the Council or the moderation team for at least one year.</p>
<p>By default, the new Council and interim moderation team will take responsibility for clearly communicating the transition.</p>
<p>This mechanism is an absolute last resort. It will almost certainly produce suboptimal outcomes, to say the least. If situations escalate to this outcome, many things have gone <em>horribly</em> wrong, and those cleaning up the aftermath should endeavor to prevent it from ever happening again. The indication (by either the moderation team or the Council) that the situation <em>might</em> escalate to this point should be considered a strong signal to come to the table and find a way to do &quot;Something Else which is Not That&quot; to avoid the situation.</p>
<h2 id="涉及專案成員之審核措施"><a class="header" href="#涉及專案成員之審核措施">涉及專案成員之審核措施</a></h2>
<p>The moderation team, in the course of doing moderation work, necessarily requires the ability to take action not just against members of the Rust community but also against members of the Rust Project. Those actions may span the ladder of escalation all the way from a conversation to removal from the Project. This puts the moderation team in a position of power and trust. This RFC seeks to provide appropriate accountability and cross-checks for the moderation team, as well as for the Council.</p>
<p>If the moderation team plans to enact externally visible sanctions against any member of the Rust Project (anything that would create a conspicuous absence, such as removal from a role, or exclusion from participation in a Project space for more than a week), then any party may request that an <a href="3392-leadership-council.html#audits">audit</a> take place by reaching out to either the Council or contingent moderators, and that audit will be automatically granted.</p>
<p>For the first year after the ratification of this RFC, audits are automatically performed even without a request, to ensure the process is functional. After that time, the Council and moderation team will jointly review and decide whether to renew this provision.</p>
<p>When the moderation team sends a warning to a Project member, or sends a notification of moderation action regarding a Project member, that message will mention the option of requesting an audit.</p>
<p>Conflicts regarding Project members should be brought to the moderation team as soon as possible.</p>
<h2 id="涉及理事會代表之衝突"><a class="header" href="#涉及理事會代表之衝突">涉及理事會代表之衝突</a></h2>
<p>Conflicts involving Council representatives, or alternates, follow the same process as conflicts involving Project members. The moderation team has the same ability to moderate representatives or alternates as any other member of the Project, including the required <a href="3392-leadership-council.html#audits">audit</a> by the contingent moderators for any externally visible sanction. This remains subject to the same accountability mechanisms as for other decisions of the moderation team.</p>
<p>In addition to the range of moderation actions already available, the moderation team may take the following additional actions for representatives or alternates as a near-last resort, as a lesser step on the ladder of escalation than removing a member from the Project entirely. These actions are not generally specific to the Council, and apply to other Rust teams as well.</p>
<ul>
<li>The moderation team may decide to remove a representative from the Council. The top-level team represented by that representative should delegate a new representative to serve the remainder of the term, starting immediately.</li>
<li>The moderation team may decide to prevent a Project member from becoming a Council representative.</li>
<li>The moderation team and Council (excluding the affected parties) may jointly decide (as a private operational consent decision) to apply other sanctions limiting the representative's involvement in the Council. (In this scenario, representatives are not excluded if they have a conflict of interest, as the entire Council will have to cooperate to make the sanctions effective. If the conflicts of interest thus prevent applying these partial sanctions, the moderation team always has the option of full sanctions such as removal.)</li>
</ul>
<p>All of these also trigger a required audit. The Council must also be notified of any moderation actions involving representatives or alternates, or actions directly preventing people from becoming representatives.</p>
<h2 id="涉及審核團隊成員之衝突"><a class="header" href="#涉及審核團隊成員之衝突">涉及審核團隊成員之衝突</a></h2>
<p>Conflicts involving a member of the moderation team will be handled by the remaining members of the moderation team (minus any with a conflict of interest), <em>together with</em> the contingent moderation team to provide additional oversight. Any member of the moderation or contingent moderation team should confer with the Council if there is a more systemic issue within the moderation team. The contingent moderators must audit this decision and must provide an audit report to the Council and moderation team.</p>
<h1 id="本案之批准"><a class="header" href="#本案之批准">本案之批准</a></h1>
<p>自 2021 年 11 月以來，下列成員實質上已在專案擔任中領導角色：所有 Core 團隊成員、所有審核團隊成員、Rust Foundation 理事會（board）上的所有專案代表以及「一級」團隊的負責人：</p>
<ul>
<li>編譯器</li>
<li>Crates.io</li>
<li>開發工具</li>
<li>基礎架構</li>
<li>語言</li>
<li>函式庫</li>
<li>審核（已包含在上方）</li>
<li>發佈</li>
</ul>
<p>此 RFC 將以標準 RFC 程序審批，由前述實質上的領導層成員來批准。這些成員還應代表專案中其他成員提出異議，更具體來說，團隊負責人應徵求他的團隊和子團隊的回饋。</p>
<h1 id="附註"><a class="header" href="#附註">附註</a></h1>
<div class="footnote-definition" id="core"><sup class="footnote-definition-label">1</sup>
<p>Unlike in some other Open Source projects, the Rust Project's &quot;core team&quot; does not refer to a group that decides the technical direction of the Project. As explained in more detail elsewhere in the RFC, the Rust Project distributes decision-making to many different teams who have responsibility for their specific purview. For example, the compiler team is in charge of the Rust compiler, the language team is in charge of language evolution, etc. This is part of why this RFC discontinues use of the term &quot;core team&quot;.</p>
</div>
<div class="footnote-definition" id="authority"><sup class="footnote-definition-label">2</sup>
<p>The term 'authority' here refers to the powers and responsibilities the Council has to ensure the success of the Rust Project. This RFC lays out the limits of these powers, so that the Council will delegate the authority it has to teams responsible for the concerns of the Project. These concerns may include - but are not limited to - product vision, day-to-day procedures, engineering decisions, mentoring, and marketing.</p>
</div>
<div class="footnote-definition" id="teams"><sup class="footnote-definition-label">3</sup>
<p>Throughout this document, &quot;teams&quot; includes subteams, working groups, project groups, initiatives, and all other forms of official collaboration structures within the Project. &quot;Subteams&quot; includes all forms of collaboration structures that report up through a team.</p>
</div>
<div class="footnote-definition" id="under-multiple-teams"><sup class="footnote-definition-label">4</sup>
<p>Subteams or individuals that fall under multiple top-level teams should not get disproportionate representation by having multiple representatives speaking for them on the Council. Whenever a &quot;diamond&quot; structure like this exists anywhere in the organization, the teams involved in that structure should strive to avoid ambiguity or diffusion of responsibility, and ensure people and teams know what paths they should use to raise issues and provide feedback.</p>
</div>
<div class="footnote-definition" id="bootstrapping-new-teams"><sup class="footnote-definition-label">6</sup>
<p>The Council consists only of the representatives provided to it by top-level teams, and cannot appoint new ad hoc members to itself. However, if the Council identifies a gap in the project, it can create a new top-level team. In particular, the Council can bootstrap the creation of a team to address a problem for which the Project doesn't currently have coordinated/organized expertise and for which the Council doesn't know the right solution structure to charter a team solving it. In that case, the Council could bring together a team whose purview is to explore the solution-space for that problem, determine the right solution, and to return to the Council with a proposal and charter. That team would then provide a representative to the Council, who can work with the Council on aspects of that problem and solution.</p>
</div>
<div class="footnote-definition" id="number-of-representatives"><sup class="footnote-definition-label">5</sup>
<p>This also effectively constrains the number of Council representatives to the same range. Note that this constraint is independently important.</p>
</div>
<div class="footnote-definition" id="representative-selection"><sup class="footnote-definition-label">7</sup>
<p>最終整體來說，作為一位理事會代表是為了服務個別的團隊以及 Rust 計畫。儘管此 RFC 的作者希望這個職位能夠滿足並且吸引任何足以勝任這份工作的人，我們仍然希望它不被視為是用來爭奪地位的職位。</p>
</div>
<div class="footnote-definition" id="council-roles"><sup class="footnote-definition-label">8</sup>
<p>The Council is not required to assign such roles exclusively to Council representatives; the Council may appoint any willing Project member. Such roles do not constitute membership in the Council for purposes such as decision-making.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Commit: <a href="https://github.com/rust-lang/rfcs/blob/075f4b30f5c33315163c8e6a75e3210af6229ded/text/3392-leadership-council/alternatives.md">The commit link this page based on</a></li>
</ul>
<h1 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h1>
<p>The design space for governance is quite large. This section only attempts to address the largest and most consequential alternatives to the design decisions presented in this RFC. This section presents each such alternative along with justifications for why they were not selected.</p>
<h2 id="broader-governance-changes-in-this-rfc"><a class="header" href="#broader-governance-changes-in-this-rfc">Broader governance changes in this RFC</a></h2>
<p>We considered doing <em>more</em> in this RFC to set up initial governance structures and improve existing governance structures. In particular, we considered changes to the existing set of top-level teams.</p>
<p>However, we felt strongly that anything that <em>could</em> be deferred to the Council should be, and that this RFC should focus on defining and delimiting the Council itself and its interactions with the rest of the Project. We felt it would go beyond the mandate of the transitional leadership structure to do much more than just architecting long-term leadership.</p>
<p>We also felt that further incremental evolutions would become much easier with the structures proposed by this RFC in place.</p>
<p>We recognize that changes to the set of top-level teams will prove especially difficult. However, we felt that the interim leadership group (including top-level team leads) would have that problem in common with the Council. Furthermore, we found that many members and leads of top-level teams were if anything <em>enthusiastic</em> about potential systematic improvements in this area, rather than resistant to them, even when such changes involved their own teams.</p>
<p>Apart from that, developing and building consensus on this RFC already represented a massive time investment by many people, and making it larger would make it take even longer.</p>
<h2 id="alternative-council-structures-and-non-representative-council-members"><a class="header" href="#alternative-council-structures-and-non-representative-council-members">Alternative Council structures and non-representative Council members</a></h2>
<p>As an alternative to Council representatives exclusively being the representatives of top-level teams, we extensively considered other structures, whether in addition or in place of that. For instance, the Council could appoint additional members, or appoint successors, or some or all Council representatives could be elected by the Project. Such approaches could potentially make it easier to represent aspects or constituencies of the Project not <em>yet</em> represented by existing top-level teams, before even the nascent structures of those teams started to take shape.</p>
<p>Specific variants we decided not to pursue:</p>
<h3 id="non-representative-council-structures"><a class="header" href="#non-representative-council-structures">Non-representative Council structures</a></h3>
<p>Alternative structures in which Council members are not representatives of top-level teams would have various drawbacks:</p>
<ul>
<li>Any structure that does not guarantee each team a representative would provide less comprehensive and balanced representation for existing teams.</li>
<li>A structure not based on team-appointed representatives would make it harder to change representatives quickly and easily in a pinch, such as in response to changes in personal circumstances, or changes in a representative's affiliations that cause a violation of the limits placed on shared affiliations.</li>
<li>Some variants of this (such as Council-appointed additional members or Council-appointed successors) would steer the Council towards a more self-perpetuating nature that we wanted to avoid.</li>
</ul>
<p>Ultimately, we addressed part of this issue by instead allowing the Council to easily create provisional teams (so as to introduce additional <em>representatives</em> on the Council), and then made room for the Council to further evolve its structure in the future by consent.</p>
<h3 id="elections"><a class="header" href="#elections">Elections</a></h3>
<p>Any structure involving elections would raise additional problems:</p>
<ul>
<li>Accurately determining the electorate: who precisely qualifies as being &quot;part of the Rust Project&quot;?
<ul>
<li>Many people have intuitive ideas about this, and such intuitions don't currently cause problems because we don't tie much of substance to that status. However, such intuitive definitions cause serious issues if membership in the Project determines eligibility to vote.</li>
</ul>
</li>
<li>The usual problems of popularity contests: not all folks doing organizational/coordinative work are especially visible/glamorous/popular, and those doing visible/glamorous/popular work may serve the Project better doing that work rather than reallocating their time towards organizational/coordinative work.</li>
<li>Elections motivate some form of campaigning.</li>
<li>A robust election system would introduce more process complexity, both directly for the voting process, indirectly by making it harder to rotate/replace candidates in a pinch or supply alternates/backups.</li>
<li>Elections would introduce more difficult challenges when needing to change representatives quickly and easily in a pinch, such as in response to changes in personal circumstances, or changes in affiliation that run into the limits upon shared affiliations. The voters will have chosen candidates, and it's harder to go back to the electorate for new candidates, so there would have to be (for example) careful rules for selecting backup candidates based on the next lower number of votes.</li>
<li>Elections, no matter what voting system they use, inherently ignore the consent of many constituents.</li>
<li>Simpler election structures would not guarantee teams a representative, and would thus provide less comprehensive and balanced representation for existing teams. Providing more comprehensive/proportional representation of teams would add even more complexity to the election system.
<ul>
<li>In particular, if the people in the project fall into teams in a vaguely Pareto-style structure (a small number of teams contain a large number of people), a simple election structure may result in many teams having <em>no</em> representation.</li>
</ul>
</li>
</ul>
<p>We felt that we could better improve people's routes to be heard and taken into account by ensuring all governance structures and all Project members are connected through parent teams, and thus that every member of the Project has at least one representative on the Council.</p>
<h2 id="referendums"><a class="header" href="#referendums">Referendums</a></h2>
<p>We considered introducing a full-fledged referendum system, by which proposals could be introduced, supported, and voted on by the Project as a whole. This would sidestep issues of ensuring proposals get considered and added to the Council's agenda, and would make it easier to make substantial changes not aligned with the existing Council (for better or for worse); it would also serve as an addition check and balance on the Council.</p>
<p>However:</p>
<ul>
<li>This would have all the problems mentioned above about determining constituency in the Project.</li>
<li>This would also be a <em>complex</em> new structure introduced entirely in this RFC (rather than later by the Council).
<ul>
<li>This mechanism and its eligibility and corner cases would need to be <em>very</em> precisely specified, as it would often be invoked in situations with high tension and a need for a timely and authoritative decision.</li>
</ul>
</li>
<li>Voting mechanisms, no matter what voting system they use, inherently ignore the consent of many constituents.
<ul>
<li>Voting mechanisms trend towards picking winners and losers, rather than consensus-seeking and finding ways to meet <em>everyone's</em> needs.</li>
</ul>
</li>
<li>If such a mechanism were trivial to initiate, it could become a dysfunctional pseudo-&quot;communication&quot; mechanism in its own right, substituting for healthier communication and more consent-driven actions. It would, effectively, escalate problems into public dirty laundry, making it <em>harder</em> to resolve smaller problems. In addition, reporting on such events can generate unwarranted news like &quot;Rust considers X&quot; even if X has no meaningful support.</li>
<li>If such a mechanism were not trivial to initiate, the type of grassroots organizing required to successfully raise and pass such a referendum would produce better effects by working through teams, when the Project is well-aligned.</li>
<li>Conversely, if the Project has substantial issues aligning with its leadership, making <em>individual</em> decisions doesn't solve the underlying problem with Project health.</li>
</ul>
<p>We chose to instead provide extensive checks on the Council itself, and mechanisms to ensure feedback and alignment between the Council and the Project, as well as a last-resort mechanism, rather than providing an ongoing mechanism to make or override <em>individual</em> Project-wide decisions.</p>
<h2 id="alternative-checks-and-balances-between-the-leadership-council-and-the-project"><a class="header" href="#alternative-checks-and-balances-between-the-leadership-council-and-the-project">Alternative checks and balances between the Leadership Council and the Project</a></h2>
<p>We considered many structures for additional checks and balances between the Leadership Council and the Project:</p>
<ul>
<li>We considered &quot;vote of no confidence&quot; mechanisms, but these would have many of the same problems as referendums, including determining the electorate, being either too difficult or too easy to initiate, and tending towards escalation rather than resolution.</li>
<li>We considered arrangements in which members of teams could directly raise objections to Council RFCs. However, this added complexity for something that the consent decision-making mechanism <em>should</em> make redundant.</li>
<li>We considered more formal feedback systems that could provide checks on <em>individual</em> Council decisions. However, any such mechanisms would also make it difficult to make timely decisions, and the blocking mechanisms would cause problems if they were either too easy or too difficult to initiate.</li>
</ul>
<h2 id="alternative-checks-and-balances-between-the-leadership-council-and-the-moderation-team"><a class="header" href="#alternative-checks-and-balances-between-the-leadership-council-and-the-moderation-team">Alternative checks and balances between the Leadership Council and the moderation team</a></h2>
<p>We went through substantial tuning on the checks and balances between the Leadership Council and the moderation team:</p>
<ul>
<li>We considered making audits not automatically granted, and instead having the Council decide whether to grant an audit request. However, this would raise fairness questions for how the Council decides when to grant an audit based on limited information, as well as motivating procedural delays to give time for such an evaluation. We also felt that automatic audits (at least initially) would provide an opportunity to thoroughly test and evaluate the audit process.</li>
<li>We also considered structures using separate auditors rather than using the &quot;contingent moderators&quot; as auditors, but this raised <em>severe</em> trust issues with sharing private moderation information with those auditors.</li>
</ul>
<h2 id="launching-pad-alternatives"><a class="header" href="#launching-pad-alternatives">Launching pad alternatives</a></h2>
<p>We considered other alternate structures apart from the &quot;launching pad&quot;, for handling existing teams that aren't attached to the rest of the team structure. For instance, we considered attaching such teams directly to the Council; however, this would have required special-case handling for representation that would start to look a lot like the launching pad, but with more coordination work attached to the Council.</p>
<p>We also considered options in which we <em>didn't</em> connect those teams, and permitted &quot;disconnected&quot; working groups and similar. This would require less transition, but would leave many Project members unrepresented and disenfranchised.</p>
<p>We felt that we could best improve people's routes to be heard and taken into account by ensuring all governance structures and all Project members are connected through parent teams.</p>
<p>We considered giving additional purviews to the launching pad, such as contributing to team organization and structure, best practices, or processes. However, the launching pad is already the one exception in which this RFC creates a new team, and we already have concerns about successfully staffing that team; we don't want to add further complexity beyond that in this RFC. The Council has the option of changing the launching pad's purview in the future.</p>
<p>We considered the name &quot;landing pad&quot; (a place for unattached teams to land) instead of &quot;launching pad&quot;, but we felt that &quot;launching pad&quot; better conveyed the idea of incubating teams and helping them thrive rather than just serving as a holding area.</p>
<h2 id="double-linking"><a class="header" href="#double-linking">Double-linking</a></h2>
<p>We considered adopting a &quot;double-linking&quot; structure between the Council and top-level teams, in which teams have two representatives on the Council, one more responsible for connecting team-to-Council and the other more responsible for connecting Council-to-team. Such redundancy could provide a firmer connection between the Council and teams, making it <em>much</em> less likely that concerns from teams would fail to propagate to the Council and vice versa. However:</p>
<ul>
<li>Such a structure would require either an unmanageable number of Council members or far fewer than our current number of top-level teams (and we did not want to change the number of top-level teams in this RFC, or limit the number of top-level teams that strongly).</li>
<li>This would require substantial changes to the structures of top-level teams themselves to permit such linking, and such structural changes would go beyond the remit of this RFC.</li>
<li>Some models of double-linking would have one of the representatives determined by the team and the other by the Council; such a model would add complexity to the membership of the Council, such that members were not exclusively the representatives of top-level teams, which would have many of the downsides of such variations mentioned above, notably giving the Council a more self-perpetuating nature.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Commit: <a href="https://github.com/rust-lang/rfcs/blob/075f4b30f5c33315163c8e6a75e3210af6229ded/text/3392-leadership-council/initial-work-of-the-council.md">The commit link this page based on</a></li>
</ul>
<h1 id="recommendations-for-initial-work-of-the-council"><a class="header" href="#recommendations-for-initial-work-of-the-council">Recommendations for initial work of the Council</a></h1>
<p>In the course of developing this RFC, and thinking extensively about the structure and operation of the Council, the interim leadership team also identified many other tasks that fell outside the scope of this RFC, and explicitly decided to defer those tasks to the new Council. This section documents those tasks, as a suggested starting point for bootstrapping the work of the Council. None of these are binding suggestions, and the Council can freely set and prioritize its own agenda; this section serves as a public, transparent handoff of knowledge and proposals to the Leadership Council.</p>
<p>Some of these tasks represent meta-level decisions about the processes of the Council, and we chose not to make those decisions in this RFC to avoid enshrining a particular structure rather than deferring to those who will be working regularly with that structure. The remaining tasks represent a partial todo list of long-standing tasks that fall within the Council's purview, insofar as they have fallen through the gaps between team purviews. Some of these tasks should be delegated by the Council rather than worked on directly by the Council. The inclusion of a task in this list doesn't change what type of decision-making process is required for it; some of these may be Council-internal operational decisions or private operational decisions, while others will require a public policy process.</p>
<p>These are in no particular order, other than that meta-level decisions about processes for making decisions will need to happen before decisions relying on those processes.</p>
<h2 id="meta-level-decisions-about-processes-and-policies"><a class="header" href="#meta-level-decisions-about-processes-and-policies">Meta-level decisions about processes and policies</a></h2>
<ul>
<li>Determining where, when, and how frequently the Council meets.</li>
<li>Establishing processes for where the Council makes decisions, both synchronously (in meetings) and asynchronously.</li>
<li>Writing and agreeing on templates for decisions, that help guide the Council to remember and follow process steps.</li>
<li>Establishing specific processes around Council transparency, including records of decisions, minutes of meetings, the locations where these get published, and similar.</li>
<li>Establishing a process for appointing the &quot;Project directors&quot; to the Rust Foundation board in a timely fashion. The Council will need to make such appointments soon after formation, and will also need to help ensure continuity across the transition.</li>
<li>Establishing processes and conventions for the Council's regular review of its policy decisions. In particular, establishing expectations for the frequency of such reviews, with mechanisms to adjust those downwards when representatives express concern, or upwards after previous successful reviews.</li>
<li>Selecting tools and establishing processes for tracking the Council's backlog/todo list, making as much of that list as possible public for transparency, and having a well-defined mechanism for Project members or teams to ask the Council to address something (either publicly or privately).</li>
<li>Defining and documenting processes for external requests to the Council from outside the Project, ensuring they get routed appropriately, and taking steps where possible to ensure they can be directly routed to appropriate teams (potentially including new teams) in the future.</li>
<li>Bootstrapping the new &quot;Launching Pad&quot; team and ensuring it has enough structure to operate.</li>
<li>Organizing teams within Rust, and ensuring all teams and other governance structures are &quot;attached&quot; to appropriate places in the structure. (This includes working with teams to find appropriate homes, and ensuring such changes are ultimately reflected in the team metadata repository.)</li>
<li>Establishing and agreeing on processes for faster decision-making for simple one-off operational matters, such as responding to emails reaching out to the Project.</li>
<li>Ensuring the policy decision process (RFC process) is well-documented and linked from the Council documentation, so people know how Council public proposals happen.</li>
<li>Develop handoff procedures for handling transitions to new Council representatives, or to alternates.</li>
</ul>
<h2 id="other-tasksgaps-potentially-within-the-councils-purview"><a class="header" href="#other-tasksgaps-potentially-within-the-councils-purview">Other tasks/gaps potentially within the Council's purview</a></h2>
<ul>
<li>Checking in with teams and individuals across the Project, seeing what's going well and what needs help, and adding to the Council's todo list.
<ul>
<li>Checking for priority items that need <em>urgent</em> help from the Council.</li>
<li>Checking in with members of the former core team to identify items from their past todo lists and other open issues they're aware of, to add to the Council's todo list, and subsequently to either work on or delegate or otherwise disposition.</li>
<li>Checking in with the moderation team, to ensure they have sufficient support and resources to ensure growth and sustainability. Collaborating with the moderation team as they develop and codify their policies and procedures to better handle a broader range of situations across the Project.</li>
<li>Helping to develop plans to support understaffed or otherwise unsustainable teams.</li>
</ul>
</li>
<li>Work with the infra team to develop a transition plan for privileges traditionally maintained by core (such as root privileges / logged-use break-glass credentials). Coordinate appropriate policies with infra.</li>
<li>Working with the Launching Pad team to help transition teams out of it into appropriate places in the organization.</li>
<li>Ensuring that top-level teams have well-documented purviews, starting to identify gaps between those purviews, and working with teams to determine when those gaps should fall to specific existing teams or become the purview of new teams.</li>
<li>Establishing policies to enable delegation of communication/PR tasks that have traditionally fallen to top-level leadership, and then making appropriate delegations of such work, potentially including the creation of teams.</li>
<li>Working with teams to establish coordination channels for team roadmaps, and developing processes to support cohesion across those roadmaps.</li>
<li>Making concrete plans to improve Rust Project diversity, including working with individual teams on how to better support diversity initiatives, as well as addressing gaps for which no individual team currently has responsibility.</li>
<li>Working with teams on processes for receiving feedback from subteams, particularly on proposed Council representatives. Particular attention should be paid to:
<ul>
<li>Ensure feedback is processed early, often, fairly, and consistently such that subteam members feel heard and Council members are given opportunity to address feedback and improve.</li>
<li>Help detect and address bias in Council representative selection, including status-quo bias towards existing Rust leaders or people similar to them.</li>
</ul>
</li>
<li>Documenting and improving processes for interaction with the Rust Foundation, and considering organizational improvements to provide further ongoing support for those interactions (such as how and where Project directors fit into the organizational structure and how they interface with the Council regularly).
<ul>
<li>In particular, establishing the purview of the Project directors along with policies and procedures for ensuring proper representation of Project interests on the Foundation board.</li>
</ul>
</li>
<li>Establishing proper procedures, and potentially teams, for handling issues which may have legal implications on the Project or Project participants.</li>
<li>Ensuring that people and teams within the Rust Project have access to appropriate training and resources for the positions they find themselves in, beyond the skills required for their direct purview. Foster a culture of team membership that values such skills and help teams find resources or training to bolster such skills. Such skills and training include, among many others:
<ul>
<li>General leadership and coordination skills, within a team and across a community</li>
<li>Transparent and legible reasoning skills, recognizing and documenting underlying values, crux-finding, and collaborative disagreement</li>
<li>Conflict resolution and de-escalation</li>
<li>Project management and planning</li>
<li>Communications between individuals, teams, and projects</li>
<li>Public communications</li>
</ul>
</li>
<li>Help teams evaluate and consider replicating useful aspects of the Council's structure and processes within other teams across the Project (particularly top-level teams), such as:
<ul>
<li>Appropriate structures to help subteams collaborate and coordinate amongst themselves and with top-level teams</li>
<li>Structures for decision-making, including policies allowing for some types of decisions to be made more quickly, where appropriate</li>
<li>Transparency, privacy, and documentation of decisions</li>
<li>Policies for handling conflicts of interest among team members</li>
<li>Policies on the number of team members sharing a common affiliation</li>
</ul>
</li>
<li>Ensure Project and Project member health by understanding and working against common work patterns where select &quot;heroes&quot; assume an outsized and unreasonable share of the maintenance burden by:
<ul>
<li>taking on large amounts of essential work that they do not really <em>want</em> to do because no one else volunteers</li>
<li>taking on so much work (either voluntarily or out of seeming necessity) that they are prone to burnout</li>
<li>taking on work no one else has the ability to do and for which the member's absence would lead to potential crises in the Project</li>
</ul>
</li>
<li>Evaluating improvements to the RFC decision process, such as tracking and supporting multiple potential outcomes and changes in people's preferences without restarting decisions, and providing lighter-weight mechanisms for reversible decisions.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Commit: <a href="https://github.com/rust-lang/rfcs/blob/075f4b30f5c33315163c8e6a75e3210af6229ded/text/3392-leadership-council/motivation.md">The commit link this page based on</a></li>
</ul>
<h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p>The Rust Project is composed of hundreds of globally distributed individuals each of whom have very different motivations for working on Rust. Rust's open culture allows for these individuals to collaborate in a productive manner where complex technical and organizational decisions are made through consensus building and stakeholder feedback.</p>
<p>Rust's model for project management and decision-making delegates most decisions to the appropriate team. Teams are ultimately accountable for their purview. While teams' decision-making processes do not strictly need to be consensus based, stakeholder feedback is repeatedly solicited to ensure a plethora of opinions on each matter are considered and factored in.</p>
<p>However, at times this leads to issues. These issues can be summarized by the following questions which do not have clear answers in Rust's current governance model:</p>
<ul>
<li>What happens when it is unclear which teams' purviews a certain decision falls under?</li>
<li>Who is in charge of important but non-urgent work that is not clearly owned by an existing team?</li>
<li>Who is accountable when that work does not happen and organizational debt accrues?</li>
<li>How are teams in the Project held accountable to each other and to the wider Project?</li>
</ul>
<p>Examples of the type of work in question include the following. Please note that this list is far from exhaustive and is merely meant to give an impression of the type of work in question:</p>
<ul>
<li>Helping identify gaps where existing teams are struggling to accomplish work or grow to meet challenges.</li>
<li>Establishing large structural changes such as the Rust Foundation or new top-level teams.</li>
<li>Project self-reflection. What aspects of Project operations are less than ideal? What do we do to change course?</li>
<li>Project-wide community management. While individual teams can ensure that their teams are welcoming places, how do we ensure that the Project as a whole is?</li>
<li>Policy work, for policies that have ramifications across the Project or even legal ramifications.</li>
<li>Ensuring teams coordinate their work so that the Rust Project produces results greater than the sum of the output of the individual teams.</li>
</ul>
<p>While the current system does at times lead to positive outcomes in the above scenarios, it often does not. Some examples of failure mode categories include:</p>
<ul>
<li>No one is accountable for a decision and so the decision goes unmade, leaving it undefined. This requires solutions to repeatedly be developed either &quot;off the cuff&quot; or from first principles. This requires enormous amounts of energy and often leads to work not being done well or at all. In some cases it can even lead to burning out Project participants.</li>
<li>Much Project work that is non-urgent often does not get done. This can lead to processes and procedures that are done not because they are the best way to handle a situation but simply because they are the easiest. This can lead to outcomes that are unfair or even actively harmful to individuals. In general, working this way leads to a culture of &quot;putting out fires&quot; instead of actively fostering improvements.</li>
<li>The solutions to many of the issues facing the Rust Project require coordinated action across many different teams. Finding solutions for these issues requires investment at the organizational level, and it is often very difficult for individuals to coordinate and implement such structural investment.</li>
<li>Still, such Project work is often taken up by motivated individuals who then lack structural support for accomplishing goals leading to frustration and at times conflict and burnout.</li>
</ul>
<p>Historically, the core team delegated authority to &quot;top-level&quot; teams who have further delegated authority to subteams or other governance structures. However, since the work outlined above is often Project-wide and outside the purview of individual teams, delegation was sometimes difficult. As a result, the core team assumed the following two responsibilities:</p>
<ul>
<li>Identifying, prioritizing, and advertising that certain important work needs to get done and does not fall under the purview of an existing team</li>
<li>Attempting to do that work</li>
</ul>
<p>Through experience by the core team, it has become clear that both the identification of problems <em>and</em> the actual work itself is far too much for a single team. This has led to less than ideal results and in some cases, burnout. While a small amount of work requires urgent and immediate action, the vast majority of work would benefit from being tracked and handled by dedicated governance structures.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Commit: <a href="https://github.com/rust-lang/rfcs/blob/075f4b30f5c33315163c8e6a75e3210af6229ded/text/3392-leadership-council/non-goals.md">The commit link this page based on</a></li>
</ul>
<h1 id="non-goals-of-this-rfc"><a class="header" href="#non-goals-of-this-rfc">Non-goals of this RFC</a></h1>
<p>The following are non-goals of this RFC. These may be met in future RFCs but are explicitly not part of this RFC.</p>
<p>Non-goal #1: <em>Laying out the complete policies and procedures of the Council</em>. While the RFC lays out and bounds the structure of the Council, the Council's full policies and procedures will be created by the Council itself. It is also expected that the Council will change and adapt to meet the needs of the Rust Project as it evolves.</p>
<p>Non-goal #2: <em>Addressing all governance and potential governance concerns</em>. One of the Council's responsibilities will be to identify and reflect on the issues present in governance, but we see the formation of the Council as part of a continuous process of improving Rust's leadership and how it meets the needs of the Project.</p>
<p>Non-goal #3: <em>Forming additional teams</em>. The focus of this RFC is to form the Council and does not include the creation of additional teams, subteams, or groups of any kind.</p>
<p>We recognize the importance of having additional teams, but see this as outside of the scope of this RFC. Instead, it will be the responsibility of the Council to investigate and understand such needs and then create additional teams to ultimately handle these issues.</p>
<p>This has one exception, other than the Council itself: the &quot;launching pad&quot; top-level team, which provides a temporary grouping of teams not yet attached to any existing top-level team either directly or indirectly.</p>
<p>Non-goal #4: <em>Altering the charters or purviews of existing teams</em>. While this RFC does discuss membership in the Council, it does not extend beyond this to update the charter or purview of any existing team. Existing teams continue to follow their existing charters and purviews.</p>
<p>This has two exceptions:</p>
<ul>
<li>the core team: As part of this RFC, all of the capabilities and responsibilities of the core team move to the Council and are then clarified, modified, and constrained by the rest of this RFC.</li>
<li>the moderation team: As this RFC covers topics like conflict resolution and Council oversight, it does define additional capabilities for the moderation team, as well as additional checks and balances providing bidirectional oversight between the moderation team and the Council.</li>
</ul>
<p>Non-goal #5: <em>Establishing completely immutable properties of the Council</em>. Any aspect established in this RFC can be modified in the future, via the public policy decision-making process, with oversight provided by that process. This RFC lays out policies for making such changes, and the processes of changing such policies must follow the existing policies.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>我們歡迎任何協助，非常感謝你願意一起支援這個社群！</p>
<h2 id="授權條款"><a class="header" href="#授權條款">授權條款</a></h2>
<p>此專案的授權條款和其他 Rust 專案一樣都是 MIT/Apache2。你可以在 <code>LICENSE-*</code> 檔案中閱讀條款全文</p>
<h2 id="行為準則"><a class="header" href="#行為準則">行為準則</a></h2>
<p>Rust 專案有一個 <a href="http://rust-lang.org/policies/code-of-conduct">行為準則</a>會囊括其下專案，這當然包含此專案。請遵守這些準則！</p>
<h2 id="翻譯流程"><a class="header" href="#翻譯流程">翻譯流程</a></h2>
<p>我們的 <a href="https://github.com/rust-tw/rfcs/pulls">open pull requests</a> 接受任何翻譯或修正文章的 PR。在想開始翻譯一篇 RFC 前請先開一個 issue，如果你有希望被翻譯的也一樣歡迎開。翻譯完文章後請在每一篇文底加上以下以下資訊：</p>
<pre><code>translators: [Firstname Lastname &lt;email@address.tld&gt;]
commit: [The commit link this page based on](https://github.com/rust-lang/rfcs/...)
updated: YYYY-MMM-DD
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
