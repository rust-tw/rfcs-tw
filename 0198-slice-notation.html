<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>0198-slice-notation - The Rust RFC Book</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="0049-match-arm-attributes.html">0049-match-arm-attributes</a></li><li class="chapter-item expanded "><a href="0198-slice-notation.html" class="active">0198-slice-notation</a></li><li class="chapter-item expanded "><a href="1548-global-asm.html">1548-global-asm</a></li><li class="chapter-item expanded "><a href="1598-generic_associated_types.html">1598-generic_associated_types</a></li><li class="chapter-item expanded "><a href="2000-const-generics.html">2000-const-generics</a></li><li class="chapter-item expanded "><a href="2342-const-control-flow.html">2342-const-control-flow</a></li><li class="chapter-item expanded "><a href="2394-async_await.html">2394-async_await</a></li><li class="chapter-item expanded "><a href="2495-min-rust-version.html">2495-min-rust-version</a></li><li class="chapter-item expanded "><a href="2592-futures.html">2592-futures</a></li><li class="chapter-item expanded "><a href="2789-sparse-index.html">2789-sparse-index</a></li><li class="chapter-item expanded "><a href="2843-llvm-asm.html">2843-llvm-asm</a></li><li class="chapter-item expanded "><a href="3128-io-safety.html">3128-io-safety</a></li><li class="chapter-item expanded "><a href="3151-scoped-threads.html">3151-scoped-threads</a></li><li class="chapter-item expanded "><a href="3392-leadership-council.html">3392-leadership-council</a></li><li class="chapter-item expanded "><a href="alternatives.html">alternatives</a></li><li class="chapter-item expanded "><a href="initial-work-of-the-council.html">initial-work-of-the-council</a></li><li class="chapter-item expanded "><a href="motivation.html">motivation</a></li><li class="chapter-item expanded "><a href="non-goals.html">non-goals</a></li><li class="chapter-item expanded affix "><a href="CONTRIBUTING.html">Contributing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <ul>
<li>Start Date: 2014-09-11</li>
<li>RFC PR #: <a href="https://github.com/rust-lang/rfcs/pull/198">rust-lang/rfcs#198</a></li>
<li>Rust Issue #: <a href="https://github.com/rust-lang/rust/issues/17177">rust-lang/rust#17177</a></li>
<li>Translators: [<a href="https://github.com/FizzyElt">@FizzyElt</a>]</li>
<li>Commit: <a href="https://github.com/rust-lang/rfcs/blob/4009b546172c558a1cfa0f39dd81c896312f73d5/text/0198-slice-notation.md">The commit link this page based on</a></li>
<li>Updated: 2022-05-27</li>
</ul>
<h1 id="概要"><a class="header" href="#概要">概要</a></h1>
<p>此 RFC 增加了<em>多載切片符號</em>：</p>
<ul>
<li><code>foo[]</code> 對應 <code>foo.as_slice()</code></li>
<li><code>foo[n..m]</code> 對應 <code>foo.slice(n, m)</code></li>
<li><code>foo[n..]</code> 對應 <code>foo.slice_from(n)</code></li>
<li><code>foo[..m]</code> 對應 <code>foo.slice_to(m)</code></li>
<li>以上所有的 <code>mut</code> 變體</li>
</ul>
<p>透過<code>Slice</code> 跟 <code>SliceMut</code> 兩個新特徵（trait）。</p>
<p>它還將 範圍<code>配對</code>模式的符號改為 <code>...</code>，以表示它們是包含的，而 <code>..</code> 在切片中是不包含的。</p>
<h1 id="動機"><a class="header" href="#動機">動機</a></h1>
<p>引入此功能有兩個主要動機。</p>
<h3 id="人因工程"><a class="header" href="#人因工程">人因工程</a></h3>
<p>在處理 vector 或其他類型的容器時，切片操作（特別是 <code>as_slice</code>）是相當常見的基本操作。我們已經有了透過 <code>Index</code> 特徵進行索引的語法，此 RFC 本質上是這特徵的延續。</p>
<p><code>as_slice</code> 運算子尤其重要，自從我們已經擺脫以強迫的方式自動切片，明確地呼叫 <code>as_slice</code> 變得非常普遍，這也是語言中<a href="https://github.com/rust-lang/rust/issues/14983">人因工程優先/第一印象</a>的問題之一。還有一些其他方法可以解決這個特定問題，但這些替代方法具有下方討論的一些缺點（參閱「替代方案」）。</p>
<h3 id="錯誤處理協定"><a class="header" href="#錯誤處理協定">錯誤處理協定</a></h3>
<p>我們正在逐漸走向一個類似 Python 的世界，像是當 <code>n</code> 超出範圍時，<code>foo[n]</code> 會呼叫 <code>fail!</code>，而相應的方法像是 <code>get</code> 則返回 <code>Option</code> 而不是失敗。透過為切片提供類似的符號，我們打開了在整個 vector-like APIs 中遵循相同協定的大門。</p>
<h1 id="詳細設計"><a class="header" href="#詳細設計">詳細設計</a></h1>
<p>此設計是對 <code>Index</code> 特徵設計的直接延續。我們引入了兩個新特徵（trait），用於不可變與可變切片：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Slice&lt;Idx, S&gt; {
    fn as_slice&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a S;
    fn slice_from(&amp;'a self, from: Idx) -&gt; &amp;'a S;
    fn slice_to(&amp;'a self, to: Idx) -&gt; &amp;'a S;
    fn slice(&amp;'a self, from: Idx, to: Idx) -&gt; &amp;'a S;
}

trait SliceMut&lt;Idx, S&gt; {
    fn as_mut_slice&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut S;
    fn slice_from_mut(&amp;'a mut self, from: Idx) -&gt; &amp;'a mut S;
    fn slice_to_mut(&amp;'a mut self, to: Idx) -&gt; &amp;'a mut S;
    fn slice_mut(&amp;'a mut self, from: Idx, to: Idx) -&gt; &amp;'a mut S;
}
<span class="boring">}</span></code></pre></pre>
<p>（請注意，此處的可變名稱是命名規則可能更改的一部分，將在單獨的 RFC 中描述）。</p>
<p>這些特徵將在解釋以下符號時使用：</p>
<p><em>不可變切片</em></p>
<ul>
<li><code>foo[]</code> 對應 <code>foo.as_slice()</code></li>
<li><code>foo[n..m]</code> 對應 <code>foo.slice(n, m)</code></li>
<li><code>foo[n..]</code> 對應 <code>foo.slice_from(n)</code></li>
<li><code>foo[..m]</code> 對應 <code>foo.slice_to(m)</code></li>
</ul>
<p><em>可變切片</em></p>
<ul>
<li><code>foo[mut]</code> 對應 <code>foo.as_mut_slice()</code></li>
<li><code>foo[mut n..m]</code> 對應 <code>foo.slice_mut(n, m)</code></li>
<li><code>foo[mut n..]</code> 對應 <code>foo.slice_from_mut(n)</code></li>
<li><code>foo[mut ..m]</code> 對應 <code>foo.slice_to_mut(m)</code></li>
</ul>
<p>像 <code>Index</code> 一樣，這種表示法的使用將自動取值，就如同對應的方法調用一樣。因此，如果 <code>T</code> 實現了 <code>Slice&lt;uint, [U]&gt;</code> 和 <code>s: Smaht&lt;T&gt;</code>，那麼 <code>s[]</code> 就可以編譯並具有 <code>&amp;[U]</code> 類型。</p>
<p>請注意，切片是「不包含」（因此 <code>[n..m]</code> 是等於 <code>n &lt;= x &lt; m</code>），而模式配對中的 <code>..</code> 是「包含」。為了避免混淆，我們建議將配對符號更改為 <code>...</code> 來做出區別。更改符號而不是解釋的原因是，「不包含」（分別「包含」）解釋是切片（相較於「配對」）的正確默認值。</p>
<h2 id="使用此語法的基本理由"><a class="header" href="#使用此語法的基本理由">使用此語法的基本理由</a></h2>
<p>用於切片的方括號的選擇很簡單：它與我們的索引表示法契合，並且切片和索引密切相關。</p>
<p>其他一些語言（如 Python 和 Go 和 Fortran）在切片表示法中使用 <code>:</code> 而不是 <code>..</code>。在 Rust 中，<code>..</code> 的選擇受到 Rust 本身其他地方的使用影響，例如固定長度陣列類型 <code>[T, ..n]</code>。用於切片的 <code>..</code> 在 Perl 和 D 中有先例。</p>
<p>有關程式語言中切片表示法歷史的更多資訊，請參閱 <a href="http://en.wikipedia.org/wiki/Array_slicing">維基百科</a>。</p>
<h3 id="mut-限定符"><a class="header" href="#mut-限定符"><code>mut</code> 限定符</a></h3>
<p>可能令人驚訝的是，<code>mut</code> 在建議的切片表示法中作為限定符，而不是用於索引表示法。原因是索引包含隱式取消引用。假如 <code>v: Vec&lt;Foo&gt;</code> 則 <code>v[n]</code> 的類型為 <code>Foo</code>，而不是 <code>&amp;Foo</code> 或 <code>&amp;mut Foo</code>。因此，如果你想透過索引取得可變引用，你可以寫成 <code>&amp;mut v[n]</code>。更廣泛地說，這允許我們在解決可變性之前進行解析/類型檢查。</p>
<p>這種對 <code>Index</code> 的處理符合 C 的傳統，並允許我們寫成 <code>v[0] = foo</code>，而不是 <code>*v[0] = foo</code>。</p>
<p>另一方面，這種方法對於切片是有問題的，因為一般來說，他會產生一個 unsized 類型（在 DST 中），當然，切片是為了給你一個指向切片大小的胖指標，我們不希望立即取消引用。但是，這樣的結果是，我們需要預先知道切片的可變性，因為它決定了表達式的類型。</p>
<h1 id="缺點"><a class="header" href="#缺點">缺點</a></h1>
<p>主要的缺點是增加了語言語法的複雜度。這看起來微不足道，尤其是因為這裡的符號本質上是 &quot;完成&quot; 以 <code>Index</code> 特徵開始的內容。</p>
<h2 id="設計上的限制"><a class="header" href="#設計上的限制">設計上的限制</a></h2>
<p>與 <code>Index</code> 特徵一樣，這迫使結果透過 <code>＆</code> 成為一個引用，這可能會排除切片的普遍化。</p>
<p>解決此問題的一個方法是切片方法使用 <code>self</code> （依值) 而不是 <code>&amp;self</code>，反過來在 <code>&amp;T</code> 而不是 <code>T</code> 上實現特徵。這個方法是否長期可行將取決於方法解析和自動引用的最終規則。</p>
<p>一般來說，當特徵可以應用於類型 <code>T</code> 而不是借用類型 <code>&amp;T</code> 時，特徵系統運作的最好。最終，如果 Rust 獲得了更高的類型（HKT），我們可以將特徵中的切片類型 <code>S</code> 更改為更高的類型，這樣他就是一個由生命週期索引的類型<em>家族</em>。然後，我們可以用 <code>S&lt;'a&gt;</code> 來代替返回值中的 <code>&amp;'a S</code>。在未來，我們應該可以從當前的 <code>Index</code> 和 <code>Slice</code> 特徵設計轉換到一個 HKT 版本，而不會破壞相後的兼容性，方法是對實現舊特徵的類型使用新特徵的全面實現（例如 <code>IndexHKT</code>）。</p>
<h1 id="替代方案"><a class="header" href="#替代方案">替代方案</a></h1>
<p>對於改善 <code>as_slice</code> 的易用性，有兩個主要替代方案。</p>
<h2 id="強制-自動切片"><a class="header" href="#強制-自動切片">強制: 自動切片</a></h2>
<p>一種可能性是重新引入某種自動切片的強制。我們曾經有一個從（用現今的話來說）<code>Vec&lt;T&gt;</code> 到 <code>&amp;[T]</code> 的強制轉換。由於我們不再強制擁有借來的值，我們現在可能想要一個強制 <code>&amp;Vec&lt;T&gt;</code> 到 <code>&amp;[T]</code> 的轉換：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn use_slice(t: &amp;[u8]) { ... }

let v = vec!(0u8, 1, 2);
use_slice(&amp;v)           // automatically coerce here
use_slice(v.as_slice()) // equivalent
<span class="boring">}</span></code></pre></pre>
<p>不幸的是，添加這樣的強制需要在以下選項中進行選擇：</p>
<ul>
<li>
<p>將強制與 <code>Vec</code> 和 <code>String</code> 連繫起來，這將重新引入對這些原本純粹的函式庫類型的特殊處理，並且意味著其他支援切片的函數庫類型不會受益（違背了一些 DST 的目的）。</p>
</li>
<li>
<p>透過特徵使強制可擴展。然而這是在打開潘朵拉的盒子：這個機制很可能被用來在強制的過程中運行任意的程式碼，所以任何呼叫 <code>foo(a, b, c)</code> 都可能涉及運行程式碼來預處理每個參數。雖然我們最終可能想要這種使用者可擴展的強制機制，但在理解程式碼時，這是一個很<strong>大</strong>的步驟，有很多潛在的不利因素，所以我們應該先追求更保守的解決方案。</p>
</li>
</ul>
<h2 id="解引用"><a class="header" href="#解引用">解引用</a></h2>
<p>另一種可能是讓 <code>String</code> 實現 <code>Deref&lt;str&gt;</code> 和 <code>Vec&lt;T&gt;</code> 實現 <code>Deref&lt;[T]&gt;</code> 一旦 DST 登陸。這樣做將允許顯式的強制機制，例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn use_slice(t: &amp;[u8]) { ... }

let v = vec!(0u8, 1, 2);
use_slice(&amp;*v)          // take advantage of deref
use_slice(v.as_slice()) // equivalent
<span class="boring">}</span></code></pre></pre>
<p>但是，這樣做至少有兩個缺點：</p>
<ul>
<li>
<p>目前不清楚方法解析規則最終將如何與 <code>Deref</code> 互動。特別是，一個領先的提議是，對於一個智慧指標 <code>s: Smaht&lt;T&gt;</code> ，當你呼叫 <code>s.m(...)</code> 時，對於 <code>Smaht&lt;T&gt;</code> 只有 <em>內置</em> 方法 <code>m</code> 被考慮到；僅考慮最大引用值 <code>*s</code> 的特徵方法。</p>
<p>使用這樣的解析策略，為 <code>Vec</code> 實現 <code>Deref</code> 將使得我們無法在 <code>Vec</code> 類型上使用特徵方法 ，除非透過 UFCS，這嚴重限制了程式設計師為 <code>Vec</code> 有效地實現新特徵的能力。</p>
</li>
<li>
<p>將 <code>Vec</code> 作為一個圍繞切片的智慧指標的想法，以及如上所述的 <code>&amp;*v</code> 的使用，有點違反直覺，特別是對於這樣的基本類型。</p>
</li>
</ul>
<p>追根究底，無論如何，切片的符號本身似乎是可取的，如果它能消除對 <code>Vec</code> 和 <code>String</code> 實現 <code>Deref</code> 的需要，那就更好了。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="0049-match-arm-attributes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="1548-global-asm.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="0049-match-arm-attributes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="1548-global-asm.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
