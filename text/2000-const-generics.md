- Feature Name: `const_generics`
- Start Date: 2017-05-01
- RFC PR: [rust-lang/rfcs#2000](https://github.com/rust-lang/rfcs/pull/2000)
- Rust Issue: [rust-lang/rust#44580](https://github.com/rust-lang/rust/issues/44580)
- Translators: [[@yanganto](https://github.com/yanganto)]
- Commit: [The commit link this page based on](https://github.com/rust-tw/rfcs-tw/blob/725bf172f383a21cf74189feb5073705778d2206/text/2000-const-generics.md)
- Updated: 2021-03-26

# 總結
[總結]: #總結

允許所有類型（type）以作為常數值（constant values）的形式成為泛型（generic）；由此將允許使用者以撰寫所有陣列類型（array types）之抽象的實作（impls）。

# 動機
[動機]: #動機

現今 Rust 具有一種以常數參數化（parametric）類型︰內建陣列類形`[T; LEN]`。然而，常數泛型（const generics）並非一級特徵，使用者無法以常數形式定義自己的泛型，且不能對所有的陣列實作特徵（traits）。

於此限制下，標準庫僅包含了長度為 32 之陣列的實作，而陣列一般作為語言的二級特徵。即使在長度可靜態已知的情形下，也大多調配於堆（heap）上成為向量而非使用陣列類型。（造成了一定程度上的效能取捨）

常數參數亦可讓使用者更自然的指定一個泛型變數, 且相比於類型更確切的反應其值。例如，如果由於某些因素而用一個值類型的名稱作為參數，其可比以一個單元類型（unit type）的形式來提供名稱更合理的（藉由相關的常數或是函數）以`&'static str`的形式來提供其名稱。這是更簡易的API。


總結來說，常數可用作參數使用，讓編譯器可在型別檢查時期將確定了這些值。藉由此限制在編譯時檢查來評估一個特徵是否實作過，孤兒規則可以確保一個箱（crate）僅使用部份安全的值。（例如，有關密碼學之相關函式庫）


# 設計細節
[設計]: #設計細節

現今，Rust 中的型別可以兩種形式參數化︰類型與生命周期化。如同在編譯時運算這些值的方式，我們將額外的允許類型以值的形數參數化。一個單一常數參數必為單一、特定類型，且可以有效的置換為編譯時期計算出的任意值且該類型將符合本RFC於後列出的要求。


（為明確在此RFC闡明哪些表達式可在編譯時評估，在之後的範例中，我們假設整數及其基本算數操作可以在編譯時計算。）

## 詞彙表

* <b>常數（constant, const value）︰</b>一個在編譯時期可以保證完全評估的 Rust 值。不同於靜態值，常數將在其使用的位置內聯而非存在於編譯好的二進制檔案的資料區段。

* <b>常數參數（泛型常數）︰</b>一個由類型或函式抽象而得到的常數。此常數是具體類型的輸入，例如一個靜態陣例的長度。

* <b>關聯常數︰</b>一個由特徵關聯而得到的常數，其相似於關聯的類型。不同於常數參數，關聯常數是由類型所決定的。

* <b>常數變數︰</b>相比於具體常數，常數參數或關聯常數皆為常數變數。在單態化之前，一個常數在上下文中是未確定的。

* <b>具體常數︰</b>相比於常數變數，一個在上下文中已知且單一值的常數。

* <b>常數表達式︰</b>一個用於評估一個常數的表達式。此可為一個身份表達式或一個在 Rust 常數系統中可以評估出的更複雜的表達式。

* <b>抽象常數表達式︰</b>一個包含常數變數的表達式。（因此在單態化結束前其值是無法評估的）

* <b>常數投影︰</b>抽象常數表達式之值（其在泛型上下文中因缺乏所依賴的常數變數而無法被定義）

* <b>身份表達式︰</b>一個在不以其範圍內的名稱進行置換則無法評估的表達式。此包括了所有的文字及身份（ident），例如，`3`、`"Hello, world"`、`foo_bar`。

## 宣告一個常數參數

可在類型參數宣告之任何序列中宣告常數參數（例如在一個類型的定義中或是在`impl`的標頭或區塊中）。常數參數可以用`const $ident: $ty`之形式。

```rust
struct RectangularArray<T, const WIDTH: usize, const HEIGHT: usize> {
    array: [[T; WIDTH]; HEIGHT],
}
```

這些常數參數（在本RFC內文中可替稱作「常數變數」）使用名稱進行身份（ident）的進行宣告，且所有值必定可歸因於其類型。於此可歸因於之類型將於本RFC後文說明其限制。

常數變數可宣告於在此項目（type、impl、function、method、…等）的整體範圍中。

## 採用一個常數作為參數

任何可歸因於常數參數之常數表達式的類型將可用作參數。除了陣列外，當採用一個表達式作為參數且該表達式非一身份表達式時，該表達式必包含於一區塊中 。此語法上的限制是必要的以避免在類型中解析表達式需要無限的向前展望（lookahead）。


```rust
const X: usize = 7;

let x: RectangularArray<i32, 2, 4>;
let y: RectangularArray<i32, X, {2 * 2}>;
```

### 陣列
陣列語法中有一個特別的構造語法：`[T; CONST]`。在陣列中大括號是不在需要的存在於任何的常數表達式中，`[i32; N * 2]`是一個合規的類型。

## 何時可使用常數變數

常數變數可使用於下列上下文之任一者中︰

1. 用於任一型別中的常數，該型別是待定之項目之簽章的一部份：`fn foo<const N: usize>(arr: [i32; N])`
2. 用於定義相關常數的常數表達式或相關類型之參數的一部份
3. 在項目中任何函數的內部之任何運行表達式中的一值
4. 在項目中任何函數內部用於任何類型的參數，例如在`let x: [i32; N]` or `<[i32; N] as Foo>::bar()`.
5. 在項目中任何欄位之類型的一部分（如，`struct Foo<const N: usize>([i32; N]);`）

在一般情況下，常數變數可以用做常數。但有一個明顯的例外是，常數變數不可用於常數、靜態類型、函數、或函數內的類型的建構子。意即下面的例子是不合規的。

```rust
fn foo<const X: usize>() {
    const Y: usize = X * 2;
    static Z: (usize, usize)= (X, X);

    struct Foo([i32; X]);
}
```

這個限制可比擬為使用來自函數中建造之類型的類型變數的限制。所有的宣告雖然專用於該項目，但也必需獨立於它，且不能有其他於其同範圍內的變數。

## 兩個變數的類型相等性之相等的原則

在統一且重疊的檢查期間，何時兩個類型是否相等是關重要的。因為類型現在可依賴於常數了，所以我們必須定義我們如何比較兩個常數表達式的相等性。

在大多數情況下，兩個常數的相等性會如同你的預期，如果兩個常數彼此相等，則它們相等。 但是容會有一些特別的警告。

### 結構相等性

根據[RFC 1445][1445]所說明之結構相等性之定義而定常數相等性。只有在類型是「結構相符」的情形下，該結構可用做結構參數。舉例來說，浮點數將會不相等。

在最終解決方案出來前，已針對常數進行匹配之結構相符的性質應作為權宜之計。無論變數參數採用什麼解決方案，確保相等是具有反射性（reflexive）對於類型相等之目的都是重要的，其使得類型始終相同。（浮點數相等的標准定義是不具反射性的。）

進行匹配和常數參數使用相同的相等性定義，可能會在某一天因使用的定義有所不同而發散，但是這是無關緊要的，現今所使用的相等性定義仍足以滿足我們的目的。

因為常數必須具有結構相符的性質，並且此屬性無法強制轉成一個類型變量，因此無法引入歸因於類型變量的參數於一個常數之中。（意即，`Foo <T，const N：T>`不是合規的）

### 兩個抽像表達式的相等性

在比較兩個抽象常數表達式（即，依賴於變數的表達式）的相等性時，我們無法比較其值的相等性，因其值是由常數變數所決定的，而在在單態化之前是未知的。

基於這個原因，我們將至少會將常數表達式的返回值當作投影（projections）。雖然其值仍保特未知，我們仍藉由輸入值來決定其值，這是作法相同於現在我們處理關聯類型（associated types）的作法。此作法我們將稱為常數投影（const projection），對另一個同類型的常數而言，我們永遠無法確定其相等性。

每個常數表達式都會生成一個新的投影，該投影本質上是匿名的。不可能使兩個匿名投影一致（想像兩個關聯類型之泛型`T :: Assoc`和`T :: Item`：你無法證明或否定它們是否為同一類型）。因此，除非它們從字面上使用完完全全相同的文字，否則常數表達式在AST節點中是彼此不一樣的。這意味著`N + 1`的一個實例不會與另一個`N + 1`的實例在類型相同。

更清楚來說，以下是無法通過類型檢查的，因為`N + 1`會是兩種不同的類型：

```rust
fn foo<const N: usize>() -> [i32; N + 1] {
    let x: [i32; N + 1] = [0; N + 1];
    x
}
```

但如果這樣撰寫，它將只有一個類型：

```rust
type Foo<const N: usize> = [i32; N + 1];

fn foo<const N: usize>() -> Foo<N> {
    let x: Foo<N> = Default::default();
    x
}
```

#### 未來展望與延伸

未來的某一天我們可以利用一些操作的基本屬性（例如加法和乘法的可交換性），而對常數投影的相等性做出更聰明的判斷。但是，本RFC並不打算在此提案中建造這些已知可能，而打算留給未來的 RFC。

## 常數變數的特異化

定義將常數參數特異化的順序也是很重要的。為此，將字面上的定義必需比其他表達式更具體，否則會表達式的定義的順序上產生不確定性。

正如我們有朝一日可以在常數投影上支持更進階的平等性一樣，我們可以支持更進階的定義特異性。例如，給定類型為`(i32, i32)`，我們可以確定`(0, PARAM2)`比`(PARAM1, PARAM2)`更為具體；`(i32, U)`比`(T, U)`更為具體。在未來的某天我們將來也有可能在常數特異化上支持多元交互（intersectional）和其他更進階的定義。

# 我們如何教導這個
[我們如何教導這個]: #我們如何教導這個

常數泛型是一個很大的功能，將需要大量的教育資料，這將會需要在書本跟參考文件，且可能會在書中有獨立的章節。常數泛型的文件化過程本質上將會是一個大工程。

然而，常數泛型應該被視為進階功能，並且應該在使用 Rust 的初期，我們可能不會向新用戶介紹這些內容。

# 缺點
[缺點]: #缺點
此功能由於允許類型由常數確定，將為類型系統增加了大量的複雜性。它需要抽象變數相等性的確定規則，這出現了很多令人意外的的特殊情況。它增加了 Rust 的很多語法。如果我們不要採用此功能，Rust 肯定會更簡單。

然而，我們已經引入了一種由常數確定的類型（數組類型）。泛型化之功能似乎是必然的，甚至是不可避免的，鑑於此，我們應該盡早決定。

# 替代方案
[替代方案]: #替代方案

除了暫緩執行或不執行外，並沒有真的替代方案。

我們將限制常數泛型為`usize`類型，但這不會讓實作更為簡單。

我們可以更快地往常數間更複雜的平等性概念之方向去，但這會使實作比上述說明的更加複雜。

我們可以選擇稍微不同的語法，例如將在常數跟類型間加上分號。

# 未解決問題
[未解決問題]: #未解決問題

- <b>一致的抽象常數表達式︰</b>本RFC盡可能最大限度地減少抽象常數表達式的統合性上的處理，從本質上來說，並沒有使其一致。這可能造成無法接受的使用者體驗的不穩定，而我們想要實作一些更進些的統合性之前穩定此功能。
- <b>常數表達式之正確格式︰</b>在單態化過程中，程式將不會採用應急措施（panic），此類型都被識為正確格式。這對於溢出和超出範圍的陣列存取來說很棘手。然而，我們實際上只能確保在函數的簽章中表達式常數的格式進行正確性約束。目前尚不清楚有關在函數中抽象常數表達式之格式正確性的處理方式，也因此使實作推遲。
- <b>排序與默認參數︰</b>所有常數參數是否將排在最後，或者將它們與類型混合嗎？具有默認值的參數是否須在沒有默認值之後？這些決定推遲到實作語法的討論中。

[1445]: https://github.com/rust-lang/rfcs/blob/master/text/1445-restrict-constants-in-patterns.md
